{"mappings":"C,A,W,S,E,C,E,O,G,E,W,E,Q,C,C,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,Q,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,K,E,Q,E,E,S,E,O,C,I,E,A,M,uB,E,I,O,E,K,mB,C,C,E,S,S,C,C,C,E,C,C,E,C,C,E,E,kB,G,I,E,E,SE6DO,SAAS,EAAM,CAAa,CAAE,CAAqB,CAAE,CAAqB,EAC7E,OAAO,KAAK,IAAI,EAAe,KAAK,IAAI,EAAe,GAC3D,CA2BO,MAAM,EACT,YACW,EAAY,CAAG,CACf,EAAY,CAAG,CACf,EAAY,CAAG,CACf,EAAY,CAAG,CACxB,CAJS,IAAA,CAAA,EAAA,EACA,IAAA,CAAA,EAAA,EACA,IAAA,CAAA,EAAA,EACA,IAAA,CAAA,EAAA,CACP,CAEJ,OAAO,QAAQ,CAAe,CAAQ,CAElC,IAAI,EAAS,4CAA4C,KAAK,GAC9D,GAAI,AAAW,OAAX,EACA,MAAM,AAAI,MAAM,CAAC,iBAAiB,EAAE,EAAQ,CAAC,EAEjD,OAAO,IAAI,EACP,SAAS,CAAM,CAAC,EAAE,CAAE,IACpB,SAAS,CAAM,CAAC,EAAE,CAAE,IACpB,SAAS,CAAM,CAAC,EAAE,CAAE,IACpB,IAER,C,O,C,C,C,A,C,KAEO,IAAA,CAAA,KAAO,IAAI,EAAK,EAAG,EAAG,EAAG,E,C,G,A,Q,C,C,C,A,C,KACzB,IAAA,CAAA,IAAM,IAAI,EAAK,EAAG,EAAG,EAAG,E,C,G,AACnC,CAIO,MAAM,EACT,YACW,EAAY,CAAG,CACf,EAAY,CAAG,CACxB,CAFS,IAAA,CAAA,EAAA,EACA,IAAA,CAAA,EAAA,CACP,CAEJ,UAAmB,CACf,MAAO,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE,EAAE,EAAE,IAAI,CAAC,EAAE,CAAC,CAAC,AACvC,C,O,C,C,C,A,C,KAGO,IAAA,CAAA,IAAM,IAAI,EAAK,EAAG,E,C,G,A,Q,C,C,C,A,C,KAClB,IAAA,CAAA,KAAO,IAAI,EAAK,EAAG,E,C,G,A,Q,C,C,C,A,C,KACnB,IAAA,CAAA,KAAO,IAAI,EAAK,EAAG,E,C,G,A,Q,C,C,C,A,C,KACnB,IAAA,CAAA,KAAO,IAAI,EAAK,EAAG,E,C,G,A,Q,C,C,C,A,C,KAEnB,IAAA,CAAA,KAAO,IAAI,EAAK,EAAG,E,C,G,A,Q,C,C,C,A,C,KACnB,IAAA,CAAA,IAAM,IAAI,EAAK,EAAG,E,C,G,AAEzB,QAAO,IAAI,CAAO,CAAE,CAAS,CAAE,CAAS,CAAQ,CAG5C,OAFA,EAAE,EAAI,EACN,EAAE,EAAI,EACC,CACX,CAEA,OAAO,KAAK,CAAO,CAAE,CAAU,CAAQ,CAInC,MAFA,AADA,CAAA,EAAM,GAAO,IAAI,CAAjB,EACI,EAAI,EAAE,EACV,EAAI,EAAI,EAAE,EACH,CACX,CAEA,OAAO,IAAI,CAAO,CAAE,CAAO,CAAE,CAAU,CAAQ,CAI3C,MAFA,AADA,CAAA,EAAM,GAAO,IAAI,CAAjB,EACI,EAAI,EAAE,EAAI,EAAE,EAChB,EAAI,EAAI,EAAE,EAAI,EAAE,EACT,CACX,CAEA,OAAO,IAAI,CAAO,CAAE,CAAO,CAAE,CAAU,CAAQ,CAI3C,MAFA,AADA,CAAA,EAAM,GAAO,IAAI,CAAjB,EACI,EAAI,EAAE,EAAI,EAAE,EAChB,EAAI,EAAI,EAAE,EAAI,EAAE,EACT,CACX,CAEA,OAAO,IAAI,CAAO,CAAE,CAAO,CAAE,CAAU,CAAQ,CAI3C,MAFA,AADA,CAAA,EAAM,GAAO,IAAI,CAAjB,EACI,EAAI,EAAE,EAAI,EAAE,EAChB,EAAI,EAAI,EAAE,EAAI,EAAE,EACT,CACX,CAEA,OAAO,IAAI,CAAO,CAAE,CAAO,CAAE,CAAU,CAAQ,CAI3C,MAFA,AADA,CAAA,EAAM,GAAO,IAAI,CAAjB,EACI,EAAI,EAAE,EAAI,EAAE,EAChB,EAAI,EAAI,EAAE,EAAI,EAAE,EACT,CACX,CAEA,OAAO,MAAM,CAAO,CAAE,CAAU,CAAQ,CAIpC,MAFA,AADA,CAAA,EAAM,GAAO,IAAI,CAAjB,EACI,EAAI,KAAK,MAAM,EAAE,GACrB,EAAI,EAAI,KAAK,MAAM,EAAE,GACd,CACX,CAEA,OAAO,OAAO,CAAO,CAAE,CAAU,CAAQ,CAIrC,MAFA,AADA,CAAA,EAAM,GAAO,IAAI,CAAjB,EACI,EAAI,CAAC,EAAE,EACX,EAAI,EAAI,CAAC,EAAE,EACJ,CACX,CAEA,OAAO,MAAM,CAAO,CAAE,CAAS,CAAE,CAAU,CAAQ,CAI/C,MAFA,AADA,CAAA,EAAM,GAAO,IAAI,CAAjB,EACI,EAAI,EAAE,EAAI,EACd,EAAI,EAAI,EAAE,EAAI,EACP,CACX,CAEA,OAAO,KAAK,CAAO,CAAE,CAAO,CAAE,CAAS,CAAE,CAAU,CAAQ,CAIvD,MAFA,AADA,CAAA,EAAM,GAAO,IAAI,CAAjB,EACI,EAAI,EAAE,EAAK,CAAA,EAAI,CAAA,EAAK,EAAE,EAAI,EAC9B,EAAI,EAAI,EAAE,EAAK,CAAA,EAAI,CAAA,EAAK,EAAE,EAAI,EACvB,CACX,CAEA,OAAO,SAAS,CAAW,CAAE,CAAY,CAAW,KA7IhC,EAAsC,EAAtC,EAAsC,EA8ItD,OAAO,AA9IS,EA8ID,EAAM,EA9IiC,EA8I3B,EAAO,EA7I/B,GA6IqB,GA7IK,EAAQ,IADrB,EA8IgC,EAAM,EA9IA,EA8IM,EAAO,EA7IhE,GA6IsD,GA7I5B,EAAQ,EA8IzC,CAGA,OAAO,SAAS,CAAW,CAAE,CAAY,CAAW,KA9I/B,EAAsC,EAAtC,EAAsC,EA+IvD,OAAO,AA/IU,EA+ID,EAAM,EA/IiC,EA+I3B,EAAO,EAAV,GA9ItB,GAA0B,EAAS,IAAO,IAD5B,EA+IiC,EAAM,EA/ID,EA+IO,EAAO,EA9IlE,AA8IwD,GA9IxD,GAA0B,EAAS,IAAO,EA+IjD,CAEA,OAAO,OAAO,CAAO,CAAW,CAC5B,OAAO,AAAQ,IAAR,EAAE,GAAW,AAAQ,IAAR,EAAE,CAC1B,CAEA,OAAO,OAAO,CAAO,CAAE,CAAO,CAAW,CACrC,OAAO,EAAE,IAAM,EAAE,GAAK,EAAE,IAAM,EAAE,CACpC,CAEA,OAAO,KAAK,CAAO,CAAE,CAAyB,CAAE,CAAU,CAAQ,CAI9D,MAFA,AADA,CAAA,EAAM,GAAO,IAAI,CAAjB,EACI,EAAI,EAAG,EAAE,GACb,EAAI,EAAI,EAAG,EAAE,GACN,CACX,CAEA,OAAO,KAAK,CAAO,CAAE,CAAO,CAAE,CAAoC,CAAE,CAAU,CAAQ,CAIlF,MAFA,AADA,CAAA,EAAM,GAAO,IAAI,CAAjB,EACI,EAAI,EAAG,EAAE,EAAG,EAAE,GAClB,EAAI,EAAI,EAAG,EAAE,EAAG,EAAE,GACX,CACX,CAEA,OAAO,gBAAgB,CAAO,CAAqB,QAC/C,AAAI,KAAK,IAAI,EAAE,IAAM,KAAK,IAAI,EAAE,GAC5B,AAAI,EAAE,GAAK,EACA,OAEA,OAGX,AAAI,EAAE,GAAK,EACA,OAEA,MAGnB,CACJ,CE5PA,a,I,E,E,S,E,C,E,E,C,EC2DI,EAAgB,WAAa,CAEjC,CAAA,EAAc,UAAY,CAEzB,IAAK,SAAS,CAAM,EACnB,IAAI,EAAG,EAAM,EAA4B,EAArB,EAAM,EAAO,OAC7B,EAAS,EAAM,EAAI,CAAM,CAAC,EAAE,CAAC,MAAQ,EACrC,EAAS,EAAM,EAAI,CAAM,CAAC,EAAE,CAAC,OAAS,EAE1C,IAAK,EAAI,EADT,IAAI,CAAC,KAAO,CAAE,EAAG,EAAG,EAAG,EAAG,MAAO,EAAO,OAAQ,CAAO,EAC3C,EAAI,EAAM,IACrB,EAAQ,CAAM,CAAC,EAAE,CACb,CAAA,EAAO,IAAI,CAAC,SAAS,IAAI,CAAC,KAAM,EAAM,MAAO,EAAM,OAAA,GACtD,EAAM,IAAI,CAAC,UAAU,EAAM,EAAM,MAAO,EAAM,QAC9C,EAAM,EAAI,EAAI,EACd,EAAM,EAAI,EAAI,IAGd,EAAM,IAAI,CAAC,SAAS,EAAM,MAAO,EAAM,QACvC,EAAM,EAAI,EAAI,EACd,EAAM,EAAI,EAAI,EAGjB,EAEA,SAAU,SAAS,CAAI,CAAE,CAAK,CAAE,CAAM,SACrC,AAAI,EAAK,KACD,IAAI,CAAC,SAAS,EAAK,MAAO,EAAO,IAAW,IAAI,CAAC,SAAS,EAAK,KAAM,EAAO,GAC1E,GAAS,EAAK,OAAW,GAAU,EAAK,OAC1C,EAEA,IACT,EAEA,UAAW,SAAS,CAAI,CAAE,CAAK,CAAE,CAAM,EAItC,OAHA,EAAK,KAAO,CAAA,EACZ,EAAK,KAAQ,CAAE,EAAG,EAAK,EAAW,EAAG,EAAK,EAAI,EAAQ,MAAO,EAAK,MAAe,OAAQ,EAAK,OAAS,CAAO,EAC9G,EAAK,MAAQ,CAAE,EAAG,EAAK,EAAI,EAAO,EAAG,EAAK,EAAY,MAAO,EAAK,MAAQ,EAAO,OAAQ,CAAqB,EACvG,CACR,EAEA,SAAU,SAAS,CAAK,CAAE,CAAM,EAC/B,IAAI,EAAgB,GAAU,IAAI,CAAC,KAAK,MACpC,EAAgB,GAAU,IAAI,CAAC,KAAK,OAEpC,EAAkB,GAAiB,IAAI,CAAC,KAAK,QAAW,IAAI,CAAC,KAAK,MAAS,EAC3E,EAAkB,GAAiB,IAAI,CAAC,KAAK,OAAW,IAAI,CAAC,KAAK,OAAS,SAE/E,AAAI,EACI,IAAI,CAAC,UAAU,EAAO,GACrB,EACD,IAAI,CAAC,SAAS,EAAO,GACpB,EACD,IAAI,CAAC,UAAU,EAAO,GACrB,EACD,IAAI,CAAC,SAAS,EAAO,GAErB,IACT,EAEA,UAAW,SAAS,CAAK,CAAE,CAAM,MAU5B,QACJ,CAVA,IAAI,CAAC,KAAO,CACX,KAAM,CAAA,EACN,EAAG,EACH,EAAG,EACH,MAAO,IAAI,CAAC,KAAK,MAAQ,EACzB,OAAQ,IAAI,CAAC,KAAK,OAClB,KAAM,IAAI,CAAC,KACX,MAAO,CAAE,EAAG,IAAI,CAAC,KAAK,MAAO,EAAG,EAAG,MAAO,EAAO,OAAQ,IAAI,CAAC,KAAK,MAAO,CAC3E,EAEI,EAAO,IAAI,CAAC,SAAS,IAAI,CAAC,KAAM,EAAO,IACnC,IAAI,CAAC,UAAU,EAAM,EAAO,GAE5B,IACT,EAEA,SAAU,SAAS,CAAK,CAAE,CAAM,MAU3B,QACJ,CAVA,IAAI,CAAC,KAAO,CACX,KAAM,CAAA,EACN,EAAG,EACH,EAAG,EACH,MAAO,IAAI,CAAC,KAAK,MACjB,OAAQ,IAAI,CAAC,KAAK,OAAS,EAC3B,KAAO,CAAE,EAAG,EAAG,EAAG,IAAI,CAAC,KAAK,OAAQ,MAAO,IAAI,CAAC,KAAK,MAAO,OAAQ,CAAO,EAC3E,MAAO,IAAI,CAAC,IACb,EAEI,EAAO,IAAI,CAAC,SAAS,IAAI,CAAC,KAAM,EAAO,IACnC,IAAI,CAAC,UAAU,EAAM,EAAO,GAE5B,IACT,CAED,EAEA,EAAiB,EDtJjB,EAAiB,SAAS,CAAK,CAAE,CAAO,EACvC,EAAU,GAAW,CAAC,EACtB,IAAI,EAAS,IAAI,EACb,EAAU,EAAQ,SAAW,CAAA,EAG7B,EAAW,EAAM,IAAI,SAAS,CAAI,EAAI,OAAO,EAAU,EAAO,CAAE,MAAO,EAAK,MAAO,OAAQ,EAAK,OAAQ,KAAM,CAAK,CAAG,GAE1H,EAAW,EAAS,KAAK,SAAS,CAAC,CAAE,CAAC,EAGrC,OAAQ,EAAE,MAAQ,EAAE,OAAW,EAAE,MAAQ,EAAE,MAC5C,GAEA,EAAO,IAAI,GAKX,IAAI,EAAM,CACT,MAJO,EAAS,OAAO,SAAS,CAAI,CAAE,CAAI,EAAI,OAAO,KAAK,IAAI,EAAM,EAAK,EAAI,EAAK,MAAQ,EAAG,GAK7F,OAJO,EAAS,OAAO,SAAS,CAAI,CAAE,CAAI,EAAI,OAAO,KAAK,IAAI,EAAM,EAAK,EAAI,EAAK,OAAS,EAAG,EAK/F,EAMA,OAJK,GACJ,CAAA,EAAI,MAAQ,CADb,EAIO,CACR,E,I,E,E,QD5BO,OAAM,EACT,YACW,CAAA,CACA,CAAA,CACA,CAAA,CACA,CAAA,CACT,CAJS,IAAA,CAAA,KAAA,EACA,IAAA,CAAA,IAAA,EACA,IAAA,CAAA,MAAA,EACA,IAAA,CAAA,OAAA,CACP,CACR,CFUA,IAAM,EAAK,SAAU,cAAc,MAA4B,WAAW,SAAU,CAAE,MAAO,CAAA,CAAM,GACnG,EAAG,WAAW,GAAK,GAAK,IAAM,GAC9B,EAAG,OAAO,EAAG,OACb,EAAG,UAAU,EAAG,UAAW,EAAG,qBAC9B,EAAA,0BAA+B,EAAG,QAClC,EAAG,SAAS,EAAG,EAAG,EAAG,mBAAoB,EAAG,qBAE5C,IAAM,EAAM,IEZL,MAgBH,YACW,CAAA,CACP,CAAgD,CAClD,CAFS,IAAA,CAAA,GAAA,EAXX,IAAA,CAAA,SAAmB,EAef,IAAI,CAAC,aAAe,EAAA,kBAAuB,EAAI,CAE3C,CAAC;;;;;;;;;;;;;;;;;YAiBD,CAAC,CAED,CAAC;;;;;;;;;;;;YAYD,CAAC,CACJ,EAGD,QAAQ,OAAQ,CAAA,EAAgC,qEAEhD,IAAI,CAAC,aAAe,IAAI,aAAa,MACrC,IAAI,CAAC,aAAe,EAAG,eACvB,EAAG,WAAW,EAAG,aAAc,IAAI,CAAC,cACpC,EAAG,WAAW,EAAG,aAAc,IAAI,CAAC,aAAc,EAAG,cAErD,IAAM,EAAiB,IAAI,YAAY,OACvC,IAAK,IAAI,EAAI,EAAG,EATM,KASa,GAAK,EAEpC,CAAc,CAAC,AAAI,EAAJ,EAAQ,EAAE,CAAG,AAtEpB,EAsEoB,EAAkB,EAC9C,CAAc,CAAC,AAAI,EAAJ,EAAQ,EAAE,CAAG,AAvEpB,EAuEoB,EAAkB,EAC9C,CAAc,CAAC,AAAI,EAAJ,EAAQ,EAAE,CAAG,AAxEpB,EAwEoB,EAAkB,EAE9C,CAAc,CAAC,AAAI,EAAJ,EAAQ,EAAE,CAAG,AA1EpB,EA0EoB,EAAkB,EAC9C,CAAc,CAAC,AAAI,EAAJ,EAAQ,EAAE,CAAG,AA3EpB,EA2EoB,EAAkB,EAC9C,CAAc,CAAC,AAAI,EAAJ,EAAQ,EAAE,CAAG,AA5EpB,EA4EoB,EAAkB,CAGlD,CAAA,IAAI,CAAC,YAAc,EAAA,2BAAgC,EAAI,CACnD,WAAY,CACR,OAAQ,IAAI,CAAC,aACb,cAAe,EACf,KAAM,aACN,OAAQ,EACR,OAAQ,EACZ,EACA,WAAY,CACR,OAAQ,IAAI,CAAC,aACb,cAAe,EACf,KAAM,aACN,OAAQ,EACR,OAAQ,EACZ,EACA,QAAS,CACL,KAAM,EACN,SAAU,EAAG,WACjB,CACJ,GAEA,IAAI,CAAC,SAAW,EAAA,sBAA2B,EAAI,IAAI,CAAC,aAAc,IAAI,CAAC,aAGvE,IAAI,EAME,EAAE,CACR,IAAK,GAAM,CAAC,EAAU,EAAS,GAAI,OAAO,QAAQ,GAAe,CAC7D,IAAI,EAAW,CAAQ,CAAC,EAAE,CAAC,OAAO,MAAM,MAAM,IAAI,AAAA,GAAK,EAAE,QACzD,EAAQ,KAAK,CACT,MAAO,AD5HhB,SAAa,CAAa,EAC7B,GAAI,AAAe,IAAf,EAAI,OAGR,OAAO,CAAG,CAAC,AAGR,SAAgB,CAAa,EAChC,GAAI,AAAe,IAAf,EAAI,OACJ,OAEJ,IAAI,EAAM,EACN,EAAU,CAAG,CAAC,EAAE,CACpB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,OAAQ,IACxB,CAAG,CAAC,EAAE,CAAG,IACT,EAAU,CAAG,CAAC,EAAE,CAChB,EAAM,GAGd,OAAO,CACX,EAhBsB,GAAM,AAC5B,ECuH2B,EAAS,IAAI,AAAA,GAAK,EAAE,SAC/B,OAAQ,EAAS,OACjB,SAAU,EACV,WAAY,CAAQ,CAAC,EAAE,CACvB,SAAU,CACd,EACJ,CACA,IAAI,EAAc,AAAA,EAAA,GAAK,EAAS,CAAE,QAAS,CAAA,CAAK,GAC5C,EAAc,IAAI,WAAW,EAAI,EAAY,OAAS,EAAY,MACtE,CAAA,IAAI,CAAC,QAAU,CAAC,EAChB,EAAQ,QAAQ,AAAA,IAEZ,IAAI,EAAI,EAAI,EAER,EAAI,EAAI,EACR,EAAc,EAAI,WAAW,IAAI,AAAA,IACjC,GAAI,AAAa,aAAb,EACA,MAAO,CAAC,IAAK,GAAI,GAAI,IAAI,CAE7B,IAAI,EAAM,AAAA,EAAA,GAAM,GAAW,QAE3B,OADA,EAAI,KAAK,KACF,CACX,EACA,CAAA,IAAI,CAAC,OAAO,CAAC,EAAI,SAAS,CAAG,IAAI,EAAO,EAAI,EAAY,MAAO,EAAI,EAAY,OAAQ,AAAC,CAAA,EAAI,EAAI,KAAA,EAAS,EAAY,MAAO,AAAC,CAAA,EAAI,EAAI,MAAA,EAAU,EAAY,QAC3J,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,MAAO,IAC3B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,OAAQ,IAAK,CACjC,IAAI,EAAO,EAAI,QAAQ,CAAC,EAAE,CAAC,OAAO,GAClC,GAAI,AAAS,MAAT,EAAc,SAClB,IAAI,EAAc,CAAW,CAAC,OAAO,GAAM,CACvC,EAAY,AAAC,CAAA,EAAK,EAAM,AAAA,CAAA,EAAI,CAAA,EAAK,EAAY,KAAA,EAAS,CAC1D,CAAA,CAAW,CAAC,EAAY,EAAE,CAAG,CAAW,CAAC,EAAE,CAC3C,CAAW,CAAC,EAAY,EAAE,CAAG,CAAW,CAAC,EAAE,CAC3C,CAAW,CAAC,EAAY,EAAE,CAAG,CAAW,CAAC,EAAE,CAC3C,CAAW,CAAC,EAAY,EAAE,CAAG,CAAW,CAAC,EAAE,AAC/C,CAER,GAEA,IAAI,CAAC,cAAgB,EAAA,cAAmB,EAAI,CACxC,IAAK,EACL,MAAO,EAAY,MACnB,OAAQ,EAAY,OACpB,OAAQ,EAAG,KACX,IAAK,EAAG,OACZ,GAEA,QAAQ,IAAI,IAAI,CAAC,QACrB,CAEA,YAAY,CAAmB,CAAE,CAAoB,CAAE,CAAmB,CAAE,CACxE,IAAI,CAAC,OAAS,IAAI,EAAK,CAAE,EAAc,EAAc,IAAI,CAAC,GAAG,OAAO,MAAO,EAAe,EAAc,IAAI,CAAC,GAAG,OAAO,QACvH,IAAI,CAAC,MAAQ,IAAI,EAAK,EAAI,EAAc,IAAI,CAAC,GAAG,OAAO,MAAO,GAAK,EAAc,IAAI,CAAC,GAAG,OAAO,OAIpG,CAEA,MAAM,CAAmB,CAAE,CAAS,CAAE,CAAS,CAAE,CAC7C,IAAI,CAAC,WAAW,EAAa,IAAI,EAAK,EAAG,GAAI,AAAA,EAAK,IACtD,CAEA,WAAW,CAAmB,CAAE,CAAS,CAAE,CAAU,CAAE,CACnD,IAAI,EAAa,AAAgB,EAAhB,IAAI,CAAC,SA/KV,EAgLR,EAAU,IAAI,CAAC,OAAO,CAAC,EAAY,CACvC,GAAI,AAAY,KAAA,IAAZ,EACA,MAAM,AAAI,MAAM,CAAC,sBAAsB,EAAE,EAAY,CAAC,CAI1D,CAAA,IAAI,CAAC,YAAY,CAAC,EAAa,EAAE,CAAG,EAAI,EACxC,IAAI,CAAC,YAAY,CAAC,EAAa,EAAE,CAAG,EAAI,EACxC,IAAI,CAAC,YAAY,CAAC,EAAa,EAAE,CAAG,EAAQ,KAC5C,IAAI,CAAC,YAAY,CAAC,EAAa,EAAE,CAAG,EAAQ,IAG5C,IAAI,CAAC,YAAY,CAAC,EAAa,EAAE,CAAG,EAAI,EAAI,EAAK,EACjD,IAAI,CAAC,YAAY,CAAC,EAAa,EAAE,CAAG,EAAI,EACxC,IAAI,CAAC,YAAY,CAAC,EAAa,EAAE,CAAG,EAAQ,MAC5C,IAAI,CAAC,YAAY,CAAC,EAAa,EAAE,CAAG,EAAQ,IAG5C,IAAI,CAAC,YAAY,CAAC,EAAa,EAAE,CAAG,EAAI,EACxC,IAAI,CAAC,YAAY,CAAC,EAAa,EAAE,CAAG,EAAI,EAAI,EAAK,EACjD,IAAI,CAAC,YAAY,CAAC,EAAa,GAAG,CAAG,EAAQ,KAC7C,IAAI,CAAC,YAAY,CAAC,EAAa,GAAG,CAAG,EAAQ,OAG7C,IAAI,CAAC,YAAY,CAAC,EAAa,GAAG,CAAG,EAAI,EAAI,EAAK,EAClD,IAAI,CAAC,YAAY,CAAC,EAAa,GAAG,CAAG,EAAI,EAAI,EAAK,EAClD,IAAI,CAAC,YAAY,CAAC,EAAa,GAAG,CAAG,EAAQ,MAC7C,IAAI,CAAC,YAAY,CAAC,EAAa,GAAG,CAAG,EAAQ,OAE7C,IAAI,CAAC,UAAY,CACrB,CAEA,MAAO,CACH,IAAI,EAAK,IAAI,CAAC,GAEd,EAAG,WAAW,EAAG,aAAc,IAAI,CAAC,cACpC,EAAG,cAAc,EAAG,aAAc,EAAG,IAAI,CAAC,aAAc,EAAG,AAAgB,EAAhB,IAAI,CAAC,SApNpD,GAsNZ,EAAG,WAAW,IAAI,CAAC,aAAa,SAChC,EAAG,gBAAgB,IAAI,CAAC,SAAS,mBAEjC,EAAA,2BAAgC,IAAI,CAAC,aAAc,CAC/C,SAAU,CAAC,IAAI,CAAC,OAAO,EAAG,IAAI,CAAC,OAAO,EAAE,CACxC,QAAS,CAAC,IAAI,CAAC,MAAM,EAAG,IAAI,CAAC,MAAM,EAAE,CACrC,UAAW,IAAI,CAAC,aACpB,GACA,EAAG,aAAa,EAAG,UAAW,EAAI,IAAI,CAAC,SAAU,EAAG,eAAgB,GACpE,IAAI,CAAC,SAAW,CACpB,CACJ,EFnNqC,EAAI,CACrC,MAAO,CAAC,CAAC,aAAc,QAAQ,CAC3B,CAAC;;;;;;IAML,CAAC,CAAC,CACF,KAAM,CAAC,CAAC,QAAS,YAAY,CACzB,CAAC;;;;;;IAML,CAAC,CAAC,CACF,OAAQ,CAAC,CAAC,QAAS,SAAU,QAAS,OAAO,CACzC,CAAC;;;;;;IAML,CAAC,CAAC,CACF,MAAO,CAAC,CAAC,SAAS,CACd,CAAC;;;;;;IAML,CAAC,CAAC,AACN,GAEM,EAAY,CAAC;;;;;;;;AAQnB,CAAC,CAAC,OAEI,EAAa,EAAU,MAAM,MAAM,IAAI,AAAA,GAAK,EAAE,QAC9C,EAAe,EAAW,OAC1B,EAAc,CAAU,CAAC,EAAE,CAAC,OAClC,QAAQ,OAAO,EAAW,MAAM,AAAA,GAAK,EAAE,QAAU,GAAc,mBAC/D,IAAM,EAAc,EAAW,IAAI,AAAA,GAAK,EAAE,MAAM,IAAI,IAAI,AAAA,GAAK,AAAK,KAAL,IAAW,OAExE,SAAS,EAAU,CAAS,CAAE,CAAS,QACnC,CAAI,CAAA,EAAI,CAAA,IAAK,CAAA,GAAK,CAAA,IAAe,CAAA,EAAI,CAAA,IAAK,CAAA,GAAK,CAAA,GAGxC,CAAW,CAAC,EAAI,EAAI,EAAY,AAC3C,CAIA,IAAI,EAAe,EAAW,IAAI,AAAA,GAAK,EAAE,MAAM,IAAI,IAAI,AAAA,GAAK,AAAK,KAAL,GAAY,AAAK,KAAL,IAAW,OAE/E,EAAa,CACb,QAAS,EACT,QAAS,EACT,WAAY,IAAI,EAAK,EAAG,GACxB,WAAY,CACR,IAAI,EAAK,EAAG,GACZ,IAAI,EAAK,EAAG,GACf,AACL,CAKA,OAAM,EACF,YACW,CAAA,CACA,CAAA,CACT,CAFS,IAAA,CAAA,aAAA,EACA,IAAA,CAAA,IAAA,CACP,CAEJ,SAAU,CACN,AAAA,EAAK,IAAI,IAAI,CAAC,aAAc,IAAI,CAAC,IAAK,EAAW,WACrD,CAEA,SAAS,CAAiB,CAAE,CACxB,AAAA,EAAK,IAAI,IAAI,CAAC,aAAc,AAAA,EAAK,MAAM,IAAI,CAAC,IAAK,GAAY,EAAa,cAAc,SAC5F,CAEA,aAAa,CAAiB,CAAE,CAC5B,IAAI,CAAC,SAAS,EAAM,EACxB,CAEA,MAAO,CACH,AAAA,EAAK,KAAK,IAAI,CAAC,aAAc,EAAW,WAC5C,CACJ,CAEA,MAAM,EAGF,YACW,CAAA,CACA,CAAA,CACA,CAAA,CACT,CAHS,IAAA,CAAA,YAAA,EACA,IAAA,CAAA,aAAA,EACA,IAAA,CAAA,IAAA,EAEP,IAAI,CAAC,cAAgB,IAAI,EAAkB,AAAA,EAAK,IAAI,EAAc,GAAM,EAC5E,CAEA,SAAU,CACN,AAAA,EAAK,IAAI,IAAI,CAAC,aAAc,IAAI,CAAC,IAAK,EAAW,UAAU,CAAC,IAAI,CAAC,YAAY,EAC7E,IAAI,CAAC,cAAc,SACvB,CAEA,SAAS,CAAiB,CAAE,CACxB,AAAA,EAAK,IAAI,IAAI,CAAC,aAAc,AAAA,EAAK,MAAM,IAAI,CAAC,IAAK,GAAY,EAAa,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,UAC3G,IAAI,CAAC,cAAc,SAAS,EAChC,CAEA,aAAa,CAAiB,CAAE,KAiGX,EA/FjB,IAAI,CAAC,cAAc,SAAS,EAAM,GAElC,IAAI,EAAc,AAAA,EAAK,IAAI,IAAI,CAAC,aAAc,IAAI,EAAK,GAAI,IACvD,CAAA,EAAY,IACZ,AAAA,EAAK,MAAM,AAAA,EAAK,IAAK,EAAM,EAAM,EAAW,EAAa,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,MAC1F,AAAA,EAAK,IAAI,EAAa,IAAI,CAAC,IAAK,KAEhC,AAAA,EAAK,MAAM,AAAA,EAAK,IAAK,EAAM,EAAY,EAAK,EAAa,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,MAC1F,AAAA,EAAK,KAAK,IAAI,CAAC,aAAc,EAAa,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,WAuF9D,EArFD,EAAa,cAAc,CAAC,IAAI,CAAC,YAAY,CAsFjE,AAAA,EAAK,IAtF8D,EAsFlD,AAAA,EAAK,MAAM,EAAO,KAAM,IAAK,EAAO,SArFrD,CAEA,MAAO,CACH,AAAA,EAAK,KAAK,IAAI,CAAC,aAAc,EAAW,UAAU,CAAC,IAAI,CAAC,YAAY,EACpE,IAAI,CAAC,cAAc,MACvB,CACJ,CAEA,MAAM,EACF,YACW,CAAA,CACA,CAAA,CACT,CAFS,IAAA,CAAA,IAAA,EACA,IAAA,CAAA,IAAA,CACP,CAEJ,SAAU,CACN,MAAM,AAAI,MAAM,4BACpB,CAEA,SAAS,CAAiB,CAAE,CAExB,AAAA,EAAK,IAAI,IAAI,CAAC,IAAK,AAAA,EAAK,MAAM,IAAI,CAAC,IADhB,EAAa,CAAA,EAAI,CAAA,GACmB,EAAa,cAAc,SACtF,CAEA,aAAa,CAAiB,CAAE,CAC5B,MAAM,AAAI,MAAM,0BACpB,CAEA,MAAO,CACH,MAAM,AAAI,MAAM,0BACpB,CACJ,CAQA,IAAI,EAA6B,EAAE,CAE/B,EAAe,CACf,UAAW,EACX,cAAe,EACX,AAAA,EAAK,KAAK,EAAW,YACrB,AAAA,EAAK,KAAK,AAAA,EAAK,KACf,AAAA,EAAK,KAAK,AAAA,EAAK,MACf,AAAA,EAAK,KAAK,AAAA,EAAK,MAEnB,eAAgB,EAAW,WAAW,IAAI,AAAA,GAC/B,EACH,AAAA,EAAK,KAAK,GACV,AAAA,EAAK,KAAK,AAAA,EAAK,KACf,AAAA,EAAK,KAAK,AAAA,EAAK,MACf,AAAA,EAAK,KAAK,AAAA,EAAK,MAG3B,EAEI,EAAwC,KACxC,EAA6C,KAcjD,SAAS,EAAa,CAAS,CAAE,CAAU,CAAE,CAAY,CAAE,CAAa,EAQpE,MAPqB,CACjB,aAAc,EACd,SAAU,EACV,KAAM,EACN,OAAQ,EACR,QAAS,CACb,CAEJ,CAMA,IAAI,EAGA,CACA,QAAS,CAAC,EACV,OAAQ,EAAE,AACd,EAGc,sBAiBd,SAAS,EAAO,CAAgB,EAC5B,IAAI,EAAQ,AAAC,CAAA,EAAW,CAAA,EAAa,KAOrC,GANA,EAAY,EAER,EAAA,0BAA+B,EAAG,SAClC,EAAG,SAAS,EAAG,EAAG,EAAG,mBAAoB,EAAG,qBAG5C,EAAY,OAAO,OAAS,GAAK,AAA0B,OAA1B,GAAkC,AAA+B,OAA/B,EAAqC,CACxG,IAAI,EAAY,EAAY,OAAO,QACnC,GAAI,AAAa,QAAb,EACI,EAAgB,OAAS,IAEzB,AADA,CAAA,EAA6B,EAAgB,KAA7C,EAC2B,OAC3B,EAAa,UAAY,OAE1B,CACH,IAAI,EAAe,IAAI,EACvB,OAAQ,GACJ,IAAK,OACD,EAAa,EAAI,EACjB,KACJ,KAAK,OACD,EAAa,EAAI,GACjB,KACJ,KAAK,OACD,EAAa,EAAI,GACjB,KACJ,KAAK,OACD,EAAa,EAAI,CAEzB,CAEA,GAAI,AAAkB,GAAlB,EAAa,GAAU,AAAkB,GAAlB,EAAa,EAAQ,CAC5C,IAAI,EAAiB,AAAA,EAAK,IAAI,EAAW,WAAY,GACrD,GAAK,EAAU,EAAe,EAAG,EAAe,GAsB5C,EAAwB,IAAI,EAAgB,EAAW,WAAY,OAtBnB,CAChD,IAAI,EAAsB,EAAW,WAAW,UAAU,AAAA,GAAa,AAAA,EAAK,OAAO,EAAgB,IACnG,GAAI,AAAuB,IAAvB,EAGA,AADA,CAAA,EAAwB,IAAI,EAAkB,AAAA,EAAK,KAAK,EAAW,YAAa,EAAhF,EACsB,UACtB,EAAgB,KAAK,OAClB,CAEH,IAAI,EAAgB,AAAA,EAAK,IAAI,EAAW,UAAU,CAAC,EAAoB,CAAE,EACnD,CAAA,EAAU,EAAc,EAAG,EAAc,IACxD,EAAW,WAAW,KAAK,AAAA,GAAa,AAAA,EAAK,OAAO,EAAe,IAOtE,EAAwB,IAAI,EAAgB,EAAW,WAAY,IAHnE,AADA,CAAA,EAAwB,IAAI,EAAiB,EAAqB,AAAA,EAAK,KAAK,EAAW,UAAU,CAAC,EAAoB,EAAG,EAAzH,EACsB,UACtB,EAAgB,KAAK,GAI7B,CACJ,CAGJ,CACJ,CACJ,CAEI,AAA0B,OAA1B,GACA,EAAa,WAAa,EArHZ,IAsHd,EAAa,UAAY,AAAA,EAAM,EAAa,UAAW,EAAG,GAC1D,EAAsB,SAAS,EAAa,WACxC,EAAa,WAAa,IAC1B,EAAwB,KACxB,EAAa,UAAY,IAES,OAA/B,IACP,EAAa,WAAa,EA7HZ,IA8Hd,EAAa,UAAY,AAAA,EAAM,EAAa,UAAW,EAAG,GAC1D,EAA2B,aAAa,EAAa,WACjD,EAAa,WAAa,IAC1B,EAA6B,KAC7B,EAAa,UAAY,IAIjC,EAAG,MAAM,EAAG,kBAEZ,EAAI,YAAY,EAAa,EA/QR,IAkRrB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAc,IAC9B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAa,IACzB,CAAY,CAAC,EAAI,EAAI,EAAY,CACjC,EAAI,MAAM,QAAS,EAAG,GACf,CAAW,CAAC,EAAI,EAAI,EAAY,EACvC,EAAI,MAAM,OAAQ,EAAG,GAMjC,EAAI,WAAW,SAAU,EAAa,cAAc,SAAU,EAAa,cAAc,MACzF,EAAa,eAAe,QAAQ,AAAA,IAChC,EAAI,WAAW,QAAS,EAAI,SAAU,EAAI,KAC9C,GAEA,EAAI,OAEM,sBAAsB,EACpC,GAzHA,SAAS,iBAAiB,UAG1B,SAAmB,CAAiB,EAChC,QAAQ,IAAI,WACZ,EAAY,OAAO,CAAC,EAAG,KAAK,CAAG,CAAA,EAC/B,EAAY,OAAO,KAAK,EAAG,KAC/B,GANA,SAAS,iBAAiB,QAQ1B,SAAiB,CAAiB,EAC9B,QAAQ,IAAI,SACZ,EAAY,OAAO,CAAC,EAAG,KAAK,CAAG,CAAA,CACnC,GAGA,IAAI,EAAY,C","sources":["<anon>","sokobanFast/main.ts","kommon/math.ts","kommon/puzzlescript_graphics.ts","node_modules/bin-pack/index.js","node_modules/bin-pack/packer.growing.js"],"sourcesContent":["(function () {\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire94c2\"] = parcelRequire;\n}\n\nvar $6MzNI = parcelRequire(\"6MzNI\");\nfunction $c15e63e86d3cb1d2$export$3c5f89dae98e900b(low_inclusive, high_exclusive) {\n    return low_inclusive + Math.floor(Math.random() * (high_exclusive - low_inclusive));\n}\nfunction $c15e63e86d3cb1d2$export$8960430cfd85939f(arr) {\n    if (arr.length === 0) return undefined;\n    return arr[$c15e63e86d3cb1d2$export$3249d46f03066cfe(arr)];\n}\nfunction $c15e63e86d3cb1d2$export$3249d46f03066cfe(arr) {\n    if (arr.length === 0) return undefined;\n    let res = 0;\n    let biggest = arr[0];\n    for(let k = 1; k < arr.length; k++)if (arr[k] > biggest) {\n        biggest = arr[k];\n        res = k;\n    }\n    return res;\n}\nfunction $c15e63e86d3cb1d2$export$3a89f8d6f6bf6c9f(a, b, t) {\n    return a * (1 - t) + b * t;\n}\nfunction $c15e63e86d3cb1d2$export$dff840edf10f285e(cur, target, max_delta) {\n    if (cur > target) return Math.max(cur - max_delta, target);\n    else if (cur < target) return Math.min(cur + max_delta, target);\n    else return target;\n}\nfunction $c15e63e86d3cb1d2$export$842a2cf37af977e1(n, m) {\n    return (n % m + m) % m;\n}\nfunction $c15e63e86d3cb1d2$export$aee1dbae5de2db9d(value, old_a, old_b, new_a, new_b) {\n    let t = (value - old_a) / (old_b - old_a);\n    return t * (new_b - new_a) + new_a;\n}\nfunction $c15e63e86d3cb1d2$export$94951fac5549ef77(arr) {\n    if (arr.length === 0) throw new Error(\"can't choose out of an empty array\");\n    return arr[Math.floor(Math.random() * arr.length)];\n}\nfunction $c15e63e86d3cb1d2$export$4053e36566dd3d9a(toZero, toOne, value) {\n    let x = Math.max(0, Math.min(1, (value - toZero) / (toOne - toZero)));\n    return x * x * (3 - 2 * x);\n}\nfunction $c15e63e86d3cb1d2$export$7d15b64cf5a3a4c4(value, min_inclusive, max_inclusive) {\n    return Math.max(min_inclusive, Math.min(max_inclusive, value));\n}\nfunction $c15e63e86d3cb1d2$export$ddf89a9c5af38f94(value, min_inclusive, max_exclusive) {\n    return value >= min_inclusive && value < max_exclusive;\n}\nfunction $c15e63e86d3cb1d2$export$66124ef7f3a58cb4(value, min_inclusive, max_exclusive) {\n    return value == min_inclusive || value + 1 === max_exclusive;\n}\nfunction $c15e63e86d3cb1d2$export$448332262467e042(array) {\n    let currentIndex = array.length, randomIndex;\n    // While there remain elements to shuffle.\n    while(currentIndex != 0){\n        // Pick a remaining element.\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex--;\n        // And swap it with the current element.\n        [array[currentIndex], array[randomIndex]] = [\n            array[randomIndex],\n            array[currentIndex]\n        ];\n    }\n    return array;\n}\nclass $c15e63e86d3cb1d2$export$b973696b5f65b53b {\n    constructor(x = 0.0, y = 0.0, z = 0.0, w = 0.0){\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n    static fromHex(hex_str) {\n        // from https://stackoverflow.com/a/5624139\n        var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex_str);\n        if (result === null) throw new Error(`can't parse hex: ${hex_str}`);\n        return new $c15e63e86d3cb1d2$export$b973696b5f65b53b(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), 255);\n    }\n    static #_ = (()=>{\n        this.zero = new $c15e63e86d3cb1d2$export$b973696b5f65b53b(0, 0, 0, 0);\n    })();\n    static #_1 = (()=>{\n        this.one = new $c15e63e86d3cb1d2$export$b973696b5f65b53b(1, 1, 1, 1);\n    })();\n}\nclass $c15e63e86d3cb1d2$export$ac4bca90992eed1 {\n    constructor(x = 0.0, y = 0.0){\n        this.x = x;\n        this.y = y;\n    }\n    toString() {\n        return `Vec2(${this.x}, ${this.y})`;\n    }\n    static #_ = (()=>{\n        // scratchpad vectors, meant to be reused as intermediate values without allocation\n        this.tmp = new $c15e63e86d3cb1d2$export$ac4bca90992eed1(0, 0);\n    })();\n    static #_1 = (()=>{\n        this.tmp1 = new $c15e63e86d3cb1d2$export$ac4bca90992eed1(0, 0);\n    })();\n    static #_2 = (()=>{\n        this.tmp2 = new $c15e63e86d3cb1d2$export$ac4bca90992eed1(0, 0);\n    })();\n    static #_3 = (()=>{\n        this.tmp3 = new $c15e63e86d3cb1d2$export$ac4bca90992eed1(0, 0);\n    })();\n    static #_4 = (()=>{\n        this.zero = new $c15e63e86d3cb1d2$export$ac4bca90992eed1(0, 0);\n    })();\n    static #_5 = (()=>{\n        this.one = new $c15e63e86d3cb1d2$export$ac4bca90992eed1(1, 1);\n    })();\n    static set(v, x, y) {\n        v.x = x;\n        v.y = y;\n        return v;\n    }\n    static copy(v, out) {\n        out = out || new $c15e63e86d3cb1d2$export$ac4bca90992eed1();\n        out.x = v.x;\n        out.y = v.y;\n        return out;\n    }\n    static add(a, b, out) {\n        out = out || new $c15e63e86d3cb1d2$export$ac4bca90992eed1();\n        out.x = a.x + b.x;\n        out.y = a.y + b.y;\n        return out;\n    }\n    static sub(a, b, out) {\n        out = out || new $c15e63e86d3cb1d2$export$ac4bca90992eed1();\n        out.x = a.x - b.x;\n        out.y = a.y - b.y;\n        return out;\n    }\n    static mul(a, b, out) {\n        out = out || new $c15e63e86d3cb1d2$export$ac4bca90992eed1();\n        out.x = a.x * b.x;\n        out.y = a.y * b.y;\n        return out;\n    }\n    static div(a, b, out) {\n        out = out || new $c15e63e86d3cb1d2$export$ac4bca90992eed1();\n        out.x = a.x / b.x;\n        out.y = a.y / b.y;\n        return out;\n    }\n    static round(v, out) {\n        out = out || new $c15e63e86d3cb1d2$export$ac4bca90992eed1();\n        out.x = Math.round(v.x);\n        out.y = Math.round(v.y);\n        return out;\n    }\n    static negate(v, out) {\n        out = out || new $c15e63e86d3cb1d2$export$ac4bca90992eed1();\n        out.x = -v.x;\n        out.y = -v.y;\n        return out;\n    }\n    static scale(v, s, out) {\n        out = out || new $c15e63e86d3cb1d2$export$ac4bca90992eed1();\n        out.x = v.x * s;\n        out.y = v.y * s;\n        return out;\n    }\n    static lerp(a, b, t, out) {\n        out = out || new $c15e63e86d3cb1d2$export$ac4bca90992eed1();\n        out.x = a.x * (1 - t) + b.x * t;\n        out.y = a.y * (1 - t) + b.y * t;\n        return out;\n    }\n    static inBounds(point, bounds) {\n        return $c15e63e86d3cb1d2$export$ddf89a9c5af38f94(point.x, 0, bounds.x) && $c15e63e86d3cb1d2$export$ddf89a9c5af38f94(point.y, 0, bounds.y);\n    }\n    // too niche for here?\n    static onBorder(point, bounds) {\n        return $c15e63e86d3cb1d2$export$66124ef7f3a58cb4(point.x, 0, bounds.x) || $c15e63e86d3cb1d2$export$66124ef7f3a58cb4(point.y, 0, bounds.y);\n    }\n    static isZero(v) {\n        return v.x === 0 && v.y === 0;\n    }\n    static equals(a, b) {\n        return a.x === b.x && a.y === b.y;\n    }\n    static map1(v, fn, out) {\n        out = out || new $c15e63e86d3cb1d2$export$ac4bca90992eed1();\n        out.x = fn(v.x);\n        out.y = fn(v.y);\n        return out;\n    }\n    static map2(a, b, fn, out) {\n        out = out || new $c15e63e86d3cb1d2$export$ac4bca90992eed1();\n        out.x = fn(a.x, b.x);\n        out.y = fn(a.y, b.y);\n        return out;\n    }\n    static roundToCardinal(a) {\n        if (Math.abs(a.x) >= Math.abs(a.y)) {\n            if (a.x >= 0) return \"xpos\";\n            else return \"xneg\";\n        } else {\n            if (a.y >= 0) return \"ypos\";\n            else return \"yneg\";\n        }\n    }\n}\nclass $c15e63e86d3cb1d2$export$4617fb02663045ef {\n    constructor(topLeft, size){\n        this.topLeft = topLeft;\n        this.size = size;\n    }\n    static fromParams(params) {\n        let topLeft = new $c15e63e86d3cb1d2$export$ac4bca90992eed1();\n        let size = new $c15e63e86d3cb1d2$export$ac4bca90992eed1();\n        if (params.topLeft !== undefined) {\n            $c15e63e86d3cb1d2$export$ac4bca90992eed1.copy(params.topLeft, topLeft);\n            if (params.size !== undefined) $c15e63e86d3cb1d2$export$ac4bca90992eed1.copy(params.size, size);\n            else if (params.bottomRight !== undefined) $c15e63e86d3cb1d2$export$ac4bca90992eed1.sub(params.bottomRight, topLeft, size);\n            else if (params.center !== undefined) {\n                $c15e63e86d3cb1d2$export$ac4bca90992eed1.sub(params.center, topLeft, size);\n                $c15e63e86d3cb1d2$export$ac4bca90992eed1.scale(size, 2, size);\n            } else throw new Error(\"not enough data to compute rect\");\n            return new $c15e63e86d3cb1d2$export$4617fb02663045ef(topLeft, size);\n        } else if (params.center !== undefined) {\n            if (params.size !== undefined) $c15e63e86d3cb1d2$export$ac4bca90992eed1.copy(params.size, size);\n            else if (params.bottomRight !== undefined) {\n                $c15e63e86d3cb1d2$export$ac4bca90992eed1.sub(params.bottomRight, params.center, size);\n                $c15e63e86d3cb1d2$export$ac4bca90992eed1.scale(size, 2, size);\n            } else throw new Error(\"not enough data to compute rect\");\n            $c15e63e86d3cb1d2$export$ac4bca90992eed1.sub(params.center, $c15e63e86d3cb1d2$export$ac4bca90992eed1.scale(size, .5), topLeft);\n            return new $c15e63e86d3cb1d2$export$4617fb02663045ef(topLeft, size);\n        } else throw new Error(\"unimplemented\");\n    }\n}\n\n\n\nvar $6MzNI = parcelRequire(\"6MzNI\");\n\nvar $69b8e49bf8d6d1f7$exports = {};\n\"use strict\";\nvar $6d9d5b3d477adb58$exports = {};\n/******************************************************************************\n\nThis is a binary tree based bin packing algorithm that is more complex than\nthe simple Packer (packer.js). Instead of starting off with a fixed width and\nheight, it starts with the width and height of the first block passed and then\ngrows as necessary to accomodate each subsequent block. As it grows it attempts\nto maintain a roughly square ratio by making 'smart' choices about whether to\ngrow right or down.\n\nWhen growing, the algorithm can only grow to the right OR down. Therefore, if\nthe new block is BOTH wider and taller than the current target then it will be\nrejected. This makes it very important to initialize with a sensible starting\nwidth and height. If you are providing sorted input (largest first) then this\nwill not be an issue.\n\nA potential way to solve this limitation would be to allow growth in BOTH\ndirections at once, but this requires maintaining a more complex tree\nwith 3 children (down, right and center) and that complexity can be avoided\nby simply chosing a sensible starting block.\n\nBest results occur when the input blocks are sorted by height, or even better\nwhen sorted by max(width,height).\n\nInputs:\n------\n\n\tblocks: array of any objects that have .w and .h attributes\n\nOutputs:\n-------\n\n\tmarks each block that fits with a .fit attribute pointing to a\n\tnode with .x and .y coordinates\n\nExample:\n-------\n\n\tvar blocks = [\n\t\t{ w: 100, h: 100 },\n\t\t{ w: 100, h: 100 },\n\t\t{ w:  80, h:  80 },\n\t\t{ w:  80, h:  80 },\n\t\tetc\n\t\tetc\n\t];\n\n\tvar packer = new GrowingPacker();\n\tpacker.fit(blocks);\n\n\tfor(var n = 0 ; n < blocks.length ; n++) {\n\t\tvar block = blocks[n];\n\t\tif (block.fit) {\n\t\t\tDraw(block.fit.x, block.fit.y, block.w, block.h);\n\t\t}\n\t}\n\n\n******************************************************************************/ var $6d9d5b3d477adb58$var$GrowingPacker = function() {};\n$6d9d5b3d477adb58$var$GrowingPacker.prototype = {\n    fit: function(blocks) {\n        var n, node, block, len = blocks.length, fit;\n        var width = len > 0 ? blocks[0].width : 0;\n        var height = len > 0 ? blocks[0].height : 0;\n        this.root = {\n            x: 0,\n            y: 0,\n            width: width,\n            height: height\n        };\n        for(n = 0; n < len; n++){\n            block = blocks[n];\n            if (node = this.findNode(this.root, block.width, block.height)) {\n                fit = this.splitNode(node, block.width, block.height);\n                block.x = fit.x;\n                block.y = fit.y;\n            } else {\n                fit = this.growNode(block.width, block.height);\n                block.x = fit.x;\n                block.y = fit.y;\n            }\n        }\n    },\n    findNode: function(root, width, height) {\n        if (root.used) return this.findNode(root.right, width, height) || this.findNode(root.down, width, height);\n        else if (width <= root.width && height <= root.height) return root;\n        else return null;\n    },\n    splitNode: function(node, width, height) {\n        node.used = true;\n        node.down = {\n            x: node.x,\n            y: node.y + height,\n            width: node.width,\n            height: node.height - height\n        };\n        node.right = {\n            x: node.x + width,\n            y: node.y,\n            width: node.width - width,\n            height: height\n        };\n        return node;\n    },\n    growNode: function(width, height) {\n        var canGrowDown = width <= this.root.width;\n        var canGrowRight = height <= this.root.height;\n        var shouldGrowRight = canGrowRight && this.root.height >= this.root.width + width; // attempt to keep square-ish by growing right when height is much greater than width\n        var shouldGrowDown = canGrowDown && this.root.width >= this.root.height + height; // attempt to keep square-ish by growing down  when width  is much greater than height\n        if (shouldGrowRight) return this.growRight(width, height);\n        else if (shouldGrowDown) return this.growDown(width, height);\n        else if (canGrowRight) return this.growRight(width, height);\n        else if (canGrowDown) return this.growDown(width, height);\n        else return null; // need to ensure sensible root starting size to avoid this happening\n    },\n    growRight: function(width, height) {\n        this.root = {\n            used: true,\n            x: 0,\n            y: 0,\n            width: this.root.width + width,\n            height: this.root.height,\n            down: this.root,\n            right: {\n                x: this.root.width,\n                y: 0,\n                width: width,\n                height: this.root.height\n            }\n        };\n        var node;\n        if (node = this.findNode(this.root, width, height)) return this.splitNode(node, width, height);\n        else return null;\n    },\n    growDown: function(width, height) {\n        this.root = {\n            used: true,\n            x: 0,\n            y: 0,\n            width: this.root.width,\n            height: this.root.height + height,\n            down: {\n                x: 0,\n                y: this.root.height,\n                width: this.root.width,\n                height: height\n            },\n            right: this.root\n        };\n        var node;\n        if (node = this.findNode(this.root, width, height)) return this.splitNode(node, width, height);\n        else return null;\n    }\n};\n$6d9d5b3d477adb58$exports = $6d9d5b3d477adb58$var$GrowingPacker;\n\n\n$69b8e49bf8d6d1f7$exports = function(items, options) {\n    options = options || {};\n    var packer = new $6d9d5b3d477adb58$exports();\n    var inPlace = options.inPlace || false;\n    // Clone the items.\n    var newItems = items.map(function(item) {\n        return inPlace ? item : {\n            width: item.width,\n            height: item.height,\n            item: item\n        };\n    });\n    newItems = newItems.sort(function(a, b) {\n        // TODO: check that each actually HAS a width and a height.\n        // Sort based on the size (area) of each block.\n        return b.width * b.height - a.width * a.height;\n    });\n    packer.fit(newItems);\n    var w = newItems.reduce(function(curr, item) {\n        return Math.max(curr, item.x + item.width);\n    }, 0);\n    var h = newItems.reduce(function(curr, item) {\n        return Math.max(curr, item.y + item.height);\n    }, 0);\n    var ret = {\n        width: w,\n        height: h\n    };\n    if (!inPlace) ret.items = newItems;\n    return ret;\n};\n\n\n\nvar $9AT65 = parcelRequire(\"9AT65\");\nclass $72f198b559e83e7d$export$499e30931c411408 {\n    constructor(left, top, right, bottom){\n        this.left = left;\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n    }\n}\n// vec2 for position, vec2 for uv -> 4\nconst $72f198b559e83e7d$var$VERTEX_SIZE = 4;\nclass $72f198b559e83e7d$export$84a9fffd752f3d21 {\n    constructor(gl, sprites_data){\n        this.gl = gl;\n        this.n_queued = 0;\n        // todo: shader that allows pixelart rotation\n        this.program_info = $6MzNI.createProgramInfo(gl, [\n            // vs\n            `#version 300 es\r\n        \r\n            in vec2 a_position;\r\n            in vec2 a_texcoord;\r\n        \r\n            // global data\r\n            // sprites drawn at 0,0 will end in this clipspace position\r\n            uniform vec2 u_origin;\r\n            // sprites drawn at 1,1 will end in u_origin plus this clipspace position\r\n            uniform vec2 u_basis;\r\n        \r\n            out vec2 v_texcoord;\r\n        \r\n            void main() {\r\n                gl_Position = vec4(u_origin + a_position * u_basis, 0.0, 1.0);\r\n                v_texcoord = a_texcoord;\r\n            }\r\n            `,\n            // fs\n            `#version 300 es\r\n            precision highp float;\r\n            \r\n            in vec2 v_texcoord;\r\n        \r\n            uniform sampler2D u_texture;\r\n        \r\n            out vec4 out_color;\r\n        \r\n            void main() {\r\n                out_color = texture(u_texture, v_texcoord);\r\n            }\r\n            `\n        ]);\n        const max_n_sprites = 2048;\n        console.assert(max_n_sprites * 6 < 65536, \"Can't draw that many sprites, change the code to use u32 indices.\");\n        this.vertices_cpu = new Float32Array(max_n_sprites * $72f198b559e83e7d$var$VERTEX_SIZE);\n        this.vertices_gpu = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_gpu);\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices_cpu, gl.DYNAMIC_DRAW);\n        const vertex_indices = new Uint16Array(max_n_sprites * 6);\n        for(let k = 0; k < max_n_sprites; k += 1){\n            // top left triangle\n            vertex_indices[k * 6 + 0] = k * $72f198b559e83e7d$var$VERTEX_SIZE + 0;\n            vertex_indices[k * 6 + 1] = k * $72f198b559e83e7d$var$VERTEX_SIZE + 1;\n            vertex_indices[k * 6 + 2] = k * $72f198b559e83e7d$var$VERTEX_SIZE + 2;\n            // bottom right triangle\n            vertex_indices[k * 6 + 3] = k * $72f198b559e83e7d$var$VERTEX_SIZE + 1;\n            vertex_indices[k * 6 + 4] = k * $72f198b559e83e7d$var$VERTEX_SIZE + 3;\n            vertex_indices[k * 6 + 5] = k * $72f198b559e83e7d$var$VERTEX_SIZE + 2;\n        }\n        this.buffer_info = $6MzNI.createBufferInfoFromArrays(gl, {\n            a_position: {\n                buffer: this.vertices_gpu,\n                numComponents: 2,\n                type: Float32Array,\n                offset: 0,\n                stride: $72f198b559e83e7d$var$VERTEX_SIZE * 4\n            },\n            a_texcoord: {\n                buffer: this.vertices_gpu,\n                numComponents: 2,\n                type: Float32Array,\n                offset: 8,\n                stride: $72f198b559e83e7d$var$VERTEX_SIZE * 4\n            },\n            indices: {\n                data: vertex_indices,\n                drawType: gl.STATIC_DRAW\n            }\n        });\n        this.vao_info = $6MzNI.createVertexArrayInfo(gl, this.program_info, this.buffer_info);\n        // for now, no margin, let's see how it goes\n        let sprites = [];\n        for (const [spr_name, spr_data] of Object.entries(sprites_data)){\n            let spr_rows = spr_data[1].trim().split(\"\\n\").map((x)=>x.trim());\n            sprites.push({\n                width: (0, $c15e63e86d3cb1d2$export$8960430cfd85939f)(spr_rows.map((x)=>x.length)),\n                height: spr_rows.length,\n                spr_rows: spr_rows,\n                spr_colors: spr_data[0],\n                spr_name: spr_name\n            });\n        }\n        let pack_result = (0, (/*@__PURE__*/$parcel$interopDefault($69b8e49bf8d6d1f7$exports)))(sprites, {\n            inPlace: true\n        });\n        let texture_cpu = new Uint8Array(4 * pack_result.height * pack_result.width);\n        this.mapping = {};\n        sprites.forEach((spr)=>{\n            // @ts-ignore\n            let x = spr.x;\n            // @ts-ignore\n            let y = spr.y;\n            let rgba_colors = spr.spr_colors.map((color_str)=>{\n                if (color_str == \"darkbrown\") return [\n                    123,\n                    54,\n                    23,\n                    255\n                ]; // random lol\n                let res = (0, (/*@__PURE__*/$parcel$interopDefault($9AT65)))(color_str).array();\n                res.push(255);\n                return res;\n            });\n            this.mapping[spr.spr_name] = new $72f198b559e83e7d$export$499e30931c411408(x / pack_result.width, y / pack_result.height, (x + spr.width) / pack_result.width, (y + spr.height) / pack_result.height);\n            for(let j = 0; j < spr.width; j++)for(let i = 0; i < spr.height; i++){\n                let char = spr.spr_rows[j].charAt(i);\n                if (char === \".\") continue;\n                let pixel_color = rgba_colors[Number(char)];\n                let cur_index = (x + i + (y + j) * pack_result.width) * 4;\n                texture_cpu[cur_index + 0] = pixel_color[0];\n                texture_cpu[cur_index + 1] = pixel_color[1];\n                texture_cpu[cur_index + 2] = pixel_color[2];\n                texture_cpu[cur_index + 3] = pixel_color[3];\n            }\n        });\n        this.atlas_texture = $6MzNI.createTexture(gl, {\n            src: texture_cpu,\n            width: pack_result.width,\n            height: pack_result.height,\n            format: gl.RGBA,\n            mag: gl.NEAREST\n        });\n        console.log(this.mapping);\n    }\n    centerLevel(level_width, level_height, sprite_size) {\n        this.origin = new (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1)(-level_width * sprite_size / this.gl.canvas.width, level_height * sprite_size / this.gl.canvas.height);\n        this.basis = new (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1)(2 * sprite_size / this.gl.canvas.width, -2 * sprite_size / this.gl.canvas.height);\n    // console.log(\"psg origin: \", this.origin.x, this.origin.y)\n    // console.log(\"psg basis: \", this.basis.x, this.basis.y)\n    }\n    queue(sprite_name, i, j) {\n        this.queueExtra(sprite_name, new (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1)(i, j), (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).one);\n    }\n    queueExtra(sprite_name, pos, size) {\n        let base_index = this.n_queued * 4 * $72f198b559e83e7d$var$VERTEX_SIZE;\n        let uv_data = this.mapping[sprite_name];\n        if (uv_data === undefined) throw new Error(`cant find sprite name ${sprite_name}`);\n        // tl vertex\n        this.vertices_cpu[base_index + 0] = pos.x;\n        this.vertices_cpu[base_index + 1] = pos.y;\n        this.vertices_cpu[base_index + 2] = uv_data.left;\n        this.vertices_cpu[base_index + 3] = uv_data.top;\n        // tr vertex\n        this.vertices_cpu[base_index + 4] = pos.x + size.x;\n        this.vertices_cpu[base_index + 5] = pos.y;\n        this.vertices_cpu[base_index + 6] = uv_data.right;\n        this.vertices_cpu[base_index + 7] = uv_data.top;\n        // bl vertex\n        this.vertices_cpu[base_index + 8] = pos.x;\n        this.vertices_cpu[base_index + 9] = pos.y + size.y;\n        this.vertices_cpu[base_index + 10] = uv_data.left;\n        this.vertices_cpu[base_index + 11] = uv_data.bottom;\n        // br vertex\n        this.vertices_cpu[base_index + 12] = pos.x + size.x;\n        this.vertices_cpu[base_index + 13] = pos.y + size.y;\n        this.vertices_cpu[base_index + 14] = uv_data.right;\n        this.vertices_cpu[base_index + 15] = uv_data.bottom;\n        this.n_queued += 1;\n    }\n    draw() {\n        let gl = this.gl;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_gpu);\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices_cpu, 0, this.n_queued * 4 * $72f198b559e83e7d$var$VERTEX_SIZE);\n        gl.useProgram(this.program_info.program);\n        gl.bindVertexArray(this.vao_info.vertexArrayObject);\n        $6MzNI.setUniformsAndBindTextures(this.program_info, {\n            u_origin: [\n                this.origin.x,\n                this.origin.y\n            ],\n            u_basis: [\n                this.basis.x,\n                this.basis.y\n            ],\n            u_texture: this.atlas_texture\n        });\n        gl.drawElements(gl.TRIANGLES, 6 * this.n_queued, gl.UNSIGNED_SHORT, 0);\n        this.n_queued = 0;\n    }\n}\n\n\n// Sokoban, in \"exploratory style\" / \"Lisp style\":\n// abstract soon-ish, bytes don't exist, reuse, iterate fast\n// for now, this only means using puzzlescript renderer\n// This \"if\" will only execute during development\nif (null) {\n    null.dispose((data)=>{\n        data.game_state = $d7047c8d3b3cfc96$var$game_state;\n        cancelAnimationFrame($d7047c8d3b3cfc96$var$loop_id);\n        document.removeEventListener(\"keydown\", $d7047c8d3b3cfc96$var$onKeyDown);\n        document.removeEventListener(\"keyup\", $d7047c8d3b3cfc96$var$onKeyUp);\n    });\n    null.accept((_)=>{\n        $d7047c8d3b3cfc96$var$game_state = null.data.game_state;\n    });\n}\nconst $d7047c8d3b3cfc96$var$gl = document.querySelector(\"#c\").getContext(\"webgl2\", {\n    alpha: false\n});\n$d7047c8d3b3cfc96$var$gl.clearColor(0.5, 0.5, 0.75, 1.0);\n$d7047c8d3b3cfc96$var$gl.enable($d7047c8d3b3cfc96$var$gl.BLEND);\n$d7047c8d3b3cfc96$var$gl.blendFunc($d7047c8d3b3cfc96$var$gl.SRC_ALPHA, $d7047c8d3b3cfc96$var$gl.ONE_MINUS_SRC_ALPHA);\n$6MzNI.resizeCanvasToDisplaySize($d7047c8d3b3cfc96$var$gl.canvas);\n$d7047c8d3b3cfc96$var$gl.viewport(0, 0, $d7047c8d3b3cfc96$var$gl.drawingBufferWidth, $d7047c8d3b3cfc96$var$gl.drawingBufferHeight);\nconst $d7047c8d3b3cfc96$var$PSG = new (0, $72f198b559e83e7d$export$84a9fffd752f3d21)($d7047c8d3b3cfc96$var$gl, {\n    Floor: [\n        [\n            \"lightgreen\",\n            \"green\"\n        ],\n        `\r\n      11111\r\n      01111\r\n      11101\r\n      11111\r\n      10111\r\n    `\n    ],\n    Wall: [\n        [\n            \"brown\",\n            \"darkbrown\"\n        ],\n        `\r\n      00010\r\n      11111\r\n      01000\r\n      11111\r\n      00010\r\n    `\n    ],\n    Player: [\n        [\n            \"black\",\n            \"orange\",\n            \"white\",\n            \"blue\"\n        ],\n        `\r\n      .000.\r\n      .111.\r\n      22222\r\n      .333.\r\n      .3.3.\r\n    `\n    ],\n    Crate: [\n        [\n            \"orange\"\n        ],\n        `\r\n      00000\r\n      0...0\r\n      0...0\r\n      0...0\r\n      00000\r\n    `\n    ]\n});\nconst $d7047c8d3b3cfc96$var$level_src = `\r\n####!!\r\n#.O#!!\r\n#..###\r\n#@P..#\r\n#..*.#\r\n#..###\r\n####!!\r\n`.trim();\nconst $d7047c8d3b3cfc96$var$level_rows = $d7047c8d3b3cfc96$var$level_src.split(\"\\n\").map((r)=>r.trim());\nconst $d7047c8d3b3cfc96$var$level_height = $d7047c8d3b3cfc96$var$level_rows.length;\nconst $d7047c8d3b3cfc96$var$level_width = $d7047c8d3b3cfc96$var$level_rows[0].length;\nconsole.assert($d7047c8d3b3cfc96$var$level_rows.every((r)=>r.length == $d7047c8d3b3cfc96$var$level_width), \"Bad ascii level\");\nconst $d7047c8d3b3cfc96$var$level_walls = $d7047c8d3b3cfc96$var$level_rows.map((r)=>r.split(\"\").map((c)=>c == \"#\")).flat();\nfunction $d7047c8d3b3cfc96$var$getWallAt(i, j) {\n    if (i < 0 || i >= $d7047c8d3b3cfc96$var$level_width || j < 0 || j >= $d7047c8d3b3cfc96$var$level_height) return false;\n    return $d7047c8d3b3cfc96$var$level_walls[i + j * $d7047c8d3b3cfc96$var$level_width];\n}\nconst $d7047c8d3b3cfc96$var$tilemap_tilesize = 64;\nlet $d7047c8d3b3cfc96$var$level_floors = $d7047c8d3b3cfc96$var$level_rows.map((r)=>r.split(\"\").map((c)=>c != \"#\" && c != \"!\")).flat();\nlet $d7047c8d3b3cfc96$var$game_state = {\n    debug_x: 0,\n    debug_y: 0,\n    player_pos: new (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1)(2, 3),\n    crates_pos: [\n        new (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1)(1, 3),\n        new (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1)(3, 4)\n    ]\n};\n// Command: Any action that takes time & is undoable\nclass $d7047c8d3b3cfc96$var$PlayerMoveCommand {\n    constructor(original_pos, dir){\n        this.original_pos = original_pos;\n        this.dir = dir;\n    }\n    execute() {\n        (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).add(this.original_pos, this.dir, $d7047c8d3b3cfc96$var$game_state.player_pos);\n    }\n    animTurn(turn_time) {\n        (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).add(this.original_pos, (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).scale(this.dir, turn_time), $d7047c8d3b3cfc96$var$visual_state.player_sprite.position);\n    }\n    undoAnimTurn(turn_time) {\n        this.animTurn(1.0 - turn_time);\n    }\n    undo() {\n        (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).copy(this.original_pos, $d7047c8d3b3cfc96$var$game_state.player_pos);\n    }\n}\nclass $d7047c8d3b3cfc96$var$PushCrateCommand {\n    constructor(crate_index, original_pos, dir){\n        this.crate_index = crate_index;\n        this.original_pos = original_pos;\n        this.dir = dir;\n        this.extra_command = new $d7047c8d3b3cfc96$var$PlayerMoveCommand((0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).sub(original_pos, dir), dir);\n    }\n    execute() {\n        (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).add(this.original_pos, this.dir, $d7047c8d3b3cfc96$var$game_state.crates_pos[this.crate_index]);\n        this.extra_command.execute();\n    }\n    animTurn(turn_time) {\n        (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).add(this.original_pos, (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).scale(this.dir, turn_time), $d7047c8d3b3cfc96$var$visual_state.crates_sprites[this.crate_index].position);\n        this.extra_command.animTurn(turn_time);\n    }\n    undoAnimTurn(turn_time) {\n        // player moves backwards\n        this.extra_command.animTurn(1.0 - turn_time);\n        // crate pops into place\n        let tile_center = (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).add(this.original_pos, new (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1)(.5, .5));\n        if (turn_time < .5) {\n            (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).scale((0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).one, 1.0 - 2.0 * turn_time, $d7047c8d3b3cfc96$var$visual_state.crates_sprites[this.crate_index].size);\n            (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).add(tile_center, this.dir, tile_center);\n        } else {\n            (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).scale((0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).one, 2.0 * turn_time - 1.0, $d7047c8d3b3cfc96$var$visual_state.crates_sprites[this.crate_index].size);\n            (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).copy(this.original_pos, $d7047c8d3b3cfc96$var$visual_state.crates_sprites[this.crate_index].position);\n        }\n        $d7047c8d3b3cfc96$var$setSpriteCenter($d7047c8d3b3cfc96$var$visual_state.crates_sprites[this.crate_index], tile_center);\n    }\n    undo() {\n        (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).copy(this.original_pos, $d7047c8d3b3cfc96$var$game_state.crates_pos[this.crate_index]);\n        this.extra_command.undo();\n    }\n}\nclass $d7047c8d3b3cfc96$var$BumpWallCommand {\n    constructor(pos, dir){\n        this.pos = pos;\n        this.dir = dir;\n    }\n    execute() {\n        throw new Error(\"not an executable command\");\n    }\n    animTurn(turn_time) {\n        let displacement = turn_time * (1 - turn_time);\n        (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).add(this.pos, (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).scale(this.dir, displacement), $d7047c8d3b3cfc96$var$visual_state.player_sprite.position);\n    }\n    undoAnimTurn(turn_time) {\n        throw new Error(\"not an undoable command\");\n    }\n    undo() {\n        throw new Error(\"not an undoable command\");\n    }\n}\nlet $d7047c8d3b3cfc96$var$command_history = [];\nlet $d7047c8d3b3cfc96$var$visual_state = {\n    turn_time: 0,\n    player_sprite: $d7047c8d3b3cfc96$var$createSprite((0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).copy($d7047c8d3b3cfc96$var$game_state.player_pos), (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).copy((0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).one), (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).copy((0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).zero), (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).copy((0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).one)),\n    crates_sprites: $d7047c8d3b3cfc96$var$game_state.crates_pos.map((crate_pos)=>{\n        return $d7047c8d3b3cfc96$var$createSprite((0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).copy(crate_pos), (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).copy((0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).one), (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).copy((0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).zero), (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).copy((0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).one));\n    })\n};\nlet $d7047c8d3b3cfc96$var$cur_animating_command = null;\nlet $d7047c8d3b3cfc96$var$cur_animating_undo_command = null;\nconst $d7047c8d3b3cfc96$var$move_duration = .05;\nfunction $d7047c8d3b3cfc96$var$createSprite(pos, size, uv_pos, uv_size) {\n    let sprite = {\n        buffer_index: 0,\n        position: pos,\n        size: size,\n        uv_pos: uv_pos,\n        uv_size: uv_size\n    };\n    return sprite;\n}\nfunction $d7047c8d3b3cfc96$var$setSpriteCenter(sprite, center) {\n    (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).sub(center, (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).scale(sprite.size, .5), sprite.position);\n}\nlet $d7047c8d3b3cfc96$var$input_state = {\n    pressed: {},\n    queued: []\n};\nlet $d7047c8d3b3cfc96$var$loop_id = requestAnimationFrame($d7047c8d3b3cfc96$var$update);\ndocument.addEventListener(\"keydown\", $d7047c8d3b3cfc96$var$onKeyDown);\ndocument.addEventListener(\"keyup\", $d7047c8d3b3cfc96$var$onKeyUp);\nfunction $d7047c8d3b3cfc96$var$onKeyDown(ev) {\n    console.log(\"keydown\");\n    $d7047c8d3b3cfc96$var$input_state.pressed[ev.code] = true;\n    $d7047c8d3b3cfc96$var$input_state.queued.push(ev.code);\n}\nfunction $d7047c8d3b3cfc96$var$onKeyUp(ev) {\n    console.log(\"keyup\");\n    $d7047c8d3b3cfc96$var$input_state.pressed[ev.code] = false;\n}\nlet $d7047c8d3b3cfc96$var$time_last = 0;\nfunction $d7047c8d3b3cfc96$var$update(time_cur) {\n    let delta = (time_cur - $d7047c8d3b3cfc96$var$time_last) * 0.001;\n    $d7047c8d3b3cfc96$var$time_last = time_cur;\n    if ($6MzNI.resizeCanvasToDisplaySize($d7047c8d3b3cfc96$var$gl.canvas)) $d7047c8d3b3cfc96$var$gl.viewport(0, 0, $d7047c8d3b3cfc96$var$gl.drawingBufferWidth, $d7047c8d3b3cfc96$var$gl.drawingBufferHeight);\n    if ($d7047c8d3b3cfc96$var$input_state.queued.length > 0 && $d7047c8d3b3cfc96$var$cur_animating_command === null && $d7047c8d3b3cfc96$var$cur_animating_undo_command === null) {\n        let cur_input = $d7047c8d3b3cfc96$var$input_state.queued.shift();\n        if (cur_input == \"KeyZ\") {\n            if ($d7047c8d3b3cfc96$var$command_history.length > 0) {\n                $d7047c8d3b3cfc96$var$cur_animating_undo_command = $d7047c8d3b3cfc96$var$command_history.pop();\n                $d7047c8d3b3cfc96$var$cur_animating_undo_command.undo();\n                $d7047c8d3b3cfc96$var$visual_state.turn_time = 0;\n            }\n        } else {\n            let player_delta = new (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1)();\n            switch(cur_input){\n                case \"KeyD\":\n                    player_delta.x = 1;\n                    break;\n                case \"KeyA\":\n                    player_delta.x = -1;\n                    break;\n                case \"KeyW\":\n                    player_delta.y = -1;\n                    break;\n                case \"KeyS\":\n                    player_delta.y = 1;\n                    break;\n            }\n            if (player_delta.x != 0 || player_delta.y != 0) {\n                let new_player_pos = (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).add($d7047c8d3b3cfc96$var$game_state.player_pos, player_delta);\n                if (!$d7047c8d3b3cfc96$var$getWallAt(new_player_pos.x, new_player_pos.y)) {\n                    let pushing_crate_index = $d7047c8d3b3cfc96$var$game_state.crates_pos.findIndex((crate_pos)=>(0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).equals(new_player_pos, crate_pos));\n                    if (pushing_crate_index == -1) {\n                        // Standard move\n                        $d7047c8d3b3cfc96$var$cur_animating_command = new $d7047c8d3b3cfc96$var$PlayerMoveCommand((0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).copy($d7047c8d3b3cfc96$var$game_state.player_pos), player_delta);\n                        $d7047c8d3b3cfc96$var$cur_animating_command.execute();\n                        $d7047c8d3b3cfc96$var$command_history.push($d7047c8d3b3cfc96$var$cur_animating_command);\n                    } else {\n                        // Try to push a crate\n                        let new_crate_pos = (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).add($d7047c8d3b3cfc96$var$game_state.crates_pos[pushing_crate_index], player_delta);\n                        let is_push_blocked = $d7047c8d3b3cfc96$var$getWallAt(new_crate_pos.x, new_crate_pos.y) || $d7047c8d3b3cfc96$var$game_state.crates_pos.some((crate_pos)=>(0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).equals(new_crate_pos, crate_pos));\n                        if (!is_push_blocked) {\n                            // Push a crate\n                            $d7047c8d3b3cfc96$var$cur_animating_command = new $d7047c8d3b3cfc96$var$PushCrateCommand(pushing_crate_index, (0, $c15e63e86d3cb1d2$export$ac4bca90992eed1).copy($d7047c8d3b3cfc96$var$game_state.crates_pos[pushing_crate_index]), player_delta);\n                            $d7047c8d3b3cfc96$var$cur_animating_command.execute();\n                            $d7047c8d3b3cfc96$var$command_history.push($d7047c8d3b3cfc96$var$cur_animating_command);\n                        } else $d7047c8d3b3cfc96$var$cur_animating_command = new $d7047c8d3b3cfc96$var$BumpWallCommand($d7047c8d3b3cfc96$var$game_state.player_pos, player_delta);\n                    }\n                } else $d7047c8d3b3cfc96$var$cur_animating_command = new $d7047c8d3b3cfc96$var$BumpWallCommand($d7047c8d3b3cfc96$var$game_state.player_pos, player_delta);\n            }\n        }\n    }\n    if ($d7047c8d3b3cfc96$var$cur_animating_command !== null) {\n        $d7047c8d3b3cfc96$var$visual_state.turn_time += delta / $d7047c8d3b3cfc96$var$move_duration;\n        $d7047c8d3b3cfc96$var$visual_state.turn_time = (0, $c15e63e86d3cb1d2$export$7d15b64cf5a3a4c4)($d7047c8d3b3cfc96$var$visual_state.turn_time, 0, 1);\n        $d7047c8d3b3cfc96$var$cur_animating_command.animTurn($d7047c8d3b3cfc96$var$visual_state.turn_time);\n        if ($d7047c8d3b3cfc96$var$visual_state.turn_time >= 1) {\n            $d7047c8d3b3cfc96$var$cur_animating_command = null;\n            $d7047c8d3b3cfc96$var$visual_state.turn_time = 0;\n        }\n    } else if ($d7047c8d3b3cfc96$var$cur_animating_undo_command !== null) {\n        $d7047c8d3b3cfc96$var$visual_state.turn_time += delta / $d7047c8d3b3cfc96$var$move_duration;\n        $d7047c8d3b3cfc96$var$visual_state.turn_time = (0, $c15e63e86d3cb1d2$export$7d15b64cf5a3a4c4)($d7047c8d3b3cfc96$var$visual_state.turn_time, 0, 1);\n        $d7047c8d3b3cfc96$var$cur_animating_undo_command.undoAnimTurn($d7047c8d3b3cfc96$var$visual_state.turn_time);\n        if ($d7047c8d3b3cfc96$var$visual_state.turn_time >= 1) {\n            $d7047c8d3b3cfc96$var$cur_animating_undo_command = null;\n            $d7047c8d3b3cfc96$var$visual_state.turn_time = 0;\n        }\n    }\n    $d7047c8d3b3cfc96$var$gl.clear($d7047c8d3b3cfc96$var$gl.COLOR_BUFFER_BIT);\n    $d7047c8d3b3cfc96$var$PSG.centerLevel($d7047c8d3b3cfc96$var$level_width, $d7047c8d3b3cfc96$var$level_height, $d7047c8d3b3cfc96$var$tilemap_tilesize);\n    // walls & floors\n    for(let j = 0; j < $d7047c8d3b3cfc96$var$level_height; j++)for(let i = 0; i < $d7047c8d3b3cfc96$var$level_width; i++){\n        if ($d7047c8d3b3cfc96$var$level_floors[i + j * $d7047c8d3b3cfc96$var$level_width]) $d7047c8d3b3cfc96$var$PSG.queue(\"Floor\", i, j);\n        else if ($d7047c8d3b3cfc96$var$level_walls[i + j * $d7047c8d3b3cfc96$var$level_width]) $d7047c8d3b3cfc96$var$PSG.queue(\"Wall\", i, j);\n    }\n    // moving stuff:\n    $d7047c8d3b3cfc96$var$PSG.queueExtra(\"Player\", $d7047c8d3b3cfc96$var$visual_state.player_sprite.position, $d7047c8d3b3cfc96$var$visual_state.player_sprite.size);\n    $d7047c8d3b3cfc96$var$visual_state.crates_sprites.forEach((spr)=>{\n        $d7047c8d3b3cfc96$var$PSG.queueExtra(\"Crate\", spr.position, spr.size);\n    });\n    $d7047c8d3b3cfc96$var$PSG.draw();\n    $d7047c8d3b3cfc96$var$loop_id = requestAnimationFrame($d7047c8d3b3cfc96$var$update);\n}\n\n})();\n//# sourceMappingURL=index.4bcfa91a.js.map\n","import * as twgl from \"twgl.js\"\r\nimport { Vec2, clamp } from \"../kommon/math\";\r\nimport { PuzzleScriptGraphics, UVRect } from \"../kommon/puzzlescript_graphics\";\r\n\r\n// Sokoban, in \"exploratory style\" / \"Lisp style\":\r\n// abstract soon-ish, bytes don't exist, reuse, iterate fast\r\n\r\n// for now, this only means using puzzlescript renderer\r\n\r\n// This \"if\" will only execute during development\r\nif (module.hot) {\r\n    module.hot.dispose(data => {\r\n        data.game_state = game_state;\r\n        cancelAnimationFrame(loop_id);\r\n        document.removeEventListener(\"keydown\", onKeyDown);\r\n        document.removeEventListener(\"keyup\", onKeyUp);\r\n    });\r\n    module.hot.accept(_ => {\r\n        game_state = module.hot!.data.game_state;\r\n    });\r\n}\r\n\r\nconst gl = (document.querySelector(\"#c\") as HTMLCanvasElement).getContext(\"webgl2\", { alpha: false })!;\r\ngl.clearColor(0.5, 0.5, 0.75, 1.0);\r\ngl.enable(gl.BLEND);\r\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\ntwgl.resizeCanvasToDisplaySize(gl.canvas as HTMLCanvasElement);\r\ngl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n\r\nconst PSG = new PuzzleScriptGraphics(gl, {\r\n    Floor: [[\"lightgreen\", \"green\"],\r\n        `\r\n      11111\r\n      01111\r\n      11101\r\n      11111\r\n      10111\r\n    `],\r\n    Wall: [[\"brown\", \"darkbrown\"],\r\n        `\r\n      00010\r\n      11111\r\n      01000\r\n      11111\r\n      00010\r\n    `],\r\n    Player: [[\"black\", \"orange\", \"white\", \"blue\"],\r\n        `\r\n      .000.\r\n      .111.\r\n      22222\r\n      .333.\r\n      .3.3.\r\n    `],\r\n    Crate: [[\"orange\"],\r\n        `\r\n      00000\r\n      0...0\r\n      0...0\r\n      0...0\r\n      00000\r\n    `],\r\n});\r\n\r\nconst level_src = `\r\n####!!\r\n#.O#!!\r\n#..###\r\n#@P..#\r\n#..*.#\r\n#..###\r\n####!!\r\n`.trim();\r\n\r\nconst level_rows = level_src.split('\\n').map(r => r.trim());\r\nconst level_height = level_rows.length;\r\nconst level_width = level_rows[0].length;\r\nconsole.assert(level_rows.every(r => r.length == level_width), \"Bad ascii level\");\r\nconst level_walls = level_rows.map(r => r.split('').map(c => c == '#')).flat()\r\n\r\nfunction getWallAt(i: number, j: number): boolean {\r\n    if (i < 0 || i >= level_width || j < 0 || j >= level_height) {\r\n        return false\r\n    }\r\n    return level_walls[i + j * level_width];\r\n}\r\n\r\nconst tilemap_tilesize = 64;\r\n\r\nlet level_floors = level_rows.map(r => r.split('').map(c => c != '#' && c != '!')).flat()\r\n\r\nlet game_state = {\r\n    debug_x: 0,\r\n    debug_y: 0,\r\n    player_pos: new Vec2(2, 3),\r\n    crates_pos: [\r\n        new Vec2(1, 3),\r\n        new Vec2(3, 4),\r\n    ]\r\n};\r\ntype GameState = typeof game_state;\r\n\r\n// Command: Any action that takes time & is undoable\r\n\r\nclass PlayerMoveCommand {\r\n    constructor(\r\n        public original_pos: Vec2,\r\n        public dir: Vec2,\r\n    ) { }\r\n\r\n    execute() {\r\n        Vec2.add(this.original_pos, this.dir, game_state.player_pos);\r\n    }\r\n\r\n    animTurn(turn_time: number) {\r\n        Vec2.add(this.original_pos, Vec2.scale(this.dir, turn_time), visual_state.player_sprite.position);\r\n    }\r\n\r\n    undoAnimTurn(turn_time: number) {\r\n        this.animTurn(1.0 - turn_time);\r\n    }\r\n\r\n    undo() {\r\n        Vec2.copy(this.original_pos, game_state.player_pos);\r\n    }\r\n}\r\n\r\nclass PushCrateCommand {\r\n    extra_command: PlayerMoveCommand;\r\n\r\n    constructor(\r\n        public crate_index: number,\r\n        public original_pos: Vec2,\r\n        public dir: Vec2,\r\n    ) {\r\n        this.extra_command = new PlayerMoveCommand(Vec2.sub(original_pos, dir), dir);\r\n    }\r\n\r\n    execute() {\r\n        Vec2.add(this.original_pos, this.dir, game_state.crates_pos[this.crate_index]);\r\n        this.extra_command.execute();\r\n    }\r\n\r\n    animTurn(turn_time: number) {\r\n        Vec2.add(this.original_pos, Vec2.scale(this.dir, turn_time), visual_state.crates_sprites[this.crate_index].position);\r\n        this.extra_command.animTurn(turn_time);\r\n    }\r\n\r\n    undoAnimTurn(turn_time: number) {\r\n        // player moves backwards\r\n        this.extra_command.animTurn(1.0 - turn_time);\r\n        // crate pops into place\r\n        let tile_center = Vec2.add(this.original_pos, new Vec2(.5, .5));\r\n        if (turn_time < .5) {\r\n            Vec2.scale(Vec2.one, 1.0 - 2.0 * turn_time, visual_state.crates_sprites[this.crate_index].size);\r\n            Vec2.add(tile_center, this.dir, tile_center);\r\n        } else {\r\n            Vec2.scale(Vec2.one, 2.0 * turn_time - 1.0, visual_state.crates_sprites[this.crate_index].size);\r\n            Vec2.copy(this.original_pos, visual_state.crates_sprites[this.crate_index].position);\r\n        }\r\n        setSpriteCenter(visual_state.crates_sprites[this.crate_index], tile_center);\r\n    }\r\n\r\n    undo() {\r\n        Vec2.copy(this.original_pos, game_state.crates_pos[this.crate_index]);\r\n        this.extra_command.undo();\r\n    }\r\n}\r\n\r\nclass BumpWallCommand {\r\n    constructor(\r\n        public pos: Vec2,\r\n        public dir: Vec2,\r\n    ) { }\r\n\r\n    execute() {\r\n        throw new Error(\"not an executable command\");\r\n    }\r\n\r\n    animTurn(turn_time: number) {\r\n        let displacement = turn_time * (1 - turn_time);\r\n        Vec2.add(this.pos, Vec2.scale(this.dir, displacement), visual_state.player_sprite.position);\r\n    }\r\n\r\n    undoAnimTurn(turn_time: number) {\r\n        throw new Error(\"not an undoable command\");\r\n    }\r\n\r\n    undo() {\r\n        throw new Error(\"not an undoable command\");\r\n    }\r\n}\r\n\r\n// todo: generic command\r\n// todo: BumpWallCommand is inherently very dirty :(\r\n// the solution would be to embrace logic & render separation, & have separate queues for logic commands & render commands\r\n\r\ntype Command = PlayerMoveCommand | PushCrateCommand | BumpWallCommand;\r\n\r\nlet command_history: Command[] = [];\r\n\r\nlet visual_state = {\r\n    turn_time: 0,\r\n    player_sprite: createSprite(\r\n        Vec2.copy(game_state.player_pos),\r\n        Vec2.copy(Vec2.one),\r\n        Vec2.copy(Vec2.zero),\r\n        Vec2.copy(Vec2.one),\r\n    ),\r\n    crates_sprites: game_state.crates_pos.map(crate_pos => {\r\n        return createSprite(\r\n            Vec2.copy(crate_pos),\r\n            Vec2.copy(Vec2.one),\r\n            Vec2.copy(Vec2.zero),\r\n            Vec2.copy(Vec2.one),\r\n        );\r\n    }),\r\n}\r\n\r\nlet cur_animating_command: null | Command = null;\r\nlet cur_animating_undo_command: null | Command = null;\r\n\r\nconst move_duration = .05;\r\n\r\n// player sprite data\r\n\r\ntype Sprite = {\r\n    buffer_index: number,\r\n    position: Vec2,\r\n    size: Vec2,\r\n    uv_pos: Vec2,\r\n    uv_size: Vec2,\r\n}\r\n\r\nfunction createSprite(pos: Vec2, size: Vec2, uv_pos: Vec2, uv_size: Vec2): Sprite {\r\n    let sprite: Sprite = {\r\n        buffer_index: 0,\r\n        position: pos,\r\n        size: size,\r\n        uv_pos: uv_pos,\r\n        uv_size: uv_size,\r\n    }\r\n    return sprite;\r\n}\r\n\r\nfunction setSpriteCenter(sprite: Sprite, center: Vec2) {\r\n    Vec2.sub(center, Vec2.scale(sprite.size, .5), sprite.position);\r\n}\r\n\r\nlet input_state: {\r\n    pressed: Record<string, boolean>,\r\n    queued: string[],\r\n} = {\r\n    pressed: {},\r\n    queued: [],\r\n};\r\n\r\n\r\nlet loop_id = requestAnimationFrame(update);\r\ndocument.addEventListener(\"keydown\", onKeyDown);\r\ndocument.addEventListener(\"keyup\", onKeyUp);\r\n\r\nfunction onKeyDown(ev: KeyboardEvent) {\r\n    console.log(\"keydown\");\r\n    input_state.pressed[ev.code] = true;\r\n    input_state.queued.push(ev.code);\r\n}\r\n\r\nfunction onKeyUp(ev: KeyboardEvent) {\r\n    console.log(\"keyup\");\r\n    input_state.pressed[ev.code] = false;\r\n}\r\n\r\n\r\nlet time_last = 0;\r\nfunction update(time_cur: number) {\r\n    let delta = (time_cur - time_last) * 0.001;\r\n    time_last = time_cur;\r\n\r\n    if (twgl.resizeCanvasToDisplaySize(gl.canvas as HTMLCanvasElement)) {\r\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n    }\r\n\r\n    if (input_state.queued.length > 0 && cur_animating_command === null && cur_animating_undo_command === null) {\r\n        let cur_input = input_state.queued.shift();\r\n        if (cur_input == \"KeyZ\") {\r\n            if (command_history.length > 0) {\r\n                cur_animating_undo_command = command_history.pop()!;\r\n                cur_animating_undo_command.undo();\r\n                visual_state.turn_time = 0;\r\n            }\r\n        } else {\r\n            let player_delta = new Vec2()\r\n            switch (cur_input) {\r\n                case \"KeyD\":\r\n                    player_delta.x = 1;\r\n                    break;\r\n                case \"KeyA\":\r\n                    player_delta.x = -1;\r\n                    break;\r\n                case \"KeyW\":\r\n                    player_delta.y = -1;\r\n                    break;\r\n                case \"KeyS\":\r\n                    player_delta.y = 1;\r\n                    break;\r\n            }\r\n\r\n            if (player_delta.x != 0 || player_delta.y != 0) {\r\n                let new_player_pos = Vec2.add(game_state.player_pos, player_delta);\r\n                if (!getWallAt(new_player_pos.x, new_player_pos.y)) {\r\n                    let pushing_crate_index = game_state.crates_pos.findIndex(crate_pos => Vec2.equals(new_player_pos, crate_pos));\r\n                    if (pushing_crate_index == -1) {\r\n                        // Standard move\r\n                        cur_animating_command = new PlayerMoveCommand(Vec2.copy(game_state.player_pos), player_delta);\r\n                        cur_animating_command.execute()\r\n                        command_history.push(cur_animating_command);\r\n                    } else {\r\n                        // Try to push a crate\r\n                        let new_crate_pos = Vec2.add(game_state.crates_pos[pushing_crate_index], player_delta);\r\n                        let is_push_blocked = getWallAt(new_crate_pos.x, new_crate_pos.y)\r\n                            || game_state.crates_pos.some(crate_pos => Vec2.equals(new_crate_pos, crate_pos));\r\n                        if (!is_push_blocked) {\r\n                            // Push a crate\r\n                            cur_animating_command = new PushCrateCommand(pushing_crate_index, Vec2.copy(game_state.crates_pos[pushing_crate_index]), player_delta);\r\n                            cur_animating_command.execute()\r\n                            command_history.push(cur_animating_command);\r\n                        } else {\r\n                            cur_animating_command = new BumpWallCommand(game_state.player_pos, player_delta);\r\n                        }\r\n                    }\r\n                } else {\r\n                    cur_animating_command = new BumpWallCommand(game_state.player_pos, player_delta);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (cur_animating_command !== null) {\r\n        visual_state.turn_time += delta / move_duration;\r\n        visual_state.turn_time = clamp(visual_state.turn_time, 0, 1);\r\n        cur_animating_command.animTurn(visual_state.turn_time);\r\n        if (visual_state.turn_time >= 1) {\r\n            cur_animating_command = null;\r\n            visual_state.turn_time = 0;\r\n        }\r\n    } else if (cur_animating_undo_command !== null) {\r\n        visual_state.turn_time += delta / move_duration;\r\n        visual_state.turn_time = clamp(visual_state.turn_time, 0, 1);\r\n        cur_animating_undo_command.undoAnimTurn(visual_state.turn_time);\r\n        if (visual_state.turn_time >= 1) {\r\n            cur_animating_undo_command = null;\r\n            visual_state.turn_time = 0;\r\n        }\r\n    }\r\n\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n    PSG.centerLevel(level_width, level_height, tilemap_tilesize);\r\n\r\n    // walls & floors\r\n    for (let j = 0; j < level_height; j++) {\r\n        for (let i = 0; i < level_width; i++) {\r\n            if (level_floors[i + j * level_width]) {\r\n                PSG.queue(\"Floor\", i, j);\r\n            } else if (level_walls[i + j * level_width]) {\r\n                PSG.queue(\"Wall\", i, j);\r\n            }\r\n        }\r\n    }\r\n\r\n    // moving stuff:\r\n    PSG.queueExtra(\"Player\", visual_state.player_sprite.position, visual_state.player_sprite.size);\r\n    visual_state.crates_sprites.forEach(spr => {\r\n        PSG.queueExtra(\"Crate\", spr.position, spr.size);\r\n    })\r\n\r\n    PSG.draw();\r\n\r\n    loop_id = requestAnimationFrame(update);\r\n}\r\n","export function randomInt(low_inclusive: number, high_exclusive: number): number {\r\n    return low_inclusive + Math.floor(Math.random() * (high_exclusive - low_inclusive));\r\n}\r\n\r\nexport function max(arr: number[]) {\r\n    if (arr.length === 0) {\r\n        return undefined\r\n    }\r\n    return arr[argmax(arr)!];\r\n}\r\n\r\nexport function argmax(arr: number[]) {\r\n    if (arr.length === 0) {\r\n        return undefined\r\n    }\r\n    let res = 0;\r\n    let biggest = arr[0];\r\n    for (let k = 1; k < arr.length; k++) {\r\n        if (arr[k] > biggest) {\r\n            biggest = arr[k];\r\n            res = k;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function lerp(a: number, b: number, t: number): number {\r\n    return a * (1 - t) + b * t;\r\n}\r\n\r\nexport function towards(cur: number, target: number, max_delta: number): number {\r\n    if (cur > target) {\r\n        return Math.max(cur - max_delta, target);\r\n    } else if (cur < target) {\r\n        return Math.min(cur + max_delta, target);\r\n    } else {\r\n        return target;\r\n    }\r\n}\r\n\r\nexport function mod(n: number, m: number) {\r\n    return ((n % m) + m) % m;\r\n}\r\n\r\nexport function remap(value: number, old_a: number, old_b: number, new_a: number, new_b: number) {\r\n    let t = (value - old_a) / (old_b - old_a);\r\n    return t * (new_b - new_a) + new_a;\r\n}\r\n\r\nexport function randomChoice<T>(arr: T[]) {\r\n    if (arr.length === 0) {\r\n        throw new Error(\"can't choose out of an empty array\");\r\n    }\r\n    return arr[Math.floor(Math.random() * arr.length)];\r\n}\r\n\r\nexport function smoothstep(toZero: number, toOne: number, value: number) {\r\n    let x = Math.max(0, Math.min(1, (value - toZero) / (toOne - toZero)));\r\n    return x * x * (3 - 2 * x);\r\n};\r\n\r\nexport function clamp(value: number, min_inclusive: number, max_inclusive: number): number {\r\n    return Math.max(min_inclusive, Math.min(max_inclusive, value));\r\n}\r\n\r\nexport function inRange(value: number, min_inclusive: number, max_exclusive: number): boolean {\r\n    return value >= min_inclusive && value < max_exclusive;\r\n}\r\n\r\nexport function onBorder(value: number, min_inclusive: number, max_exclusive: number): boolean {\r\n    return value == min_inclusive || (value + 1) === max_exclusive;\r\n}\r\n\r\n// from https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\nexport function shuffle<T>(array: T[]) {\r\n    let currentIndex = array.length, randomIndex;\r\n    // While there remain elements to shuffle.\r\n    while (currentIndex != 0) {\r\n        // Pick a remaining element.\r\n        randomIndex = Math.floor(Math.random() * currentIndex);\r\n        currentIndex--;\r\n        // And swap it with the current element.\r\n        [array[currentIndex], array[randomIndex]] = [\r\n            array[randomIndex], array[currentIndex]];\r\n    }\r\n    return array;\r\n}\r\n\r\n\r\n// Use objects instead of arrays: https://jsben.ch/FgKVi\r\nexport class Vec4 {\r\n    constructor(\r\n        public x: number = 0.0,\r\n        public y: number = 0.0,\r\n        public z: number = 0.0,\r\n        public w: number = 0.0,\r\n    ) { }\r\n\r\n    static fromHex(hex_str: string): Vec4 {\r\n        // from https://stackoverflow.com/a/5624139\r\n        var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex_str);\r\n        if (result === null) {\r\n            throw new Error(`can't parse hex: ${hex_str}`);\r\n        }\r\n        return new Vec4(\r\n            parseInt(result[1], 16),\r\n            parseInt(result[2], 16),\r\n            parseInt(result[3], 16),\r\n            255,\r\n        );\r\n    }\r\n\r\n    static zero = new Vec4(0, 0, 0, 0);\r\n    static one = new Vec4(1, 1, 1, 1);\r\n}\r\n\r\ntype CardinalDirection = \"xpos\" | \"xneg\" | \"ypos\" | \"yneg\";\r\n\r\nexport class Vec2 {\r\n    constructor(\r\n        public x: number = 0.0,\r\n        public y: number = 0.0,\r\n    ) { }\r\n\r\n    toString(): string {\r\n        return `Vec2(${this.x}, ${this.y})`;\r\n    }\r\n\r\n    // scratchpad vectors, meant to be reused as intermediate values without allocation\r\n    static tmp = new Vec2(0, 0);\r\n    static tmp1 = new Vec2(0, 0);\r\n    static tmp2 = new Vec2(0, 0);\r\n    static tmp3 = new Vec2(0, 0);\r\n\r\n    static zero = new Vec2(0, 0);\r\n    static one = new Vec2(1, 1);\r\n\r\n    static set(v: Vec2, x: number, y: number): Vec2 {\r\n        v.x = x;\r\n        v.y = y;\r\n        return v;\r\n    }\r\n\r\n    static copy(v: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = v.x;\r\n        out.y = v.y;\r\n        return out;\r\n    }\r\n\r\n    static add(a: Vec2, b: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = a.x + b.x;\r\n        out.y = a.y + b.y;\r\n        return out;\r\n    }\r\n\r\n    static sub(a: Vec2, b: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = a.x - b.x;\r\n        out.y = a.y - b.y;\r\n        return out;\r\n    }\r\n\r\n    static mul(a: Vec2, b: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = a.x * b.x;\r\n        out.y = a.y * b.y;\r\n        return out;\r\n    }\r\n\r\n    static div(a: Vec2, b: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = a.x / b.x;\r\n        out.y = a.y / b.y;\r\n        return out;\r\n    }\r\n\r\n    static round(v: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = Math.round(v.x);\r\n        out.y = Math.round(v.y);\r\n        return out;\r\n    }\r\n\r\n    static negate(v: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = -v.x;\r\n        out.y = -v.y;\r\n        return out;\r\n    }\r\n\r\n    static scale(v: Vec2, s: number, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = v.x * s;\r\n        out.y = v.y * s;\r\n        return out;\r\n    }\r\n\r\n    static lerp(a: Vec2, b: Vec2, t: number, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = a.x * (1 - t) + b.x * t;\r\n        out.y = a.y * (1 - t) + b.y * t;\r\n        return out;\r\n    }\r\n\r\n    static inBounds(point: Vec2, bounds: Vec2): boolean {\r\n        return inRange(point.x, 0, bounds.x) && inRange(point.y, 0, bounds.y);\r\n    }\r\n\r\n    // too niche for here?\r\n    static onBorder(point: Vec2, bounds: Vec2): boolean {\r\n        return onBorder(point.x, 0, bounds.x) || onBorder(point.y, 0, bounds.y);\r\n    }\r\n\r\n    static isZero(v: Vec2): boolean {\r\n        return v.x === 0 && v.y === 0;\r\n    }\r\n\r\n    static equals(a: Vec2, b: Vec2): boolean {\r\n        return a.x === b.x && a.y === b.y;\r\n    }\r\n\r\n    static map1(v: Vec2, fn: (x: number) => number, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = fn(v.x);\r\n        out.y = fn(v.y);\r\n        return out;\r\n    }\r\n\r\n    static map2(a: Vec2, b: Vec2, fn: (a: number, b: number) => number, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = fn(a.x, b.x);\r\n        out.y = fn(a.y, b.y);\r\n        return out;\r\n    }\r\n\r\n    static roundToCardinal(a: Vec2): CardinalDirection {\r\n        if (Math.abs(a.x) >= Math.abs(a.y)) {\r\n            if (a.x >= 0) {\r\n                return \"xpos\";\r\n            } else {\r\n                return \"xneg\";\r\n            }\r\n        } else {\r\n            if (a.y >= 0) {\r\n                return \"ypos\";\r\n            } else {\r\n                return \"yneg\";\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// todo: generalize, error check for too many args\r\nexport class Rectangle {\r\n    constructor(\r\n        public topLeft: Vec2,\r\n        public size: Vec2) { }\r\n\r\n    static fromParams(params: {\r\n        topLeft?: Vec2,\r\n        center?: Vec2,\r\n        bottomRight?: Vec2,\r\n        size?: Vec2,\r\n    }): Rectangle {\r\n        let topLeft = new Vec2();\r\n        let size = new Vec2();\r\n\r\n        if (params.topLeft !== undefined) {\r\n            Vec2.copy(params.topLeft, topLeft);\r\n            if (params.size !== undefined) {\r\n                Vec2.copy(params.size, size);\r\n            } else if (params.bottomRight !== undefined) {\r\n                Vec2.sub(params.bottomRight, topLeft, size);\r\n            } else if (params.center !== undefined) {\r\n                Vec2.sub(params.center, topLeft, size);\r\n                Vec2.scale(size, 2, size);\r\n            } else {\r\n                throw new Error(\"not enough data to compute rect\");\r\n            }\r\n            return new Rectangle(topLeft, size);\r\n        } else if (params.center !== undefined) {\r\n            if (params.size !== undefined) {\r\n                Vec2.copy(params.size, size);\r\n            } else if (params.bottomRight !== undefined) {\r\n                Vec2.sub(params.bottomRight, params.center, size);\r\n                Vec2.scale(size, 2, size);\r\n            } else {\r\n                throw new Error(\"not enough data to compute rect\");\r\n            }\r\n            Vec2.sub(params.center, Vec2.scale(size, .5), topLeft);\r\n            return new Rectangle(topLeft, size);\r\n        } else {\r\n            throw new Error(\"unimplemented\");\r\n        }\r\n    }\r\n}\r\n","import * as twgl from \"twgl.js\"\r\nimport { Vec2, max } from \"./math\";\r\nimport pack from \"bin-pack\";\r\nimport Color from \"color\";\r\n\r\nexport class UVRect {\r\n    constructor(\r\n        public left: number,\r\n        public top: number,\r\n        public right: number,\r\n        public bottom: number,\r\n    ) { }\r\n}\r\n\r\n// vec2 for position, vec2 for uv -> 4\r\nconst VERTEX_SIZE = 4;\r\n\r\nexport class PuzzleScriptGraphics {\r\n    /** The shader used to render the sprites. */\r\n    program_info: twgl.ProgramInfo;\r\n    /** Sprite names to uvs */\r\n    mapping: Record<string, UVRect>;\r\n\r\n    n_queued: number = 0;\r\n    vertices_cpu: Float32Array;\r\n    vertices_gpu: WebGLBuffer;\r\n    buffer_info: twgl.BufferInfo;\r\n    vao_info: twgl.VertexArrayInfo;\r\n    atlas_texture: WebGLTexture;\r\n\r\n    origin: Vec2;\r\n    basis: Vec2;\r\n\r\n    constructor(\r\n        public gl: WebGL2RenderingContext,\r\n        sprites_data: Record<string, [string[], string]>,\r\n    ) {\r\n        // todo: shader that allows pixelart rotation\r\n        this.program_info = twgl.createProgramInfo(gl, [\r\n            // vs\r\n            `#version 300 es\r\n        \r\n            in vec2 a_position;\r\n            in vec2 a_texcoord;\r\n        \r\n            // global data\r\n            // sprites drawn at 0,0 will end in this clipspace position\r\n            uniform vec2 u_origin;\r\n            // sprites drawn at 1,1 will end in u_origin plus this clipspace position\r\n            uniform vec2 u_basis;\r\n        \r\n            out vec2 v_texcoord;\r\n        \r\n            void main() {\r\n                gl_Position = vec4(u_origin + a_position * u_basis, 0.0, 1.0);\r\n                v_texcoord = a_texcoord;\r\n            }\r\n            `,\r\n            // fs\r\n            `#version 300 es\r\n            precision highp float;\r\n            \r\n            in vec2 v_texcoord;\r\n        \r\n            uniform sampler2D u_texture;\r\n        \r\n            out vec4 out_color;\r\n        \r\n            void main() {\r\n                out_color = texture(u_texture, v_texcoord);\r\n            }\r\n            `\r\n        ]);\r\n\r\n        const max_n_sprites = 2048;\r\n        console.assert((max_n_sprites * 6) < (1 << 16), \"Can't draw that many sprites, change the code to use u32 indices.\");\r\n\r\n        this.vertices_cpu = new Float32Array(max_n_sprites * VERTEX_SIZE);\r\n        this.vertices_gpu = gl.createBuffer()!;\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_gpu);\r\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices_cpu, gl.DYNAMIC_DRAW);\r\n\r\n        const vertex_indices = new Uint16Array(max_n_sprites * 6);\r\n        for (let k = 0; k < max_n_sprites; k += 1) {\r\n            // top left triangle\r\n            vertex_indices[k * 6 + 0] = k * VERTEX_SIZE + 0;\r\n            vertex_indices[k * 6 + 1] = k * VERTEX_SIZE + 1;\r\n            vertex_indices[k * 6 + 2] = k * VERTEX_SIZE + 2;\r\n            // bottom right triangle\r\n            vertex_indices[k * 6 + 3] = k * VERTEX_SIZE + 1;\r\n            vertex_indices[k * 6 + 4] = k * VERTEX_SIZE + 3;\r\n            vertex_indices[k * 6 + 5] = k * VERTEX_SIZE + 2;\r\n        }\r\n\r\n        this.buffer_info = twgl.createBufferInfoFromArrays(gl, {\r\n            a_position: {\r\n                buffer: this.vertices_gpu,\r\n                numComponents: 2,\r\n                type: Float32Array,\r\n                offset: 0,\r\n                stride: VERTEX_SIZE * 4,\r\n            },\r\n            a_texcoord: {\r\n                buffer: this.vertices_gpu,\r\n                numComponents: 2,\r\n                type: Float32Array,\r\n                offset: 2 * 4,\r\n                stride: VERTEX_SIZE * 4,\r\n            },\r\n            indices: {\r\n                data: vertex_indices,\r\n                drawType: gl.STATIC_DRAW,\r\n            },\r\n        });\r\n\r\n        this.vao_info = twgl.createVertexArrayInfo(gl, this.program_info, this.buffer_info);\r\n\r\n        // for now, no margin, let's see how it goes\r\n        let sprites: {\r\n            width: number,\r\n            height: number,\r\n            spr_rows: string[],\r\n            spr_colors: string[],\r\n            spr_name: string,\r\n        }[] = [];\r\n        for (const [spr_name, spr_data] of Object.entries(sprites_data)) {\r\n            let spr_rows = spr_data[1].trim().split(\"\\n\").map(x => x.trim());\r\n            sprites.push({\r\n                width: max(spr_rows.map(x => x.length))!,\r\n                height: spr_rows.length,\r\n                spr_rows: spr_rows,\r\n                spr_colors: spr_data[0],\r\n                spr_name: spr_name,\r\n            });\r\n        }\r\n        let pack_result = pack(sprites, { inPlace: true });\r\n        let texture_cpu = new Uint8Array(4 * pack_result.height * pack_result.width);\r\n        this.mapping = {};\r\n        sprites.forEach(spr => {\r\n            // @ts-ignore\r\n            let x = spr.x;\r\n            // @ts-ignore\r\n            let y = spr.y;\r\n            let rgba_colors = spr.spr_colors.map(color_str => {\r\n                if (color_str == \"darkbrown\") {\r\n                    return [123, 54, 23, 255]; // random lol\r\n                }\r\n                let res = Color(color_str).array()\r\n                res.push(255)\r\n                return res\r\n            });\r\n            this.mapping[spr.spr_name] = new UVRect(x / pack_result.width, y / pack_result.height, (x + spr.width) / pack_result.width, (y + spr.height) / pack_result.height)\r\n            for (let j = 0; j < spr.width; j++) {\r\n                for (let i = 0; i < spr.height; i++) {\r\n                    let char = spr.spr_rows[j].charAt(i);\r\n                    if (char === \".\") continue;\r\n                    let pixel_color = rgba_colors[Number(char)];\r\n                    let cur_index = ((x + i) + (y + j) * pack_result.width) * 4;\r\n                    texture_cpu[cur_index + 0] = pixel_color[0];\r\n                    texture_cpu[cur_index + 1] = pixel_color[1];\r\n                    texture_cpu[cur_index + 2] = pixel_color[2];\r\n                    texture_cpu[cur_index + 3] = pixel_color[3];\r\n                }\r\n            }\r\n        })\r\n\r\n        this.atlas_texture = twgl.createTexture(gl, {\r\n            src: texture_cpu,\r\n            width: pack_result.width,\r\n            height: pack_result.height,\r\n            format: gl.RGBA,\r\n            mag: gl.NEAREST,\r\n        });\r\n\r\n        console.log(this.mapping);\r\n    }\r\n\r\n    centerLevel(level_width: number, level_height: number, sprite_size: number) {\r\n        this.origin = new Vec2(- level_width * sprite_size / this.gl.canvas.width, level_height * sprite_size / this.gl.canvas.height);\r\n        this.basis = new Vec2(2 * sprite_size / this.gl.canvas.width, -2 * sprite_size / this.gl.canvas.height);\r\n\r\n        // console.log(\"psg origin: \", this.origin.x, this.origin.y)\r\n        // console.log(\"psg basis: \", this.basis.x, this.basis.y)\r\n    }\r\n\r\n    queue(sprite_name: string, i: number, j: number) {\r\n        this.queueExtra(sprite_name, new Vec2(i, j), Vec2.one);\r\n    }\r\n\r\n    queueExtra(sprite_name: string, pos: Vec2, size: Vec2) {\r\n        let base_index = this.n_queued * 4 * VERTEX_SIZE;\r\n        let uv_data = this.mapping[sprite_name];\r\n        if (uv_data === undefined) {\r\n            throw new Error(`cant find sprite name ${sprite_name}`);\r\n\r\n        }\r\n        // tl vertex\r\n        this.vertices_cpu[base_index + 0] = pos.x;\r\n        this.vertices_cpu[base_index + 1] = pos.y;\r\n        this.vertices_cpu[base_index + 2] = uv_data.left;\r\n        this.vertices_cpu[base_index + 3] = uv_data.top;\r\n\r\n        // tr vertex\r\n        this.vertices_cpu[base_index + 4] = pos.x + size.x;\r\n        this.vertices_cpu[base_index + 5] = pos.y;\r\n        this.vertices_cpu[base_index + 6] = uv_data.right;\r\n        this.vertices_cpu[base_index + 7] = uv_data.top;\r\n\r\n        // bl vertex\r\n        this.vertices_cpu[base_index + 8] = pos.x;\r\n        this.vertices_cpu[base_index + 9] = pos.y + size.y;\r\n        this.vertices_cpu[base_index + 10] = uv_data.left;\r\n        this.vertices_cpu[base_index + 11] = uv_data.bottom;\r\n\r\n        // br vertex\r\n        this.vertices_cpu[base_index + 12] = pos.x + size.x;\r\n        this.vertices_cpu[base_index + 13] = pos.y + size.y;\r\n        this.vertices_cpu[base_index + 14] = uv_data.right;\r\n        this.vertices_cpu[base_index + 15] = uv_data.bottom;\r\n\r\n        this.n_queued += 1;\r\n    }\r\n\r\n    draw() {\r\n        let gl = this.gl;\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_gpu);\r\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices_cpu, 0, this.n_queued * 4 * VERTEX_SIZE);\r\n\r\n        gl.useProgram(this.program_info.program)\r\n        gl.bindVertexArray(this.vao_info.vertexArrayObject!);\r\n\r\n        twgl.setUniformsAndBindTextures(this.program_info, {\r\n            u_origin: [this.origin.x, this.origin.y],\r\n            u_basis: [this.basis.x, this.basis.y],\r\n            u_texture: this.atlas_texture,\r\n        });\r\n        gl.drawElements(gl.TRIANGLES, 6 * this.n_queued, gl.UNSIGNED_SHORT, 0);\r\n        this.n_queued = 0;\r\n    }\r\n}","\"use strict\";\n\nvar GrowingPacker = require('./packer.growing.js');\n\nmodule.exports = function(items, options) {\n\toptions = options || {};\n\tvar packer = new GrowingPacker();\n\tvar inPlace = options.inPlace || false;\n\n\t// Clone the items.\n\tvar newItems = items.map(function(item) { return inPlace ? item : { width: item.width, height: item.height, item: item }; });\n\n\tnewItems = newItems.sort(function(a, b) {\n\t\t// TODO: check that each actually HAS a width and a height.\n\t\t// Sort based on the size (area) of each block.\n\t\treturn (b.width * b.height) - (a.width * a.height);\n\t});\n\n\tpacker.fit(newItems);\n\n\tvar w = newItems.reduce(function(curr, item) { return Math.max(curr, item.x + item.width); }, 0);\n\tvar h = newItems.reduce(function(curr, item) { return Math.max(curr, item.y + item.height); }, 0);\n\n\tvar ret = {\n\t\twidth: w,\n\t\theight: h\n\t};\n\n\tif (!inPlace) {\n\t\tret.items = newItems;\n\t}\n\n\treturn ret;\n};\n","/******************************************************************************\n\nThis is a binary tree based bin packing algorithm that is more complex than\nthe simple Packer (packer.js). Instead of starting off with a fixed width and\nheight, it starts with the width and height of the first block passed and then\ngrows as necessary to accomodate each subsequent block. As it grows it attempts\nto maintain a roughly square ratio by making 'smart' choices about whether to\ngrow right or down.\n\nWhen growing, the algorithm can only grow to the right OR down. Therefore, if\nthe new block is BOTH wider and taller than the current target then it will be\nrejected. This makes it very important to initialize with a sensible starting\nwidth and height. If you are providing sorted input (largest first) then this\nwill not be an issue.\n\nA potential way to solve this limitation would be to allow growth in BOTH\ndirections at once, but this requires maintaining a more complex tree\nwith 3 children (down, right and center) and that complexity can be avoided\nby simply chosing a sensible starting block.\n\nBest results occur when the input blocks are sorted by height, or even better\nwhen sorted by max(width,height).\n\nInputs:\n------\n\n\tblocks: array of any objects that have .w and .h attributes\n\nOutputs:\n-------\n\n\tmarks each block that fits with a .fit attribute pointing to a\n\tnode with .x and .y coordinates\n\nExample:\n-------\n\n\tvar blocks = [\n\t\t{ w: 100, h: 100 },\n\t\t{ w: 100, h: 100 },\n\t\t{ w:  80, h:  80 },\n\t\t{ w:  80, h:  80 },\n\t\tetc\n\t\tetc\n\t];\n\n\tvar packer = new GrowingPacker();\n\tpacker.fit(blocks);\n\n\tfor(var n = 0 ; n < blocks.length ; n++) {\n\t\tvar block = blocks[n];\n\t\tif (block.fit) {\n\t\t\tDraw(block.fit.x, block.fit.y, block.w, block.h);\n\t\t}\n\t}\n\n\n******************************************************************************/\n\nvar GrowingPacker = function() { };\n\nGrowingPacker.prototype = {\n\n\tfit: function(blocks) {\n\t\tvar n, node, block, len = blocks.length, fit;\n\t\tvar width  = len > 0 ? blocks[0].width : 0;\n\t\tvar height = len > 0 ? blocks[0].height : 0;\n\t\tthis.root = { x: 0, y: 0, width: width, height: height };\n\t\tfor (n = 0; n < len ; n++) {\n\t\t\tblock = blocks[n];\n\t\t\tif (node = this.findNode(this.root, block.width, block.height)) {\n\t\t\t\tfit = this.splitNode(node, block.width, block.height);\n\t\t\t\tblock.x = fit.x;\n\t\t\t\tblock.y = fit.y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfit = this.growNode(block.width, block.height);\n\t\t\t\tblock.x = fit.x;\n\t\t\t\tblock.y = fit.y;\n\t\t\t}\n\t\t}\n\t},\n\n\tfindNode: function(root, width, height) {\n\t\tif (root.used)\n\t\t\treturn this.findNode(root.right, width, height) || this.findNode(root.down, width, height);\n\t\telse if ((width <= root.width) && (height <= root.height))\n\t\t\treturn root;\n\t\telse\n\t\t\treturn null;\n\t},\n\n\tsplitNode: function(node, width, height) {\n\t\tnode.used = true;\n\t\tnode.down  = { x: node.x,         y: node.y + height, width: node.width,         height: node.height - height };\n\t\tnode.right = { x: node.x + width, y: node.y,          width: node.width - width, height: height               };\n\t\treturn node;\n\t},\n\n\tgrowNode: function(width, height) {\n\t\tvar canGrowDown  = (width  <= this.root.width);\n\t\tvar canGrowRight = (height <= this.root.height);\n\n\t\tvar shouldGrowRight = canGrowRight && (this.root.height >= (this.root.width  + width )); // attempt to keep square-ish by growing right when height is much greater than width\n\t\tvar shouldGrowDown  = canGrowDown  && (this.root.width  >= (this.root.height + height)); // attempt to keep square-ish by growing down  when width  is much greater than height\n\n\t\tif (shouldGrowRight)\n\t\t\treturn this.growRight(width, height);\n\t\telse if (shouldGrowDown)\n\t\t\treturn this.growDown(width, height);\n\t\telse if (canGrowRight)\n\t\t\treturn this.growRight(width, height);\n\t\telse if (canGrowDown)\n\t\t\treturn this.growDown(width, height);\n\t\telse\n\t\t\treturn null; // need to ensure sensible root starting size to avoid this happening\n\t},\n\n\tgrowRight: function(width, height) {\n\t\tthis.root = {\n\t\t\tused: true,\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\twidth: this.root.width + width,\n\t\t\theight: this.root.height,\n\t\t\tdown: this.root,\n\t\t\tright: { x: this.root.width, y: 0, width: width, height: this.root.height }\n\t\t};\n\t\tvar node;\n\t\tif (node = this.findNode(this.root, width, height))\n\t\t\treturn this.splitNode(node, width, height);\n\t\telse\n\t\t\treturn null;\n\t},\n\n\tgrowDown: function(width, height) {\n\t\tthis.root = {\n\t\t\tused: true,\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\twidth: this.root.width,\n\t\t\theight: this.root.height + height,\n\t\t\tdown:  { x: 0, y: this.root.height, width: this.root.width, height: height },\n\t\t\tright: this.root\n\t\t};\n\t\tvar node;\n\t\tif (node = this.findNode(this.root, width, height))\n\t\t\treturn this.splitNode(node, width, height);\n\t\telse\n\t\t\treturn null;\n\t}\n\n};\n\nmodule.exports = GrowingPacker;\n\n"],"names":["$parcel$interopDefault","a","__esModule","default","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$6MzNI","$c15e63e86d3cb1d2$export$7d15b64cf5a3a4c4","value","min_inclusive","max_inclusive","Math","max","min","$c15e63e86d3cb1d2$export$b973696b5f65b53b","constructor","x","y","z","w","fromHex","hex_str","result","exec","parseInt","_","zero","_1","one","$c15e63e86d3cb1d2$export$ac4bca90992eed1","toString","tmp","tmp1","_2","tmp2","_3","tmp3","_4","_5","set","v","copy","out","add","b","sub","mul","div","round","negate","scale","s","lerp","t","inBounds","point","bounds","max_exclusive","$c15e63e86d3cb1d2$export$ddf89a9c5af38f94","onBorder","$c15e63e86d3cb1d2$export$66124ef7f3a58cb4","isZero","equals","map1","fn","map2","roundToCardinal","abs","$69b8e49bf8d6d1f7$exports","$6d9d5b3d477adb58$exports","$6d9d5b3d477adb58$var$GrowingPacker","prototype","fit","blocks","n","node","block","len","length","width","height","root","findNode","splitNode","growNode","used","right","down","canGrowDown","canGrowRight","shouldGrowRight","shouldGrowDown","growRight","growDown","items","options","packer","inPlace","newItems","map","item","sort","ret","reduce","curr","$9AT65","$72f198b559e83e7d$export$499e30931c411408","left","top","bottom","$d7047c8d3b3cfc96$var$gl","document","querySelector","getContext","alpha","clearColor","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","resizeCanvasToDisplaySize","canvas","viewport","drawingBufferWidth","drawingBufferHeight","$d7047c8d3b3cfc96$var$PSG","gl","sprites_data","n_queued","program_info","createProgramInfo","console","assert","max_n_sprites","vertices_cpu","Float32Array","vertices_gpu","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","DYNAMIC_DRAW","vertex_indices","Uint16Array","k","buffer_info","createBufferInfoFromArrays","a_position","buffer","numComponents","type","offset","stride","$72f198b559e83e7d$var$VERTEX_SIZE","a_texcoord","indices","data","drawType","STATIC_DRAW","vao_info","createVertexArrayInfo","sprites","spr_name","spr_data","Object","entries","spr_rows","trim","split","push","arr","$c15e63e86d3cb1d2$export$3249d46f03066cfe","res","biggest","spr_colors","pack_result","texture_cpu","Uint8Array","mapping","forEach","spr","rgba_colors","color_str","array","j","i","char","charAt","pixel_color","Number","cur_index","atlas_texture","createTexture","src","format","RGBA","mag","NEAREST","log","centerLevel","level_width","level_height","sprite_size","origin","basis","queue","sprite_name","queueExtra","pos","size","base_index","uv_data","undefined","draw","bufferSubData","useProgram","program","bindVertexArray","vertexArrayObject","setUniformsAndBindTextures","u_origin","u_basis","u_texture","drawElements","TRIANGLES","UNSIGNED_SHORT","Floor","Wall","Player","Crate","$d7047c8d3b3cfc96$var$level_src","$d7047c8d3b3cfc96$var$level_rows","r","$d7047c8d3b3cfc96$var$level_height","$d7047c8d3b3cfc96$var$level_width","every","$d7047c8d3b3cfc96$var$level_walls","c","flat","$d7047c8d3b3cfc96$var$getWallAt","$d7047c8d3b3cfc96$var$level_floors","$d7047c8d3b3cfc96$var$game_state","debug_x","debug_y","player_pos","crates_pos","$d7047c8d3b3cfc96$var$PlayerMoveCommand","original_pos","dir","execute","animTurn","turn_time","$d7047c8d3b3cfc96$var$visual_state","player_sprite","position","undoAnimTurn","undo","$d7047c8d3b3cfc96$var$PushCrateCommand","crate_index","extra_command","crates_sprites","sprite","tile_center","$d7047c8d3b3cfc96$var$BumpWallCommand","$d7047c8d3b3cfc96$var$command_history","$d7047c8d3b3cfc96$var$createSprite","crate_pos","$d7047c8d3b3cfc96$var$cur_animating_command","$d7047c8d3b3cfc96$var$cur_animating_undo_command","uv_pos","uv_size","buffer_index","$d7047c8d3b3cfc96$var$input_state","pressed","queued","requestAnimationFrame","$d7047c8d3b3cfc96$var$update","time_cur","delta","$d7047c8d3b3cfc96$var$time_last","cur_input","shift","pop","player_delta","new_player_pos","pushing_crate_index","findIndex","new_crate_pos","some","clear","COLOR_BUFFER_BIT","addEventListener","ev"],"version":3,"file":"index.4bcfa91a.js.map"}