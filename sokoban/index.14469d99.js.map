{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,e,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,S,E,C,E,O,G,E,W,E,Q,C,C,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,Q,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,K,E,Q,E,E,S,E,O,C,I,E,A,M,uB,E,I,O,E,K,mB,C,C,E,S,S,C,C,C,E,C,C,E,C,C,E,E,kB,G,E,S,Q,S,C,C,C,ECAA,a,E,E,Q,W,W,O,C,E,S,C,E,O,E,C,G,E,E,Q,U,W,O,C,E,S,C,E,O,E,C,GAEA,IAcA,EACA,EAfI,EAAU,CAAC,EAcf,EAbA,SAAkB,CAAK,EAErB,IAAK,IADD,EAAO,OAAO,KAAK,GACd,EAAI,EAAG,EAAI,EAAK,OAAQ,IAC/B,CAAO,CAAC,CAAI,CAAC,EAAE,CAAC,CAAG,CAAK,CAAC,CAAI,CAAC,EAAE,CAAC,AAErC,EASA,EARA,SAAiB,CAAE,EACjB,IAAI,EAAW,CAAO,CAAC,EAAG,CAC1B,GAAI,AAAY,MAAZ,EACF,MAAM,AAAI,MAAM,oCAAsC,GAExD,OAAO,CACT,C,GCfA,AAAA,EAAA,SAAA,SAA8C,KAAK,MAAM,+S,I,E,E,S,E,C,EGAzD,EAAe,2sB,I,E,C,ECAf,EAAe,+MCER,OAAM,EACT,YACW,EAAY,CAAG,CACf,EAAY,CAAG,CACxB,CAFS,IAAA,CAAA,EAAA,EACA,IAAA,CAAA,EAAA,CACR,C,O,C,C,C,A,C,KAEI,IAAA,CAAA,KAAO,IAAI,EAAK,EAAG,E,C,G,AAE1B,QAAO,KAAK,CAAO,CAAE,CAAU,CAAQ,CAInC,MAFA,AADA,CAAA,EAAM,GAAO,IAAI,CAAjB,EACI,EAAI,EAAE,EACV,EAAI,EAAI,EAAE,EACH,CACX,CAGA,OAAO,IAAI,CAAO,CAAE,CAAO,CAAE,CAAU,CAAQ,CAI3C,MAFA,AADA,CAAA,EAAM,GAAO,IAAI,CAAjB,EACI,EAAI,EAAE,EAAI,EAAE,EAChB,EAAI,EAAI,EAAE,EA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","sources":["<anon>","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-ebfaacd0987e6699.js","sokoban/main.ts","kommon/kommon.ts","drawSprite/shaders/sprite.vert","drawSprite/shaders/sprite.frag","kommon/math.ts","node_modules/@parcel/runtime-js/lib/runtime-6af69deb971800f0.js","node_modules/@parcel/runtime-js/lib/runtime-af940496ccff12d0.js","node_modules/@parcel/runtime-js/lib/runtime-36d6d4edf82d5325.js","node_modules/@parcel/runtime-js/lib/runtime-71be94f1a9b22f77.js"],"sourcesContent":["function $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire94c2\"] = parcelRequire;\n}\nparcelRequire.register(\"kyEFX\", function(module, exports) {\n\n$parcel$export(module.exports, \"register\", function () { return $ef7689007096c8a0$export$6503ec6e8aabbaf; }, function (v) { return $ef7689007096c8a0$export$6503ec6e8aabbaf = v; });\n$parcel$export(module.exports, \"resolve\", function () { return $ef7689007096c8a0$export$f7ad0328861e2f03; }, function (v) { return $ef7689007096c8a0$export$f7ad0328861e2f03 = v; });\nvar $ef7689007096c8a0$export$6503ec6e8aabbaf;\nvar $ef7689007096c8a0$export$f7ad0328861e2f03;\n\"use strict\";\nvar $ef7689007096c8a0$var$mapping = {};\nfunction $ef7689007096c8a0$var$register(pairs) {\n    var keys = Object.keys(pairs);\n    for(var i = 0; i < keys.length; i++)$ef7689007096c8a0$var$mapping[keys[i]] = pairs[keys[i]];\n}\nfunction $ef7689007096c8a0$var$resolve(id) {\n    var resolved = $ef7689007096c8a0$var$mapping[id];\n    if (resolved == null) throw new Error(\"Could not resolve bundle with id \" + id);\n    return resolved;\n}\n$ef7689007096c8a0$export$6503ec6e8aabbaf = $ef7689007096c8a0$var$register;\n$ef7689007096c8a0$export$f7ad0328861e2f03 = $ef7689007096c8a0$var$resolve;\n\n});\n\nvar $53964613b22e565b$exports = {};\n\n(parcelRequire(\"kyEFX\")).register(JSON.parse('{\"iPudu\":\"index.14469d99.js\",\"lRZia\":\"sprite.22ec2077.png\",\"3UC5c\":\"walls_312.cb79a6c7.png\",\"6pQwl\":\"floor_312.8cddc3eb.png\",\"6cxlj\":\"player_puzzlescript.5728a87e.png\",\"aV9ow\":\"index.c1f757b2.js\"}'));\n\n\nvar $amYBK = parcelRequire(\"amYBK\");\nfunction $267411d5da780db7$export$9f0c37400c701bee(n, callback) {\n    let result = Array(n);\n    for(let k = 0; k < n; k++)result[k] = callback(k);\n    return result;\n}\nfunction $267411d5da780db7$export$f01e84010c13cebe(lo, hi, callback) {\n    let count = hi - lo;\n    let result = Array(count);\n    for(let k = 0; k < count; k++)result[k] = callback(k + lo);\n    return result;\n}\nfunction $267411d5da780db7$export$dff840edf10f285e(cur, target, max_delta) {\n    if (cur > target) return Math.max(cur - max_delta, target);\n    else if (cur < target) return Math.min(cur + max_delta, target);\n    else return target;\n}\n\n\nvar $25fe13573bce6064$exports = {};\n$25fe13573bce6064$exports = \"#version 300 es\\n#define GLSLIFY 1\\n\\n// [0, 1]^2\\nin vec2 a_vertex;\\n\\n// pixels for everything\\nuniform vec2 u_resolution;\\nuniform vec2 u_position;\\nuniform vec2 u_size;\\n\\nout vec2 v_texcoord;\\n\\nvoid main() {\\n    // if size is 100 & screen is 400, then\\n    // clip space result width will be .5\\n    vec2 pos = 2.0 * a_vertex * u_size / u_resolution;\\n\\n    // if position is 200 & screen is 400, then\\n    // clip space result offset will be .5\\n    pos += 2.0 * u_position / u_resolution;\\n\\n    // pos of 0 should go to the top left\\n    pos -= vec2(1, 1);\\n\\n    // ypos = down\\n    pos.y = -pos.y;\\n\\n    gl_Position = vec4(pos, 0, 1);\\n\\n    v_texcoord = a_vertex;\\n}\\n\\n// todo: investigate glslify\";\n\n\nvar $2ac028d4d6421c3a$exports = {};\n$2ac028d4d6421c3a$exports = \"#version 300 es\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nin vec2 v_texcoord;\\n\\nuniform sampler2D u_texture;\\n\\nout vec4 out_color;\\n\\nvoid main() {\\n    out_color = texture(u_texture, v_texcoord);\\n}\";\n\n\n// Use objects instead of arrays: https://jsben.ch/FgKVi\nclass $5c4293b9a464b6e0$export$ac4bca90992eed1 {\n    constructor(x = 0.0, y = 0.0){\n        this.x = x;\n        this.y = y;\n    }\n    static #_ = (()=>{\n        this.zero = new $5c4293b9a464b6e0$export$ac4bca90992eed1(0, 0);\n    })();\n    static copy(v, out) {\n        out = out || new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        out.x = v.x;\n        out.y = v.y;\n        return out;\n    }\n    static add(a, b, out) {\n        out = out || new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        out.x = a.x + b.x;\n        out.y = a.y + b.y;\n        return out;\n    }\n    static sub(a, b, out) {\n        out = out || new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        out.x = a.x - b.x;\n        out.y = a.y - b.y;\n        return out;\n    }\n    static negate(v, out) {\n        out = out || new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        out.x = -v.x;\n        out.y = -v.y;\n        return out;\n    }\n    static isZero(v) {\n        return v.x == 0 && v.y == 0;\n    }\n    static map2(a, b, fn, out) {\n        out = out || new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        out.x = fn(a.x, b.x);\n        out.y = fn(a.y, b.y);\n        return out;\n    }\n}\n\n\n// This \"if\" will only execute during development\nif (null) {\n    null.dispose((data)=>{\n        data.game_state = $093282bf79b6fc15$var$game_state;\n        cancelAnimationFrame($093282bf79b6fc15$var$loop_id);\n        document.removeEventListener(\"keydown\", $093282bf79b6fc15$var$onKeyDown);\n        document.removeEventListener(\"keyup\", $093282bf79b6fc15$var$onKeyUp);\n    });\n    null.accept((_)=>{\n        $093282bf79b6fc15$var$game_state = null.data.game_state;\n        $093282bf79b6fc15$var$moving_sprites_cpu[$093282bf79b6fc15$var$player_sprite_index * 4 + 0] = $093282bf79b6fc15$var$game_state.player_pos.x;\n        $093282bf79b6fc15$var$moving_sprites_cpu[$093282bf79b6fc15$var$player_sprite_index * 4 + 1] = $093282bf79b6fc15$var$game_state.player_pos.y;\n    });\n}\nconst $093282bf79b6fc15$var$gl = document.querySelector(\"#c\").getContext(\"webgl2\", {\n    alpha: false\n});\n$093282bf79b6fc15$var$gl.clearColor(0.5, 0.5, 0.75, 1.0);\n$093282bf79b6fc15$var$gl.enable($093282bf79b6fc15$var$gl.BLEND);\n$093282bf79b6fc15$var$gl.blendFunc($093282bf79b6fc15$var$gl.SRC_ALPHA, $093282bf79b6fc15$var$gl.ONE_MINUS_SRC_ALPHA);\n$amYBK.resizeCanvasToDisplaySize($093282bf79b6fc15$var$gl.canvas);\n$093282bf79b6fc15$var$gl.viewport(0, 0, $093282bf79b6fc15$var$gl.drawingBufferWidth, $093282bf79b6fc15$var$gl.drawingBufferHeight);\nvar $22fc558e6fe70830$exports = {};\n\n$22fc558e6fe70830$exports = new URL(\"../\" + (parcelRequire(\"kyEFX\")).resolve(\"lRZia\"), import.meta.url).toString();\n\n\nconst $093282bf79b6fc15$var$my_texture = $amYBK.createTexture($093282bf79b6fc15$var$gl, {\n    src: new URL($22fc558e6fe70830$exports).toString()\n});\nconst $093282bf79b6fc15$var$sprite_program_info = $amYBK.createProgramInfo($093282bf79b6fc15$var$gl, [\n    (0, (/*@__PURE__*/$parcel$interopDefault($25fe13573bce6064$exports))),\n    (0, (/*@__PURE__*/$parcel$interopDefault($2ac028d4d6421c3a$exports)))\n]);\nconst $093282bf79b6fc15$var$sprite_buffer_info = $amYBK.createBufferInfoFromArrays($093282bf79b6fc15$var$gl, {\n    a_vertex: {\n        data: [\n            // Triangle for 1,1 corner\n            1.0,\n            1.0,\n            0.0,\n            1.0,\n            1.0,\n            0.0,\n            // Triangle for 0,0 corner\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            1.0\n        ],\n        numComponents: 2\n    }\n});\nconst $093282bf79b6fc15$var$sprite_vao = $amYBK.createVertexArrayInfo($093282bf79b6fc15$var$gl, $093282bf79b6fc15$var$sprite_program_info, $093282bf79b6fc15$var$sprite_buffer_info);\n// data for sprite renderer\n// per tile:\n// - 4 vertices : vec8\n// - 2 uv vertices : vec4\n// ?? idk, depends on the specifics (do we want rotation? arbitrary rotation? arbitrary uvs? coords on pixels or tiles or screen?)\n// for now, let's do it perfectly, one thing at a time\n// and from there, get an imperfect but general system\n// min data for a tilemap:\n// global:\n// - screen resolution : vec2\n// - tilemap count : vec2\n// - tilemap top left : vec2\n// - tile size : float/vec2?/vec4 (if allowing an arbitrary base)\n//    (for now, float)\n// per tile:\n// - tile index : vec2\n// - position : vec2\n// draw an instanced [0,1] quad, or maybe directly use vertexId?\n// in any case, a_vertex is a [0,1] quad\n// computations:\n// - pos = u_origin + (a_vertex + a_position) * vec2(u_basis_x, u_basis_y)\n// - uv = (a_tilemap_index + a_vertex) / u_sprite_counts\n// tothink:\n//   what if there's a margin?\n//   no need for position if we assume a rectangular tilemap... but that's too much\n//   another option is to always use the same mesh, & only change tile indices\n//     todo: that seems cool, will do when this one is working\nconst $093282bf79b6fc15$var$tilemap_programinfo = $amYBK.createProgramInfo($093282bf79b6fc15$var$gl, [\n    // vs\n    `#version 300 es\r\n\r\n    // [0, 1]^2 (in other words, a quad)\r\n    in vec2 a_vertex;\r\n\r\n    // per-sprite data\r\n    in vec2 a_position;\r\n    in vec2 a_tileindex;\r\n\r\n    // global data\r\n    // sprites drawn at 0,0 will end in this clipspace position\r\n    uniform vec2 u_origin;\r\n    // sprites drawn at 1,1 will end in u_origin plus this clipspace position\r\n    uniform vec2 u_basis;\r\n    // number of sprites in the spritesheet\r\n    uniform vec2 u_sheet_count;\r\n\r\n    out vec2 v_texcoord;\r\n\r\n    void main() {\r\n        gl_Position = vec4(u_origin + (a_vertex + a_position) * u_basis, 0.0, 1.0);\r\n        v_texcoord = (a_tileindex + a_vertex) / u_sheet_count;\r\n    }\r\n    `,\n    // fs\n    `#version 300 es\r\n    precision highp float;\r\n    \r\n    in vec2 v_texcoord;\r\n\r\n    uniform sampler2D u_sheet;\r\n\r\n    out vec4 out_color;\r\n\r\n    void main() {\r\n        out_color = texture(u_sheet, v_texcoord);\r\n    }\r\n    `\n]);\nvar $e5c42df7f77c5287$exports = {};\n\n$e5c42df7f77c5287$exports = new URL(\"../\" + (parcelRequire(\"kyEFX\")).resolve(\"3UC5c\"), import.meta.url).toString();\n\n\nconst $093282bf79b6fc15$var$tilemap_texture = $amYBK.createTexture($093282bf79b6fc15$var$gl, {\n    src: new URL($e5c42df7f77c5287$exports).toString(),\n    mag: $093282bf79b6fc15$var$gl.NEAREST,\n    wrap: $093282bf79b6fc15$var$gl.REPEAT\n});\nconst $093282bf79b6fc15$var$level_src = `\r\n####!!\r\n#.O#!!\r\n#..###\r\n#@P..#\r\n#..*.#\r\n#..###\r\n####!!\r\n`.trim();\nconst $093282bf79b6fc15$var$level_rows = $093282bf79b6fc15$var$level_src.split(\"\\n\").map((r)=>r.trim());\nconst $093282bf79b6fc15$var$level_height = $093282bf79b6fc15$var$level_rows.length;\nconst $093282bf79b6fc15$var$level_width = $093282bf79b6fc15$var$level_rows[0].length;\nconsole.assert($093282bf79b6fc15$var$level_rows.every((r)=>r.length == $093282bf79b6fc15$var$level_width), \"Bad ascii level\");\nconst $093282bf79b6fc15$var$level_walls = $093282bf79b6fc15$var$level_rows.map((r)=>r.split(\"\").map((c)=>c == \"#\")).flat();\nfunction $093282bf79b6fc15$var$getWallAt(i, j) {\n    if (i < 0 || i >= $093282bf79b6fc15$var$level_width || j < 0 || j >= $093282bf79b6fc15$var$level_height) return false;\n    return $093282bf79b6fc15$var$level_walls[i + j * $093282bf79b6fc15$var$level_width];\n}\nfunction $093282bf79b6fc15$var$getTileIndex(i, j) {\n    // Same numbering as http://www.cr31.co.uk/stagecast/wang/2corn.html\n    let tr_corner = $093282bf79b6fc15$var$getWallAt(i - 0, j - 1) ? 1 : 0;\n    let br_corner = $093282bf79b6fc15$var$getWallAt(i - 0, j - 0) ? 2 : 0;\n    let bl_corner = $093282bf79b6fc15$var$getWallAt(i - 1, j - 0) ? 4 : 0;\n    let tl_corner = $093282bf79b6fc15$var$getWallAt(i - 1, j - 1) ? 8 : 0;\n    let lookup_index = tl_corner + tr_corner + bl_corner + br_corner;\n    const lookup_table = [\n        [\n            0,\n            3\n        ],\n        [\n            0,\n            2\n        ],\n        [\n            1,\n            3\n        ],\n        [\n            1,\n            0\n        ],\n        [\n            0,\n            0\n        ],\n        [\n            2,\n            3\n        ],\n        [\n            3,\n            0\n        ],\n        [\n            1,\n            1\n        ],\n        [\n            3,\n            3\n        ],\n        [\n            1,\n            2\n        ],\n        [\n            0,\n            1\n        ],\n        [\n            2,\n            2\n        ],\n        [\n            3,\n            2\n        ],\n        [\n            3,\n            1\n        ],\n        [\n            2,\n            0\n        ],\n        [\n            2,\n            1\n        ]\n    ];\n    return lookup_table[lookup_index];\n}\nconst $093282bf79b6fc15$var$tilemap_tilesize = 64;\nconst $093282bf79b6fc15$var$tilemap_width = $093282bf79b6fc15$var$level_width + 1;\nconst $093282bf79b6fc15$var$tilemap_height = $093282bf79b6fc15$var$level_height + 1;\nconst $093282bf79b6fc15$var$tilemap_data_cpu = new Float32Array(4 * $093282bf79b6fc15$var$tilemap_width * $093282bf79b6fc15$var$tilemap_height);\nfor(let j = 0; j < $093282bf79b6fc15$var$tilemap_height; j++)for(let i = 0; i < $093282bf79b6fc15$var$tilemap_width; i++){\n    let k = (i + j * $093282bf79b6fc15$var$tilemap_width) * 4;\n    // x,y position; no tilemap specific logic\n    $093282bf79b6fc15$var$tilemap_data_cpu[k + 0] = i;\n    $093282bf79b6fc15$var$tilemap_data_cpu[k + 1] = j;\n    // actual tile to use, depends on the actual map state\n    let cur_index = $093282bf79b6fc15$var$getTileIndex(i, j);\n    $093282bf79b6fc15$var$tilemap_data_cpu[k + 2] = cur_index[0];\n    $093282bf79b6fc15$var$tilemap_data_cpu[k + 3] = cur_index[1];\n}\nconst $093282bf79b6fc15$var$tilemap_buffer = $093282bf79b6fc15$var$gl.createBuffer();\n$093282bf79b6fc15$var$gl.bindBuffer($093282bf79b6fc15$var$gl.ARRAY_BUFFER, $093282bf79b6fc15$var$tilemap_buffer);\n$093282bf79b6fc15$var$gl.bufferData($093282bf79b6fc15$var$gl.ARRAY_BUFFER, $093282bf79b6fc15$var$tilemap_data_cpu, $093282bf79b6fc15$var$gl.STATIC_DRAW);\nlet $093282bf79b6fc15$var$tilemap_vaoinfo = $amYBK.createVertexArrayInfo($093282bf79b6fc15$var$gl, $093282bf79b6fc15$var$tilemap_programinfo, $amYBK.createBufferInfoFromArrays($093282bf79b6fc15$var$gl, {\n    a_position: {\n        buffer: $093282bf79b6fc15$var$tilemap_buffer,\n        type: $093282bf79b6fc15$var$gl.FLOAT,\n        numComponents: 2,\n        stride: 16,\n        offset: 0,\n        divisor: 1\n    },\n    a_tileindex: {\n        buffer: $093282bf79b6fc15$var$tilemap_buffer,\n        type: $093282bf79b6fc15$var$gl.FLOAT,\n        numComponents: 2,\n        stride: 16,\n        offset: 8,\n        divisor: 1\n    },\n    a_vertex: {\n        data: [\n            // Triangle for 1,1 corner\n            1.0,\n            1.0,\n            0.0,\n            1.0,\n            1.0,\n            0.0,\n            // Triangle for 0,0 corner\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            1.0\n        ],\n        numComponents: 2\n    }\n}));\nvar $093282bf79b6fc15$var$vao, $093282bf79b6fc15$var$size, $093282bf79b6fc15$var$type, $093282bf79b6fc15$var$normalize, $093282bf79b6fc15$var$stride, $093282bf79b6fc15$var$offset, $093282bf79b6fc15$var$size, $093282bf79b6fc15$var$type, $093282bf79b6fc15$var$normalize, $093282bf79b6fc15$var$stride, $093282bf79b6fc15$var$offset;\nvar $cda84142577741c0$exports = {};\n\n$cda84142577741c0$exports = new URL(\"../\" + (parcelRequire(\"kyEFX\")).resolve(\"6pQwl\"), import.meta.url).toString();\n\n\nconst $093282bf79b6fc15$var$floor_texture = $amYBK.createTexture($093282bf79b6fc15$var$gl, {\n    src: new URL($cda84142577741c0$exports).toString(),\n    mag: $093282bf79b6fc15$var$gl.NEAREST,\n    wrap: $093282bf79b6fc15$var$gl.REPEAT\n});\nlet $093282bf79b6fc15$var$level_floors = $093282bf79b6fc15$var$level_rows.map((r)=>r.split(\"\").map((c)=>c != \"#\" && c != \"!\")).flat();\n// Floor approach: only first fill N tiles\n// use same shader, or another? for now, let's keep the same one\nconst $093282bf79b6fc15$var$floormap_data_cpu = new Float32Array(4 * $093282bf79b6fc15$var$level_width * $093282bf79b6fc15$var$level_height);\nlet $093282bf79b6fc15$var$n_floors = 0;\nfor(let j = 0; j < $093282bf79b6fc15$var$level_height; j++){\n    for(let i = 0; i < $093282bf79b6fc15$var$level_width; i++)if ($093282bf79b6fc15$var$level_floors[i + j * $093282bf79b6fc15$var$level_width]) {\n        // x,y position\n        $093282bf79b6fc15$var$floormap_data_cpu[$093282bf79b6fc15$var$n_floors * 4 + 0] = i;\n        $093282bf79b6fc15$var$floormap_data_cpu[$093282bf79b6fc15$var$n_floors * 4 + 1] = j;\n        // actual tile to use is always 0,0\n        $093282bf79b6fc15$var$tilemap_data_cpu[$093282bf79b6fc15$var$n_floors * 4 + 2] = 0;\n        $093282bf79b6fc15$var$tilemap_data_cpu[$093282bf79b6fc15$var$n_floors * 4 + 3] = 0;\n        $093282bf79b6fc15$var$n_floors += 1;\n    }\n}\nconst $093282bf79b6fc15$var$floormap_buffer = $093282bf79b6fc15$var$gl.createBuffer();\n$093282bf79b6fc15$var$gl.bindBuffer($093282bf79b6fc15$var$gl.ARRAY_BUFFER, $093282bf79b6fc15$var$floormap_buffer);\n$093282bf79b6fc15$var$gl.bufferData($093282bf79b6fc15$var$gl.ARRAY_BUFFER, $093282bf79b6fc15$var$floormap_data_cpu, $093282bf79b6fc15$var$gl.STATIC_DRAW);\nlet $093282bf79b6fc15$var$floormap_vaoinfo = $amYBK.createVertexArrayInfo($093282bf79b6fc15$var$gl, $093282bf79b6fc15$var$tilemap_programinfo, $amYBK.createBufferInfoFromArrays($093282bf79b6fc15$var$gl, {\n    a_position: {\n        buffer: $093282bf79b6fc15$var$floormap_buffer,\n        type: $093282bf79b6fc15$var$gl.FLOAT,\n        numComponents: 2,\n        stride: 16,\n        offset: 0,\n        divisor: 1\n    },\n    a_tileindex: {\n        buffer: $093282bf79b6fc15$var$floormap_buffer,\n        type: $093282bf79b6fc15$var$gl.FLOAT,\n        numComponents: 2,\n        stride: 16,\n        offset: 8,\n        divisor: 1\n    },\n    a_vertex: {\n        data: [\n            // Triangle for 1,1 corner\n            1.0,\n            1.0,\n            0.0,\n            1.0,\n            1.0,\n            0.0,\n            // Triangle for 0,0 corner\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            1.0\n        ],\n        numComponents: 2\n    }\n}));\n// Player & boxes sprite drawing\n// for now, let's keep the same shader\n// this batching only makes sense if all textures are in the same atlas\n// but texture packing is boooring & unflexible (unless we had a custom parcel plugin...)\n// maybe i'm overcomplicating stuff for no gain :/\n// nah, even with different textures, it's cool to have a single buffer, since we can draw subsets of it.\nconst $093282bf79b6fc15$var$max_n_sprites = 32;\nvar $093282bf79b6fc15$var$cur_n_sprites = 0;\nvar $093282bf79b6fc15$var$moving_sprites_cpu = new Float32Array($093282bf79b6fc15$var$max_n_sprites * 4);\nconst $093282bf79b6fc15$var$moving_sprites_buffer = $093282bf79b6fc15$var$gl.createBuffer();\n$093282bf79b6fc15$var$gl.bindBuffer($093282bf79b6fc15$var$gl.ARRAY_BUFFER, $093282bf79b6fc15$var$moving_sprites_buffer);\n$093282bf79b6fc15$var$gl.bufferData($093282bf79b6fc15$var$gl.ARRAY_BUFFER, $093282bf79b6fc15$var$moving_sprites_cpu, $093282bf79b6fc15$var$gl.DYNAMIC_DRAW);\nlet $093282bf79b6fc15$var$moving_sprites_vaoinfo = $amYBK.createVertexArrayInfo($093282bf79b6fc15$var$gl, $093282bf79b6fc15$var$tilemap_programinfo, $amYBK.createBufferInfoFromArrays($093282bf79b6fc15$var$gl, {\n    a_position: {\n        buffer: $093282bf79b6fc15$var$moving_sprites_buffer,\n        type: $093282bf79b6fc15$var$gl.FLOAT,\n        numComponents: 2,\n        stride: 16,\n        offset: 0,\n        divisor: 1\n    },\n    a_tileindex: {\n        buffer: $093282bf79b6fc15$var$moving_sprites_buffer,\n        type: $093282bf79b6fc15$var$gl.FLOAT,\n        numComponents: 2,\n        stride: 16,\n        offset: 8,\n        divisor: 1\n    },\n    a_vertex: {\n        data: [\n            // Triangle for 1,1 corner\n            1.0,\n            1.0,\n            0.0,\n            1.0,\n            1.0,\n            0.0,\n            // Triangle for 0,0 corner\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            1.0\n        ],\n        numComponents: 2\n    }\n}));\nvar $db26ee343f5bac19$exports = {};\n\n$db26ee343f5bac19$exports = new URL(\"../\" + (parcelRequire(\"kyEFX\")).resolve(\"6cxlj\"), import.meta.url).toString();\n\n\nconst $093282bf79b6fc15$var$player_texture = $amYBK.createTexture($093282bf79b6fc15$var$gl, {\n    src: new URL($db26ee343f5bac19$exports).toString(),\n    mag: $093282bf79b6fc15$var$gl.NEAREST,\n    wrap: $093282bf79b6fc15$var$gl.REPEAT\n});\nlet $093282bf79b6fc15$var$game_state = {\n    debug_x: 0,\n    debug_y: 0,\n    player_pos: new (0, $5c4293b9a464b6e0$export$ac4bca90992eed1)(2, 3)\n};\nlet $093282bf79b6fc15$var$visual_state = {\n    player_offset: new (0, $5c4293b9a464b6e0$export$ac4bca90992eed1)(0.0, 0.0)\n};\nlet $093282bf79b6fc15$var$move_duration = .05;\n// player sprite data\nlet $093282bf79b6fc15$var$player_sprite_index = $093282bf79b6fc15$var$cur_n_sprites;\n$093282bf79b6fc15$var$cur_n_sprites += 1;\n$093282bf79b6fc15$var$moving_sprites_cpu[$093282bf79b6fc15$var$player_sprite_index * 4 + 0] = $093282bf79b6fc15$var$game_state.player_pos.x;\n$093282bf79b6fc15$var$moving_sprites_cpu[$093282bf79b6fc15$var$player_sprite_index * 4 + 1] = $093282bf79b6fc15$var$game_state.player_pos.y;\n$093282bf79b6fc15$var$moving_sprites_cpu[$093282bf79b6fc15$var$player_sprite_index * 4 + 2] = 0; // tile index\n$093282bf79b6fc15$var$moving_sprites_cpu[$093282bf79b6fc15$var$player_sprite_index * 4 + 3] = 0;\nlet $093282bf79b6fc15$var$input_state = {\n    pressed: {},\n    queued: []\n};\nlet $093282bf79b6fc15$var$loop_id = requestAnimationFrame($093282bf79b6fc15$var$update);\ndocument.addEventListener(\"keydown\", $093282bf79b6fc15$var$onKeyDown);\ndocument.addEventListener(\"keyup\", $093282bf79b6fc15$var$onKeyUp);\nfunction $093282bf79b6fc15$var$onKeyDown(ev) {\n    console.log(\"keydown\");\n    $093282bf79b6fc15$var$input_state.pressed[ev.code] = true;\n    $093282bf79b6fc15$var$input_state.queued.push(ev.code);\n/*switch (ev.code) {\r\n        case \"KeyD\":\r\n            input_state.d_down = true;\r\n            break;\r\n        case \"KeyA\":\r\n            input_state.a_down = true;\r\n            break;\r\n        case \"KeyW\":\r\n            input_state.w_down = true;\r\n            break;\r\n        case \"KeyS\":\r\n            input_state.s_down = true;\r\n            break;\r\n    }*/ }\nfunction $093282bf79b6fc15$var$onKeyUp(ev) {\n    console.log(\"keyup\");\n    $093282bf79b6fc15$var$input_state.pressed[ev.code] = false;\n/*switch (ev.code) {\r\n        case \"KeyD\":\r\n            input_state.d_down = false;\r\n            break;\r\n        case \"KeyA\":\r\n            input_state.a_down = false;\r\n            break;\r\n        case \"KeyW\":\r\n            input_state.w_down = false;\r\n            break;\r\n        case \"KeyS\":\r\n            input_state.s_down = false;\r\n            break;\r\n    }*/ }\nlet $093282bf79b6fc15$var$time_last = 0;\nfunction $093282bf79b6fc15$var$update(time_cur) {\n    let delta = (time_cur - $093282bf79b6fc15$var$time_last) * 0.001;\n    $093282bf79b6fc15$var$time_last = time_cur;\n    if ($amYBK.resizeCanvasToDisplaySize($093282bf79b6fc15$var$gl.canvas)) $093282bf79b6fc15$var$gl.viewport(0, 0, $093282bf79b6fc15$var$gl.drawingBufferWidth, $093282bf79b6fc15$var$gl.drawingBufferHeight);\n    if ($093282bf79b6fc15$var$input_state.pressed[\"KeyA\"]) $093282bf79b6fc15$var$game_state.debug_x -= 1;\n    if ($093282bf79b6fc15$var$input_state.pressed[\"KeyD\"]) $093282bf79b6fc15$var$game_state.debug_x += 1;\n    if ($093282bf79b6fc15$var$input_state.pressed[\"KeyW\"]) $093282bf79b6fc15$var$game_state.debug_y -= 1;\n    if ($093282bf79b6fc15$var$input_state.pressed[\"KeyS\"]) $093282bf79b6fc15$var$game_state.debug_y += 1;\n    // console.log(game_state.x, game_state.y);\n    // todo: undo\n    if ($093282bf79b6fc15$var$input_state.queued.length > 0 && (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).isZero($093282bf79b6fc15$var$visual_state.player_offset)) {\n        let cur_input = $093282bf79b6fc15$var$input_state.queued.shift();\n        let player_delta = new (0, $5c4293b9a464b6e0$export$ac4bca90992eed1)();\n        switch(cur_input){\n            case \"KeyD\":\n                player_delta.x = 1;\n                break;\n            case \"KeyA\":\n                player_delta.x = -1;\n                break;\n            case \"KeyW\":\n                player_delta.y = -1;\n                break;\n            case \"KeyS\":\n                player_delta.y = 1;\n                break;\n        }\n        if (player_delta.x != 0 || player_delta.y != 0) {\n            let new_player_pos = (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).add($093282bf79b6fc15$var$game_state.player_pos, player_delta);\n            if (!$093282bf79b6fc15$var$getWallAt(new_player_pos.x, new_player_pos.y)) {\n                (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).copy(new_player_pos, $093282bf79b6fc15$var$game_state.player_pos);\n                (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).sub($093282bf79b6fc15$var$visual_state.player_offset, player_delta, $093282bf79b6fc15$var$visual_state.player_offset);\n            }\n        }\n    }\n    if (!(0, $5c4293b9a464b6e0$export$ac4bca90992eed1).isZero($093282bf79b6fc15$var$visual_state.player_offset)) {\n        (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).map2($093282bf79b6fc15$var$visual_state.player_offset, (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).zero, (a, b)=>(0, $267411d5da780db7$export$dff840edf10f285e)(a, b, delta / $093282bf79b6fc15$var$move_duration), $093282bf79b6fc15$var$visual_state.player_offset);\n        $093282bf79b6fc15$var$moving_sprites_cpu[$093282bf79b6fc15$var$player_sprite_index * 4 + 0] = $093282bf79b6fc15$var$game_state.player_pos.x + $093282bf79b6fc15$var$visual_state.player_offset.x;\n        $093282bf79b6fc15$var$moving_sprites_cpu[$093282bf79b6fc15$var$player_sprite_index * 4 + 1] = $093282bf79b6fc15$var$game_state.player_pos.y + $093282bf79b6fc15$var$visual_state.player_offset.y;\n    }\n    $093282bf79b6fc15$var$gl.clear($093282bf79b6fc15$var$gl.COLOR_BUFFER_BIT);\n    // Debug temp stuff\n    $093282bf79b6fc15$var$gl.useProgram($093282bf79b6fc15$var$sprite_program_info.program);\n    $amYBK.setBuffersAndAttributes($093282bf79b6fc15$var$gl, $093282bf79b6fc15$var$sprite_program_info, $093282bf79b6fc15$var$sprite_vao);\n    $amYBK.setUniforms($093282bf79b6fc15$var$sprite_program_info, {\n        u_texture: $093282bf79b6fc15$var$my_texture,\n        u_resolution: [\n            $093282bf79b6fc15$var$gl.canvas.width,\n            $093282bf79b6fc15$var$gl.canvas.height\n        ],\n        u_size: [\n            50,\n            50\n        ],\n        u_position: [\n            $093282bf79b6fc15$var$game_state.debug_x,\n            $093282bf79b6fc15$var$game_state.debug_y\n        ]\n    });\n    $amYBK.drawBufferInfo($093282bf79b6fc15$var$gl, $093282bf79b6fc15$var$sprite_buffer_info);\n    // walls\n    $093282bf79b6fc15$var$gl.useProgram($093282bf79b6fc15$var$tilemap_programinfo.program);\n    $093282bf79b6fc15$var$gl.bindVertexArray($093282bf79b6fc15$var$tilemap_vaoinfo.vertexArrayObject);\n    $amYBK.setUniformsAndBindTextures($093282bf79b6fc15$var$tilemap_programinfo, {\n        u_origin: [\n            -$093282bf79b6fc15$var$tilemap_width * $093282bf79b6fc15$var$tilemap_tilesize / $093282bf79b6fc15$var$gl.canvas.width,\n            $093282bf79b6fc15$var$tilemap_height * $093282bf79b6fc15$var$tilemap_tilesize / $093282bf79b6fc15$var$gl.canvas.height\n        ],\n        u_basis: [\n            2 * $093282bf79b6fc15$var$tilemap_tilesize / $093282bf79b6fc15$var$gl.canvas.width,\n            -2 * $093282bf79b6fc15$var$tilemap_tilesize / $093282bf79b6fc15$var$gl.canvas.height\n        ],\n        u_sheet_count: [\n            4,\n            4\n        ],\n        u_sheet: $093282bf79b6fc15$var$tilemap_texture\n    });\n    $093282bf79b6fc15$var$gl.drawArraysInstanced($093282bf79b6fc15$var$gl.TRIANGLES, 0, 6, $093282bf79b6fc15$var$tilemap_width * $093282bf79b6fc15$var$tilemap_height);\n    // floors\n    $093282bf79b6fc15$var$gl.bindVertexArray($093282bf79b6fc15$var$floormap_vaoinfo.vertexArrayObject);\n    $amYBK.setUniformsAndBindTextures($093282bf79b6fc15$var$tilemap_programinfo, {\n        u_origin: [\n            -$093282bf79b6fc15$var$level_width * $093282bf79b6fc15$var$tilemap_tilesize / $093282bf79b6fc15$var$gl.canvas.width,\n            $093282bf79b6fc15$var$level_height * $093282bf79b6fc15$var$tilemap_tilesize / $093282bf79b6fc15$var$gl.canvas.height\n        ],\n        u_basis: [\n            2 * $093282bf79b6fc15$var$tilemap_tilesize / $093282bf79b6fc15$var$gl.canvas.width,\n            -2 * $093282bf79b6fc15$var$tilemap_tilesize / $093282bf79b6fc15$var$gl.canvas.height\n        ],\n        u_sheet_count: [\n            1,\n            1\n        ],\n        u_sheet: $093282bf79b6fc15$var$floor_texture\n    });\n    $093282bf79b6fc15$var$gl.drawArraysInstanced($093282bf79b6fc15$var$gl.TRIANGLES, 0, 6, $093282bf79b6fc15$var$n_floors);\n    // player\n    $093282bf79b6fc15$var$gl.bindBuffer($093282bf79b6fc15$var$gl.ARRAY_BUFFER, $093282bf79b6fc15$var$moving_sprites_buffer);\n    $093282bf79b6fc15$var$gl.bufferSubData($093282bf79b6fc15$var$gl.ARRAY_BUFFER, 0, $093282bf79b6fc15$var$moving_sprites_cpu);\n    $093282bf79b6fc15$var$gl.bindVertexArray($093282bf79b6fc15$var$moving_sprites_vaoinfo.vertexArrayObject);\n    $amYBK.setUniformsAndBindTextures($093282bf79b6fc15$var$tilemap_programinfo, {\n        u_origin: [\n            -$093282bf79b6fc15$var$level_width * $093282bf79b6fc15$var$tilemap_tilesize / $093282bf79b6fc15$var$gl.canvas.width,\n            $093282bf79b6fc15$var$level_height * $093282bf79b6fc15$var$tilemap_tilesize / $093282bf79b6fc15$var$gl.canvas.height\n        ],\n        u_basis: [\n            2 * $093282bf79b6fc15$var$tilemap_tilesize / $093282bf79b6fc15$var$gl.canvas.width,\n            -2 * $093282bf79b6fc15$var$tilemap_tilesize / $093282bf79b6fc15$var$gl.canvas.height\n        ],\n        u_sheet_count: [\n            1,\n            1\n        ],\n        u_sheet: $093282bf79b6fc15$var$player_texture\n    });\n    $093282bf79b6fc15$var$gl.drawArraysInstanced($093282bf79b6fc15$var$gl.TRIANGLES, 0, 6, $093282bf79b6fc15$var$cur_n_sprites);\n    $093282bf79b6fc15$var$loop_id = requestAnimationFrame($093282bf79b6fc15$var$update);\n}\n\n\n//# sourceMappingURL=index.14469d99.js.map\n","\"use strict\";\n\nvar mapping = {};\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping[id];\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return resolved;\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"iPudu\\\":\\\"index.14469d99.js\\\",\\\"lRZia\\\":\\\"sprite.22ec2077.png\\\",\\\"3UC5c\\\":\\\"walls_312.cb79a6c7.png\\\",\\\"6pQwl\\\":\\\"floor_312.8cddc3eb.png\\\",\\\"6cxlj\\\":\\\"player_puzzlescript.5728a87e.png\\\",\\\"aV9ow\\\":\\\"index.c1f757b2.js\\\"}\"));","import * as twgl from \"twgl.js\"\r\nimport { fromRange, towards } from \"../kommon/kommon\";\r\n\r\n// This \"if\" will only execute during development\r\nif (module.hot) {\r\n    module.hot.dispose(data => {\r\n        data.game_state = game_state;\r\n        cancelAnimationFrame(loop_id);\r\n        document.removeEventListener(\"keydown\", onKeyDown);\r\n        document.removeEventListener(\"keyup\", onKeyUp);\r\n    });\r\n    module.hot.accept(_ => {\r\n        game_state = module.hot!.data.game_state;\r\n        moving_sprites_cpu[player_sprite_index * 4 + 0] = game_state.player_pos.x;\r\n        moving_sprites_cpu[player_sprite_index * 4 + 1] = game_state.player_pos.y;\r\n    });\r\n}\r\n\r\nconst gl = (document.querySelector(\"#c\") as HTMLCanvasElement).getContext(\"webgl2\", { alpha: false })!;\r\ngl.clearColor(0.5, 0.5, 0.75, 1.0);\r\ngl.enable(gl.BLEND);\r\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\ntwgl.resizeCanvasToDisplaySize(gl.canvas as HTMLCanvasElement);\r\ngl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n\r\nconst my_texture = twgl.createTexture(gl, {\r\n    src: (new URL('sprite.png', import.meta.url)).toString(),\r\n    // mag: gl.NEAREST, etc\r\n});\r\n\r\n// @ts-ignore\r\nimport vert_source from \"../drawSprite/shaders/sprite.vert\";\r\n// @ts-ignore\r\nimport frag_source from \"../drawSprite/shaders/sprite.frag\";\r\nimport { Vec2 } from \"../kommon/math\";\r\nconst sprite_program_info = twgl.createProgramInfo(gl, [vert_source, frag_source]);\r\nconst sprite_buffer_info = twgl.createBufferInfoFromArrays(gl, {\r\n    a_vertex: {\r\n        data: [\r\n            // Triangle for 1,1 corner\r\n            1.0, 1.0,\r\n            0.0, 1.0,\r\n            1.0, 0.0,\r\n            // Triangle for 0,0 corner\r\n            0.0, 0.0,\r\n            1.0, 0.0,\r\n            0.0, 1.0,\r\n        ],\r\n        numComponents: 2,\r\n    },\r\n});\r\nconst sprite_vao = twgl.createVertexArrayInfo(gl, sprite_program_info, sprite_buffer_info);\r\n\r\n// data for sprite renderer\r\n// per tile:\r\n// - 4 vertices : vec8\r\n// - 2 uv vertices : vec4\r\n// ?? idk, depends on the specifics (do we want rotation? arbitrary rotation? arbitrary uvs? coords on pixels or tiles or screen?)\r\n\r\n// for now, let's do it perfectly, one thing at a time\r\n// and from there, get an imperfect but general system\r\n\r\n// min data for a tilemap:\r\n// global:\r\n// - screen resolution : vec2\r\n// - tilemap count : vec2\r\n// - tilemap top left : vec2\r\n// - tile size : float/vec2?/vec4 (if allowing an arbitrary base)\r\n//    (for now, float)\r\n// per tile:\r\n// - tile index : vec2\r\n// - position : vec2\r\n// draw an instanced [0,1] quad, or maybe directly use vertexId?\r\n// in any case, a_vertex is a [0,1] quad\r\n// computations:\r\n// - pos = u_origin + (a_vertex + a_position) * vec2(u_basis_x, u_basis_y)\r\n// - uv = (a_tilemap_index + a_vertex) / u_sprite_counts\r\n// tothink:\r\n//   what if there's a margin?\r\n//   no need for position if we assume a rectangular tilemap... but that's too much\r\n//   another option is to always use the same mesh, & only change tile indices\r\n//     todo: that seems cool, will do when this one is working\r\nconst tilemap_programinfo = twgl.createProgramInfo(gl, [\r\n    // vs\r\n    `#version 300 es\r\n\r\n    // [0, 1]^2 (in other words, a quad)\r\n    in vec2 a_vertex;\r\n\r\n    // per-sprite data\r\n    in vec2 a_position;\r\n    in vec2 a_tileindex;\r\n\r\n    // global data\r\n    // sprites drawn at 0,0 will end in this clipspace position\r\n    uniform vec2 u_origin;\r\n    // sprites drawn at 1,1 will end in u_origin plus this clipspace position\r\n    uniform vec2 u_basis;\r\n    // number of sprites in the spritesheet\r\n    uniform vec2 u_sheet_count;\r\n\r\n    out vec2 v_texcoord;\r\n\r\n    void main() {\r\n        gl_Position = vec4(u_origin + (a_vertex + a_position) * u_basis, 0.0, 1.0);\r\n        v_texcoord = (a_tileindex + a_vertex) / u_sheet_count;\r\n    }\r\n    `,\r\n    // fs\r\n    `#version 300 es\r\n    precision highp float;\r\n    \r\n    in vec2 v_texcoord;\r\n\r\n    uniform sampler2D u_sheet;\r\n\r\n    out vec4 out_color;\r\n\r\n    void main() {\r\n        out_color = texture(u_sheet, v_texcoord);\r\n    }\r\n    `\r\n]);\r\n\r\nconst tilemap_texture = twgl.createTexture(gl, {\r\n    src: (new URL('walls_312.png', import.meta.url)).toString(),\r\n    mag: gl.NEAREST,\r\n    wrap: gl.REPEAT,\r\n});\r\n\r\nconst level_src = `\r\n####!!\r\n#.O#!!\r\n#..###\r\n#@P..#\r\n#..*.#\r\n#..###\r\n####!!\r\n`.trim();\r\n\r\nconst level_rows = level_src.split('\\n').map(r => r.trim());\r\nconst level_height = level_rows.length;\r\nconst level_width = level_rows[0].length;\r\nconsole.assert(level_rows.every(r => r.length == level_width), \"Bad ascii level\");\r\nconst level_walls = level_rows.map(r => r.split('').map(c => c == '#')).flat()\r\n\r\nfunction getWallAt(i: number, j: number): boolean {\r\n    if (i < 0 || i >= level_width || j < 0 || j >= level_height) {\r\n        return false\r\n    }\r\n    return level_walls[i + j * level_width];\r\n}\r\n\r\nfunction getTileIndex(i: number, j: number): [number, number] {\r\n    // Same numbering as http://www.cr31.co.uk/stagecast/wang/2corn.html\r\n    let tr_corner = getWallAt(i - 0, j - 1) ? 1 : 0;\r\n    let br_corner = getWallAt(i - 0, j - 0) ? 2 : 0;\r\n    let bl_corner = getWallAt(i - 1, j - 0) ? 4 : 0;\r\n    let tl_corner = getWallAt(i - 1, j - 1) ? 8 : 0;\r\n    let lookup_index = tl_corner + tr_corner + bl_corner + br_corner;\r\n    const lookup_table: [number, number][] = [\r\n        [0, 3], [0, 2], [1, 3], [1, 0],\r\n        [0, 0], [2, 3], [3, 0], [1, 1],\r\n        [3, 3], [1, 2], [0, 1], [2, 2],\r\n        [3, 2], [3, 1], [2, 0], [2, 1],\r\n    ];\r\n    return lookup_table[lookup_index];\r\n}\r\n\r\nconst tilemap_tilesize = 64;\r\nconst tilemap_width = level_width + 1;\r\nconst tilemap_height = level_height + 1;\r\nconst tilemap_data_cpu = new Float32Array(4 * tilemap_width * tilemap_height);\r\nfor (let j = 0; j < tilemap_height; j++) {\r\n    for (let i = 0; i < tilemap_width; i++) {\r\n        let k = (i + j * tilemap_width) * 4;\r\n        // x,y position; no tilemap specific logic\r\n        tilemap_data_cpu[k + 0] = i;\r\n        tilemap_data_cpu[k + 1] = j;\r\n        // actual tile to use, depends on the actual map state\r\n        let cur_index = getTileIndex(i, j);\r\n        tilemap_data_cpu[k + 2] = cur_index[0];\r\n        tilemap_data_cpu[k + 3] = cur_index[1];\r\n    }\r\n}\r\n\r\nconst tilemap_buffer = gl.createBuffer()!;\r\ngl.bindBuffer(gl.ARRAY_BUFFER, tilemap_buffer);\r\ngl.bufferData(gl.ARRAY_BUFFER, tilemap_data_cpu, gl.STATIC_DRAW);\r\n\r\nlet tilemap_vaoinfo = twgl.createVertexArrayInfo(gl, tilemap_programinfo, twgl.createBufferInfoFromArrays(gl, {\r\n    a_position: {\r\n        buffer: tilemap_buffer,\r\n        type: gl.FLOAT,\r\n        numComponents: 2,\r\n        stride: 4 * 4,\r\n        offset: 0 * 4,\r\n        divisor: 1,\r\n    },\r\n    a_tileindex: {\r\n        buffer: tilemap_buffer,\r\n        type: gl.FLOAT,\r\n        numComponents: 2,\r\n        stride: 4 * 4,\r\n        offset: 2 * 4,\r\n        divisor: 1,\r\n    },\r\n    a_vertex: {\r\n        data: [\r\n            // Triangle for 1,1 corner\r\n            1.0, 1.0,\r\n            0.0, 1.0,\r\n            1.0, 0.0,\r\n            // Triangle for 0,0 corner\r\n            0.0, 0.0,\r\n            1.0, 0.0,\r\n            0.0, 1.0,\r\n        ],\r\n        numComponents: 2,\r\n    },\r\n}))\r\n\r\n// raw version, unfinished - missing a_vertex & divisors.\r\nif (false) {\r\n    var vao = gl.createVertexArray()!;\r\n    gl.bindVertexArray(vao);\r\n    {\r\n        // @ts-ignore\r\n        let a_position_loc = tilemap_programinfo.attribSetters[\"a_position\"].location;\r\n        gl.enableVertexAttribArray(a_position_loc);\r\n        var size = 2;          // 2 components per iteration\r\n        var type = gl.FLOAT;   // the data is 32bit floats\r\n        var normalize = false; // don't normalize the data\r\n        var stride = 4 * 4;    // stride in bytes\r\n        var offset = 0 * 4;    // offset in bytes\r\n        gl.vertexAttribPointer(\r\n            a_position_loc, size, type, normalize, stride, offset);\r\n    }\r\n    {\r\n        // @ts-ignore\r\n        let a_tileindex_loc = tilemap_programinfo.attribSetters[\"a_tileindex\"].location;\r\n        gl.enableVertexAttribArray(a_tileindex_loc);\r\n        var size = 2;          // 2 components per iteration\r\n        var type = gl.FLOAT;   // the data is 32bit floats\r\n        var normalize = false; // don't normalize the data\r\n        var stride = 4 * 4;    // stride in bytes\r\n        var offset = 2 * 4;    // offset in bytes\r\n        gl.vertexAttribPointer(\r\n            a_tileindex_loc, size, type, normalize, stride, offset);\r\n    }\r\n}\r\n\r\nconst floor_texture = twgl.createTexture(gl, {\r\n    src: (new URL('floor_312.png', import.meta.url)).toString(),\r\n    mag: gl.NEAREST,\r\n    wrap: gl.REPEAT,\r\n});\r\n\r\nlet level_floors = level_rows.map(r => r.split('').map(c => c != '#' && c != '!')).flat()\r\n\r\n// Floor approach: only first fill N tiles\r\n// use same shader, or another? for now, let's keep the same one\r\nconst floormap_data_cpu = new Float32Array(4 * level_width * level_height);\r\nlet n_floors = 0;\r\nfor (let j = 0; j < level_height; j++) {\r\n    for (let i = 0; i < level_width; i++) {\r\n        if (level_floors[i + j * level_width]) {\r\n            // x,y position\r\n            floormap_data_cpu[n_floors * 4 + 0] = i;\r\n            floormap_data_cpu[n_floors * 4 + 1] = j;\r\n            // actual tile to use is always 0,0\r\n            tilemap_data_cpu[n_floors * 4 + 2] = 0;\r\n            tilemap_data_cpu[n_floors * 4 + 3] = 0;\r\n\r\n            n_floors += 1;\r\n        }\r\n    }\r\n}\r\n\r\nconst floormap_buffer = gl.createBuffer()!;\r\ngl.bindBuffer(gl.ARRAY_BUFFER, floormap_buffer);\r\ngl.bufferData(gl.ARRAY_BUFFER, floormap_data_cpu, gl.STATIC_DRAW);\r\n\r\n\r\nlet floormap_vaoinfo = twgl.createVertexArrayInfo(gl, tilemap_programinfo, twgl.createBufferInfoFromArrays(gl, {\r\n    a_position: {\r\n        buffer: floormap_buffer,\r\n        type: gl.FLOAT,\r\n        numComponents: 2,\r\n        stride: 4 * 4,\r\n        offset: 0 * 4,\r\n        divisor: 1,\r\n    },\r\n    a_tileindex: {\r\n        buffer: floormap_buffer,\r\n        type: gl.FLOAT,\r\n        numComponents: 2,\r\n        stride: 4 * 4,\r\n        offset: 2 * 4,\r\n        divisor: 1,\r\n    },\r\n    a_vertex: {\r\n        data: [\r\n            // Triangle for 1,1 corner\r\n            1.0, 1.0,\r\n            0.0, 1.0,\r\n            1.0, 0.0,\r\n            // Triangle for 0,0 corner\r\n            0.0, 0.0,\r\n            1.0, 0.0,\r\n            0.0, 1.0,\r\n        ],\r\n        numComponents: 2,\r\n    },\r\n}))\r\n\r\n// Player & boxes sprite drawing\r\n// for now, let's keep the same shader\r\n// this batching only makes sense if all textures are in the same atlas\r\n// but texture packing is boooring & unflexible (unless we had a custom parcel plugin...)\r\n// maybe i'm overcomplicating stuff for no gain :/\r\n// nah, even with different textures, it's cool to have a single buffer, since we can draw subsets of it.\r\nconst max_n_sprites = 32;\r\nvar cur_n_sprites = 0;\r\nvar moving_sprites_cpu = new Float32Array(max_n_sprites * 4);\r\nconst moving_sprites_buffer = gl.createBuffer()!;\r\ngl.bindBuffer(gl.ARRAY_BUFFER, moving_sprites_buffer);\r\ngl.bufferData(gl.ARRAY_BUFFER, moving_sprites_cpu, gl.DYNAMIC_DRAW);\r\n\r\nlet moving_sprites_vaoinfo = twgl.createVertexArrayInfo(gl, tilemap_programinfo, twgl.createBufferInfoFromArrays(gl, {\r\n    a_position: {\r\n        buffer: moving_sprites_buffer,\r\n        type: gl.FLOAT,\r\n        numComponents: 2,\r\n        stride: 4 * 4,\r\n        offset: 0 * 4,\r\n        divisor: 1,\r\n    },\r\n    a_tileindex: {\r\n        buffer: moving_sprites_buffer,\r\n        type: gl.FLOAT,\r\n        numComponents: 2,\r\n        stride: 4 * 4,\r\n        offset: 2 * 4,\r\n        divisor: 1,\r\n    },\r\n    a_vertex: {\r\n        data: [\r\n            // Triangle for 1,1 corner\r\n            1.0, 1.0,\r\n            0.0, 1.0,\r\n            1.0, 0.0,\r\n            // Triangle for 0,0 corner\r\n            0.0, 0.0,\r\n            1.0, 0.0,\r\n            0.0, 1.0,\r\n        ],\r\n        numComponents: 2,\r\n    },\r\n}))\r\n\r\nconst player_texture = twgl.createTexture(gl, {\r\n    src: (new URL('player_puzzlescript.png', import.meta.url)).toString(),\r\n    mag: gl.NEAREST,\r\n    wrap: gl.REPEAT,\r\n});\r\n\r\nlet game_state = {\r\n    debug_x: 0,\r\n    debug_y: 0,\r\n    player_pos: new Vec2(2, 3),\r\n};\r\n\r\nlet visual_state = {\r\n    player_offset: new Vec2(0.0, 0.0),\r\n}\r\n\r\nlet move_duration = .05;\r\n\r\n// player sprite data\r\nlet player_sprite_index = cur_n_sprites;\r\ncur_n_sprites += 1;\r\nmoving_sprites_cpu[player_sprite_index * 4 + 0] = game_state.player_pos.x;\r\nmoving_sprites_cpu[player_sprite_index * 4 + 1] = game_state.player_pos.y;\r\nmoving_sprites_cpu[player_sprite_index * 4 + 2] = 0; // tile index\r\nmoving_sprites_cpu[player_sprite_index * 4 + 3] = 0;\r\n\r\n\r\nlet input_state: {\r\n    pressed: Record<string, boolean>,\r\n    queued: string[],\r\n} = {\r\n    pressed: {},\r\n    queued: [],\r\n};\r\n\r\n\r\nlet loop_id = requestAnimationFrame(update);\r\ndocument.addEventListener(\"keydown\", onKeyDown);\r\ndocument.addEventListener(\"keyup\", onKeyUp);\r\n\r\nfunction onKeyDown(ev: KeyboardEvent) {\r\n    console.log(\"keydown\");\r\n    input_state.pressed[ev.code] = true;\r\n    input_state.queued.push(ev.code);\r\n    /*switch (ev.code) {\r\n        case \"KeyD\":\r\n            input_state.d_down = true;\r\n            break;\r\n        case \"KeyA\":\r\n            input_state.a_down = true;\r\n            break;\r\n        case \"KeyW\":\r\n            input_state.w_down = true;\r\n            break;\r\n        case \"KeyS\":\r\n            input_state.s_down = true;\r\n            break;\r\n    }*/\r\n}\r\n\r\nfunction onKeyUp(ev: KeyboardEvent) {\r\n    console.log(\"keyup\");\r\n    input_state.pressed[ev.code] = false;\r\n    /*switch (ev.code) {\r\n        case \"KeyD\":\r\n            input_state.d_down = false;\r\n            break;\r\n        case \"KeyA\":\r\n            input_state.a_down = false;\r\n            break;\r\n        case \"KeyW\":\r\n            input_state.w_down = false;\r\n            break;\r\n        case \"KeyS\":\r\n            input_state.s_down = false;\r\n            break;\r\n    }*/\r\n}\r\n\r\n\r\nlet time_last = 0;\r\nfunction update(time_cur: number) {\r\n    let delta = (time_cur - time_last) * 0.001;\r\n    time_last = time_cur;\r\n\r\n    if (twgl.resizeCanvasToDisplaySize(gl.canvas as HTMLCanvasElement)) {\r\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n    }\r\n\r\n    if (input_state.pressed[\"KeyA\"]) {\r\n        game_state.debug_x -= 1;\r\n    }\r\n    if (input_state.pressed[\"KeyD\"]) {\r\n        game_state.debug_x += 1;\r\n    }\r\n    if (input_state.pressed[\"KeyW\"]) {\r\n        game_state.debug_y -= 1;\r\n    }\r\n    if (input_state.pressed[\"KeyS\"]) {\r\n        game_state.debug_y += 1;\r\n    }\r\n    // console.log(game_state.x, game_state.y);\r\n\r\n    // todo: undo\r\n    if (input_state.queued.length > 0 && Vec2.isZero(visual_state.player_offset)) {\r\n        let cur_input = input_state.queued.shift();\r\n        let player_delta = new Vec2()\r\n        switch (cur_input) {\r\n            case \"KeyD\":\r\n                player_delta.x = 1;\r\n                break;\r\n            case \"KeyA\":\r\n                player_delta.x = -1;\r\n                break;\r\n            case \"KeyW\":\r\n                player_delta.y = -1;\r\n                break;\r\n            case \"KeyS\":\r\n                player_delta.y = 1;\r\n                break;\r\n        }\r\n\r\n        if (player_delta.x != 0 || player_delta.y != 0) {\r\n            let new_player_pos = Vec2.add(game_state.player_pos, player_delta);\r\n            if (!getWallAt(new_player_pos.x, new_player_pos.y)) {\r\n                Vec2.copy(new_player_pos, game_state.player_pos);\r\n                Vec2.sub(visual_state.player_offset, player_delta, visual_state.player_offset);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!Vec2.isZero(visual_state.player_offset)) {\r\n        Vec2.map2(visual_state.player_offset, Vec2.zero, \r\n            (a, b) => towards(a, b, delta / move_duration), \r\n        visual_state.player_offset);\r\n        moving_sprites_cpu[player_sprite_index * 4 + 0] = game_state.player_pos.x + visual_state.player_offset.x;\r\n        moving_sprites_cpu[player_sprite_index * 4 + 1] = game_state.player_pos.y + visual_state.player_offset.y;\r\n    }\r\n\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n    // Debug temp stuff\r\n    gl.useProgram(sprite_program_info.program);\r\n    twgl.setBuffersAndAttributes(gl, sprite_program_info, sprite_vao);\r\n    twgl.setUniforms(sprite_program_info, {\r\n        u_texture: my_texture,\r\n        u_resolution: [gl.canvas.width, gl.canvas.height],\r\n        u_size: [50, 50],\r\n        u_position: [game_state.debug_x, game_state.debug_y],\r\n    });\r\n    twgl.drawBufferInfo(gl, sprite_buffer_info);\r\n\r\n    // walls\r\n    gl.useProgram(tilemap_programinfo.program);\r\n    gl.bindVertexArray(tilemap_vaoinfo.vertexArrayObject!);\r\n    twgl.setUniformsAndBindTextures(tilemap_programinfo, {\r\n        u_origin: [- tilemap_width * tilemap_tilesize / gl.canvas.width, tilemap_height * tilemap_tilesize / gl.canvas.height],\r\n        u_basis: [2 * tilemap_tilesize / gl.canvas.width, -2 * tilemap_tilesize / gl.canvas.height],\r\n        u_sheet_count: [4, 4],\r\n        u_sheet: tilemap_texture,\r\n    });\r\n    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, tilemap_width * tilemap_height);\r\n\r\n    // floors\r\n    gl.bindVertexArray(floormap_vaoinfo.vertexArrayObject!);\r\n    twgl.setUniformsAndBindTextures(tilemap_programinfo, {\r\n        u_origin: [- level_width * tilemap_tilesize / gl.canvas.width, level_height * tilemap_tilesize / gl.canvas.height],\r\n        u_basis: [2 * tilemap_tilesize / gl.canvas.width, -2 * tilemap_tilesize / gl.canvas.height],\r\n        u_sheet_count: [1, 1],\r\n        u_sheet: floor_texture,\r\n    });\r\n    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, n_floors);\r\n\r\n    // player\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, moving_sprites_buffer);\r\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, moving_sprites_cpu);\r\n    gl.bindVertexArray(moving_sprites_vaoinfo.vertexArrayObject!);\r\n    twgl.setUniformsAndBindTextures(tilemap_programinfo, {\r\n        u_origin: [- level_width * tilemap_tilesize / gl.canvas.width, level_height * tilemap_tilesize / gl.canvas.height],\r\n        u_basis: [2 * tilemap_tilesize / gl.canvas.width, -2 * tilemap_tilesize / gl.canvas.height],\r\n        u_sheet_count: [1, 1],\r\n        u_sheet: player_texture,\r\n    });\r\n    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, cur_n_sprites);\r\n\r\n\r\n    loop_id = requestAnimationFrame(update);\r\n}\r\n","export function fromCount<T>(n: number, callback: (index: number) => T): T[] {\r\n    let result = Array(n);\r\n    for (let k = 0; k < n; k++) {\r\n        result[k] = callback(k);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function fromRange<T>(lo: number, hi: number, callback: (index: number) => T): T[] {\r\n    let count = hi - lo;\r\n    let result = Array(count);\r\n    for (let k = 0; k < count; k++) {\r\n        result[k] = callback(k + lo);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function towards(cur: number, target: number, max_delta: number): number {\r\n    if (cur > target) {\r\n        return Math.max(cur - max_delta, target);\r\n    } else if (cur < target) {\r\n        return Math.min(cur + max_delta, target);\r\n    } else {\r\n        return target;\r\n    }\r\n}\r\n","#version 300 es\r\n\r\n// [0, 1]^2\r\nin vec2 a_vertex;\r\n\r\n// pixels for everything\r\nuniform vec2 u_resolution;\r\nuniform vec2 u_position;\r\nuniform vec2 u_size;\r\n\r\nout vec2 v_texcoord;\r\n\r\nvoid main() {\r\n    // if size is 100 & screen is 400, then\r\n    // clip space result width will be .5\r\n    vec2 pos = 2.0 * a_vertex * u_size / u_resolution;\r\n\r\n    // if position is 200 & screen is 400, then\r\n    // clip space result offset will be .5\r\n    pos += 2.0 * u_position / u_resolution;\r\n\r\n    // pos of 0 should go to the top left\r\n    pos -= vec2(1, 1);\r\n\r\n    // ypos = down\r\n    pos.y = -pos.y;\r\n\r\n    gl_Position = vec4(pos, 0, 1);\r\n\r\n    v_texcoord = a_vertex;\r\n}\r\n\r\n// todo: investigate glslify","#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 v_texcoord;\r\n\r\nuniform sampler2D u_texture;\r\n\r\nout vec4 out_color;\r\n\r\nvoid main() {\r\n    out_color = texture(u_texture, v_texcoord);\r\n}","// Use objects instead of arrays: https://jsben.ch/FgKVi\r\n\r\nexport class Vec2 {\r\n    constructor(\r\n        public x: number = 0.0,\r\n        public y: number = 0.0,\r\n    ) {}\r\n\r\n    static zero = new Vec2(0, 0);\r\n\r\n    static copy(v: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = v.x;\r\n        out.y = v.y;\r\n        return out;\r\n    }\r\n      \r\n\r\n    static add(a: Vec2, b: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = a.x + b.x;\r\n        out.y = a.y + b.y;\r\n        return out;\r\n    }\r\n\r\n    static sub(a: Vec2, b: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = a.x - b.x;\r\n        out.y = a.y - b.y;\r\n        return out;\r\n    }\r\n\r\n    static negate(v: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = -v.x;\r\n        out.y = -v.y;\r\n        return out;\r\n    }\r\n\r\n    static isZero(v: Vec2): boolean {\r\n        return v.x == 0 && v.y == 0;\r\n    }\r\n\r\n    static map2(a: Vec2, b: Vec2, fn: (a: number, b: number) => number,  out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = fn(a.x, b.x);\r\n        out.y = fn(a.y, b.y);\r\n        return out;\r\n    }\r\n}\r\n","module.exports = new __parcel__URL__(\"../\" + require('./helpers/bundle-manifest').resolve(\"lRZia\")).toString();","module.exports = new __parcel__URL__(\"../\" + require('./helpers/bundle-manifest').resolve(\"3UC5c\")).toString();","module.exports = new __parcel__URL__(\"../\" + require('./helpers/bundle-manifest').resolve(\"6pQwl\")).toString();","module.exports = new __parcel__URL__(\"../\" + require('./helpers/bundle-manifest').resolve(\"6cxlj\")).toString();"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$ef7689007096c8a0$export$6503ec6e8aabbaf","$ef7689007096c8a0$export$f7ad0328861e2f03","$ef7689007096c8a0$var$mapping","pairs","keys","i","length","resolved","JSON","parse","$amYBK","$25fe13573bce6064$exports","$2ac028d4d6421c3a$exports","$5c4293b9a464b6e0$export$ac4bca90992eed1","constructor","x","y","_","zero","copy","out","add","b","sub","negate","isZero","map2","fn","$093282bf79b6fc15$var$gl","document","querySelector","getContext","alpha","clearColor","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","resizeCanvasToDisplaySize","canvas","viewport","drawingBufferWidth","drawingBufferHeight","$22fc558e6fe70830$exports","URL","resolve","url","toString","$093282bf79b6fc15$var$my_texture","createTexture","src","$093282bf79b6fc15$var$sprite_program_info","createProgramInfo","$093282bf79b6fc15$var$sprite_buffer_info","createBufferInfoFromArrays","a_vertex","data","numComponents","$093282bf79b6fc15$var$sprite_vao","createVertexArrayInfo","$093282bf79b6fc15$var$tilemap_programinfo","$e5c42df7f77c5287$exports","$093282bf79b6fc15$var$tilemap_texture","mag","NEAREST","wrap","REPEAT","$093282bf79b6fc15$var$level_src","trim","$093282bf79b6fc15$var$level_rows","split","map","r","$093282bf79b6fc15$var$level_height","$093282bf79b6fc15$var$level_width","console","assert","every","$093282bf79b6fc15$var$level_walls","c","flat","$093282bf79b6fc15$var$getWallAt","j","$093282bf79b6fc15$var$tilemap_width","$093282bf79b6fc15$var$tilemap_height","$093282bf79b6fc15$var$tilemap_data_cpu","Float32Array","k","cur_index","$093282bf79b6fc15$var$getTileIndex","tr_corner","br_corner","bl_corner","lookup_table","tl_corner","$093282bf79b6fc15$var$tilemap_buffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","$093282bf79b6fc15$var$tilemap_vaoinfo","a_position","buffer","type","FLOAT","stride","offset","divisor","a_tileindex","$cda84142577741c0$exports","$093282bf79b6fc15$var$floor_texture","$093282bf79b6fc15$var$level_floors","$093282bf79b6fc15$var$floormap_data_cpu","$093282bf79b6fc15$var$n_floors","$093282bf79b6fc15$var$floormap_buffer","$093282bf79b6fc15$var$floormap_vaoinfo","$093282bf79b6fc15$var$cur_n_sprites","$093282bf79b6fc15$var$moving_sprites_cpu","$093282bf79b6fc15$var$max_n_sprites","$093282bf79b6fc15$var$moving_sprites_buffer","DYNAMIC_DRAW","$093282bf79b6fc15$var$moving_sprites_vaoinfo","$db26ee343f5bac19$exports","$093282bf79b6fc15$var$player_texture","$093282bf79b6fc15$var$game_state","debug_x","debug_y","player_pos","$093282bf79b6fc15$var$visual_state","player_offset","$093282bf79b6fc15$var$player_sprite_index","$093282bf79b6fc15$var$input_state","pressed","queued","requestAnimationFrame","$093282bf79b6fc15$var$update","time_cur","delta","$093282bf79b6fc15$var$time_last","cur_input","shift","player_delta","new_player_pos","max_delta","cur","Math","max","min","clear","COLOR_BUFFER_BIT","useProgram","program","setBuffersAndAttributes","setUniforms","u_texture","u_resolution","width","height","u_size","u_position","drawBufferInfo","bindVertexArray","vertexArrayObject","setUniformsAndBindTextures","u_origin","u_basis","u_sheet_count","u_sheet","drawArraysInstanced","TRIANGLES","bufferSubData","addEventListener","ev","log","push"],"version":3,"file":"index.14469d99.js.map"}