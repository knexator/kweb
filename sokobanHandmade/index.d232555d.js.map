{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,e,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,S,E,C,E,O,G,E,W,E,Q,C,C,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,Q,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,K,E,Q,E,E,S,E,O,C,I,E,A,M,uB,E,I,O,E,K,mB,C,C,E,S,S,C,C,C,E,C,C,E,C,C,E,E,kB,G,E,S,Q,S,C,C,C,ECAA,a,E,E,Q,W,W,O,C,E,S,C,E,O,E,C,G,E,E,Q,U,W,O,C,E,S,C,E,O,E,C,GAEA,IAcA,EACA,EAfI,EAAU,CAAC,EAcf,EAbA,SAAkB,CAAK,EAErB,IAAK,IADD,EAAO,OAAO,KAAK,GACd,EAAI,EAAG,EAAI,EAAK,OAAQ,IAC/B,CAAO,CAAC,CAAI,CAAC,EAAE,CAAC,CAAG,CAAK,CAAC,CAAI,CAAC,EAAE,CAAC,AAErC,EASA,EARA,SAAiB,CAAE,EACjB,IAAI,EAAW,CAAO,CAAC,EAAG,CAC1B,GAAI,AAAY,MAAZ,EACF,MAAM,AAAI,MAAM,oCAAsC,GAExD,OAAO,CACT,C,GCfA,AAAA,EAAA,SAAA,SAA8C,KAAK,MAAM,0W,I,E,E,SE6DlD,SAAS,EAAM,CAAa,CAAE,CAAqB,CAAE,CAAqB,EAC7E,OAAO,KAAK,IAAI,EAAe,KAAK,IAAI,EAAe,GAC3D,CA2BO,MAAM,EACT,YACW,EAAY,CAAG,CACf,EAAY,CAAG,CACf,EAAY,CAAG,CACf,EAAY,CAAG,CACxB,CAJS,IAAA,CAAA,EAAA,EACA,IAAA,CAAA,EAAA,EACA,IAAA,CAAA,EAAA,EACA,IAAA,CAAA,EAAA,CACP,CAEJ,OAAO,QAAQ,CAAe,CAAQ,CAElC,IAAI,EAAS,4CAA4C,KAAK,GAC9D,GAAI,AAAW,OAAX,EACA,MAAM,AAAI,MAAM,CAAC,iBAAiB,EAAE,EAAQ,CAAC,EAEjD,OAAO,IAAI,EACP,SAAS,CAAM,CAAC,EAAE,CAAE,IACpB,SAAS,CAAM,CAAC,E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","sources":["<anon>","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-64047aa670deb529.js","sokobanHandmade/main.ts","kommon/math.ts","drawSprite/shaders/sprite.vert","drawSprite/shaders/sprite.frag","node_modules/@parcel/runtime-js/lib/runtime-a53ce9dee81f2f4a.js","node_modules/@parcel/runtime-js/lib/runtime-a71307ab7681ef63.js","node_modules/@parcel/runtime-js/lib/runtime-e051068a46b33588.js","node_modules/@parcel/runtime-js/lib/runtime-4766bd7635036f91.js","node_modules/@parcel/runtime-js/lib/runtime-9732d8c7082eeeeb.js"],"sourcesContent":["function $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire94c2\"] = parcelRequire;\n}\nparcelRequire.register(\"kyEFX\", function(module, exports) {\n\n$parcel$export(module.exports, \"register\", function () { return $ef7689007096c8a0$export$6503ec6e8aabbaf; }, function (v) { return $ef7689007096c8a0$export$6503ec6e8aabbaf = v; });\n$parcel$export(module.exports, \"resolve\", function () { return $ef7689007096c8a0$export$f7ad0328861e2f03; }, function (v) { return $ef7689007096c8a0$export$f7ad0328861e2f03 = v; });\nvar $ef7689007096c8a0$export$6503ec6e8aabbaf;\nvar $ef7689007096c8a0$export$f7ad0328861e2f03;\n\"use strict\";\nvar $ef7689007096c8a0$var$mapping = {};\nfunction $ef7689007096c8a0$var$register(pairs) {\n    var keys = Object.keys(pairs);\n    for(var i = 0; i < keys.length; i++)$ef7689007096c8a0$var$mapping[keys[i]] = pairs[keys[i]];\n}\nfunction $ef7689007096c8a0$var$resolve(id) {\n    var resolved = $ef7689007096c8a0$var$mapping[id];\n    if (resolved == null) throw new Error(\"Could not resolve bundle with id \" + id);\n    return resolved;\n}\n$ef7689007096c8a0$export$6503ec6e8aabbaf = $ef7689007096c8a0$var$register;\n$ef7689007096c8a0$export$f7ad0328861e2f03 = $ef7689007096c8a0$var$resolve;\n\n});\n\nvar $9ec3e57ee6d75ff9$exports = {};\n\n(parcelRequire(\"kyEFX\")).register(JSON.parse('{\"gi6r7\":\"index.d232555d.js\",\"5TaR7\":\"sprite.22ec2077.png\",\"6PWe3\":\"walls_312.cb79a6c7.png\",\"5Oroq\":\"floor_312.8cddc3eb.png\",\"gQMdV\":\"player_puzzlescript.5728a87e.png\",\"8p6MJ\":\"crate_puzzlescript.92620967.png\",\"bB1AD\":\"index.9c3702eb.js\"}'));\n\n\nvar $amYBK = parcelRequire(\"amYBK\");\nfunction $5c4293b9a464b6e0$export$3c5f89dae98e900b(low_inclusive, high_exclusive) {\n    return low_inclusive + Math.floor(Math.random() * (high_exclusive - low_inclusive));\n}\nfunction $5c4293b9a464b6e0$export$8960430cfd85939f(arr) {\n    if (arr.length === 0) return undefined;\n    return arr[$5c4293b9a464b6e0$export$3249d46f03066cfe(arr)];\n}\nfunction $5c4293b9a464b6e0$export$3249d46f03066cfe(arr) {\n    if (arr.length === 0) return undefined;\n    let res = 0;\n    let biggest = arr[0];\n    for(let k = 1; k < arr.length; k++)if (arr[k] > biggest) {\n        biggest = arr[k];\n        res = k;\n    }\n    return res;\n}\nfunction $5c4293b9a464b6e0$export$3a89f8d6f6bf6c9f(a, b, t) {\n    return a * (1 - t) + b * t;\n}\nfunction $5c4293b9a464b6e0$export$dff840edf10f285e(cur, target, max_delta) {\n    if (cur > target) return Math.max(cur - max_delta, target);\n    else if (cur < target) return Math.min(cur + max_delta, target);\n    else return target;\n}\nfunction $5c4293b9a464b6e0$export$842a2cf37af977e1(n, m) {\n    return (n % m + m) % m;\n}\nfunction $5c4293b9a464b6e0$export$aee1dbae5de2db9d(value, old_a, old_b, new_a, new_b) {\n    let t = (value - old_a) / (old_b - old_a);\n    return t * (new_b - new_a) + new_a;\n}\nfunction $5c4293b9a464b6e0$export$94951fac5549ef77(arr) {\n    if (arr.length === 0) throw new Error(\"can't choose out of an empty array\");\n    return arr[Math.floor(Math.random() * arr.length)];\n}\nfunction $5c4293b9a464b6e0$export$4053e36566dd3d9a(toZero, toOne, value) {\n    let x = Math.max(0, Math.min(1, (value - toZero) / (toOne - toZero)));\n    return x * x * (3 - 2 * x);\n}\nfunction $5c4293b9a464b6e0$export$7d15b64cf5a3a4c4(value, min_inclusive, max_inclusive) {\n    return Math.max(min_inclusive, Math.min(max_inclusive, value));\n}\nfunction $5c4293b9a464b6e0$export$ddf89a9c5af38f94(value, min_inclusive, max_exclusive) {\n    return value >= min_inclusive && value < max_exclusive;\n}\nfunction $5c4293b9a464b6e0$export$66124ef7f3a58cb4(value, min_inclusive, max_exclusive) {\n    return value == min_inclusive || value + 1 === max_exclusive;\n}\nfunction $5c4293b9a464b6e0$export$448332262467e042(array) {\n    let currentIndex = array.length, randomIndex;\n    // While there remain elements to shuffle.\n    while(currentIndex != 0){\n        // Pick a remaining element.\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex--;\n        // And swap it with the current element.\n        [array[currentIndex], array[randomIndex]] = [\n            array[randomIndex],\n            array[currentIndex]\n        ];\n    }\n    return array;\n}\nclass $5c4293b9a464b6e0$export$b973696b5f65b53b {\n    constructor(x = 0.0, y = 0.0, z = 0.0, w = 0.0){\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n    static fromHex(hex_str) {\n        // from https://stackoverflow.com/a/5624139\n        var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex_str);\n        if (result === null) throw new Error(`can't parse hex: ${hex_str}`);\n        return new $5c4293b9a464b6e0$export$b973696b5f65b53b(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), 255);\n    }\n    static #_ = (()=>{\n        this.zero = new $5c4293b9a464b6e0$export$b973696b5f65b53b(0, 0, 0, 0);\n    })();\n    static #_1 = (()=>{\n        this.one = new $5c4293b9a464b6e0$export$b973696b5f65b53b(1, 1, 1, 1);\n    })();\n}\nclass $5c4293b9a464b6e0$export$ac4bca90992eed1 {\n    constructor(x = 0.0, y = 0.0){\n        this.x = x;\n        this.y = y;\n    }\n    toString() {\n        return `Vec2(${this.x}, ${this.y})`;\n    }\n    static #_ = (()=>{\n        // scratchpad vectors, meant to be reused as intermediate values without allocation\n        this.tmp = new $5c4293b9a464b6e0$export$ac4bca90992eed1(0, 0);\n    })();\n    static #_1 = (()=>{\n        this.tmp1 = new $5c4293b9a464b6e0$export$ac4bca90992eed1(0, 0);\n    })();\n    static #_2 = (()=>{\n        this.tmp2 = new $5c4293b9a464b6e0$export$ac4bca90992eed1(0, 0);\n    })();\n    static #_3 = (()=>{\n        this.tmp3 = new $5c4293b9a464b6e0$export$ac4bca90992eed1(0, 0);\n    })();\n    static #_4 = (()=>{\n        this.zero = new $5c4293b9a464b6e0$export$ac4bca90992eed1(0, 0);\n    })();\n    static #_5 = (()=>{\n        this.one = new $5c4293b9a464b6e0$export$ac4bca90992eed1(1, 1);\n    })();\n    static set(v, x, y) {\n        v.x = x;\n        v.y = y;\n        return v;\n    }\n    static copy(v, out) {\n        out = out || new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        out.x = v.x;\n        out.y = v.y;\n        return out;\n    }\n    static add(a, b, out) {\n        out = out || new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        out.x = a.x + b.x;\n        out.y = a.y + b.y;\n        return out;\n    }\n    static sub(a, b, out) {\n        out = out || new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        out.x = a.x - b.x;\n        out.y = a.y - b.y;\n        return out;\n    }\n    static mul(a, b, out) {\n        out = out || new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        out.x = a.x * b.x;\n        out.y = a.y * b.y;\n        return out;\n    }\n    static div(a, b, out) {\n        out = out || new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        out.x = a.x / b.x;\n        out.y = a.y / b.y;\n        return out;\n    }\n    static round(v, out) {\n        out = out || new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        out.x = Math.round(v.x);\n        out.y = Math.round(v.y);\n        return out;\n    }\n    static negate(v, out) {\n        out = out || new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        out.x = -v.x;\n        out.y = -v.y;\n        return out;\n    }\n    static scale(v, s, out) {\n        out = out || new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        out.x = v.x * s;\n        out.y = v.y * s;\n        return out;\n    }\n    static lerp(a, b, t, out) {\n        out = out || new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        out.x = a.x * (1 - t) + b.x * t;\n        out.y = a.y * (1 - t) + b.y * t;\n        return out;\n    }\n    static inBounds(point, bounds) {\n        return $5c4293b9a464b6e0$export$ddf89a9c5af38f94(point.x, 0, bounds.x) && $5c4293b9a464b6e0$export$ddf89a9c5af38f94(point.y, 0, bounds.y);\n    }\n    // too niche for here?\n    static onBorder(point, bounds) {\n        return $5c4293b9a464b6e0$export$66124ef7f3a58cb4(point.x, 0, bounds.x) || $5c4293b9a464b6e0$export$66124ef7f3a58cb4(point.y, 0, bounds.y);\n    }\n    static isZero(v) {\n        return v.x === 0 && v.y === 0;\n    }\n    static equals(a, b) {\n        return a.x === b.x && a.y === b.y;\n    }\n    static map1(v, fn, out) {\n        out = out || new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        out.x = fn(v.x);\n        out.y = fn(v.y);\n        return out;\n    }\n    static map2(a, b, fn, out) {\n        out = out || new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        out.x = fn(a.x, b.x);\n        out.y = fn(a.y, b.y);\n        return out;\n    }\n    static roundToCardinal(a) {\n        if (Math.abs(a.x) >= Math.abs(a.y)) {\n            if (a.x >= 0) return \"xpos\";\n            else return \"xneg\";\n        } else {\n            if (a.y >= 0) return \"ypos\";\n            else return \"yneg\";\n        }\n    }\n}\nclass $5c4293b9a464b6e0$export$4617fb02663045ef {\n    constructor(topLeft, size){\n        this.topLeft = topLeft;\n        this.size = size;\n    }\n    static fromParams(params) {\n        let topLeft = new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        let size = new $5c4293b9a464b6e0$export$ac4bca90992eed1();\n        if (params.topLeft !== undefined) {\n            $5c4293b9a464b6e0$export$ac4bca90992eed1.copy(params.topLeft, topLeft);\n            if (params.size !== undefined) $5c4293b9a464b6e0$export$ac4bca90992eed1.copy(params.size, size);\n            else if (params.bottomRight !== undefined) $5c4293b9a464b6e0$export$ac4bca90992eed1.sub(params.bottomRight, topLeft, size);\n            else if (params.center !== undefined) {\n                $5c4293b9a464b6e0$export$ac4bca90992eed1.sub(params.center, topLeft, size);\n                $5c4293b9a464b6e0$export$ac4bca90992eed1.scale(size, 2, size);\n            } else throw new Error(\"not enough data to compute rect\");\n            return new $5c4293b9a464b6e0$export$4617fb02663045ef(topLeft, size);\n        } else if (params.center !== undefined) {\n            if (params.size !== undefined) $5c4293b9a464b6e0$export$ac4bca90992eed1.copy(params.size, size);\n            else if (params.bottomRight !== undefined) {\n                $5c4293b9a464b6e0$export$ac4bca90992eed1.sub(params.bottomRight, params.center, size);\n                $5c4293b9a464b6e0$export$ac4bca90992eed1.scale(size, 2, size);\n            } else throw new Error(\"not enough data to compute rect\");\n            $5c4293b9a464b6e0$export$ac4bca90992eed1.sub(params.center, $5c4293b9a464b6e0$export$ac4bca90992eed1.scale(size, .5), topLeft);\n            return new $5c4293b9a464b6e0$export$4617fb02663045ef(topLeft, size);\n        } else throw new Error(\"unimplemented\");\n    }\n}\n\n\nvar $25fe13573bce6064$exports = {};\n$25fe13573bce6064$exports = \"#version 300 es\\n#define GLSLIFY 1\\n\\n// [0, 1]^2\\nin vec2 a_vertex;\\n\\n// pixels for everything\\nuniform vec2 u_resolution;\\nuniform vec2 u_position;\\nuniform vec2 u_size;\\n\\nout vec2 v_texcoord;\\n\\nvoid main() {\\n    // if size is 100 & screen is 400, then\\n    // clip space result width will be .5\\n    vec2 pos = 2.0 * a_vertex * u_size / u_resolution;\\n\\n    // if position is 200 & screen is 400, then\\n    // clip space result offset will be .5\\n    pos += 2.0 * u_position / u_resolution;\\n\\n    // pos of 0 should go to the top left\\n    pos -= vec2(1, 1);\\n\\n    // ypos = down\\n    pos.y = -pos.y;\\n\\n    gl_Position = vec4(pos, 0, 1);\\n\\n    v_texcoord = a_vertex;\\n}\\n\\n// todo: investigate glslify\";\n\n\nvar $2ac028d4d6421c3a$exports = {};\n$2ac028d4d6421c3a$exports = \"#version 300 es\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nin vec2 v_texcoord;\\n\\nuniform sampler2D u_texture;\\n\\nout vec4 out_color;\\n\\nvoid main() {\\n    out_color = texture(u_texture, v_texcoord);\\n}\";\n\n\n// Sokoban, in \"groud truth programming\" / \"C style\":\n// delay abstraction, consider each byte, don't reuse if it's not a perfect fit\n// This \"if\" will only execute during development\nif (null) {\n    null.dispose((data)=>{\n        data.game_state = $80cc681c87a590bc$var$game_state;\n        cancelAnimationFrame($80cc681c87a590bc$var$loop_id);\n        document.removeEventListener(\"keydown\", $80cc681c87a590bc$var$onKeyDown);\n        document.removeEventListener(\"keyup\", $80cc681c87a590bc$var$onKeyUp);\n    });\n    null.accept((_)=>{\n        $80cc681c87a590bc$var$game_state = null.data.game_state;\n    });\n}\nconst $80cc681c87a590bc$var$gl = document.querySelector(\"#c\").getContext(\"webgl2\", {\n    alpha: false\n});\n$80cc681c87a590bc$var$gl.clearColor(0.5, 0.5, 0.75, 1.0);\n$80cc681c87a590bc$var$gl.enable($80cc681c87a590bc$var$gl.BLEND);\n$80cc681c87a590bc$var$gl.blendFunc($80cc681c87a590bc$var$gl.SRC_ALPHA, $80cc681c87a590bc$var$gl.ONE_MINUS_SRC_ALPHA);\n$amYBK.resizeCanvasToDisplaySize($80cc681c87a590bc$var$gl.canvas);\n$80cc681c87a590bc$var$gl.viewport(0, 0, $80cc681c87a590bc$var$gl.drawingBufferWidth, $80cc681c87a590bc$var$gl.drawingBufferHeight);\nvar $d74783ac8623d055$exports = {};\n\n$d74783ac8623d055$exports = new URL(\"../\" + (parcelRequire(\"kyEFX\")).resolve(\"5TaR7\"), import.meta.url).toString();\n\n\nconst $80cc681c87a590bc$var$my_texture = $amYBK.createTexture($80cc681c87a590bc$var$gl, {\n    src: new URL($d74783ac8623d055$exports).toString()\n});\nconst $80cc681c87a590bc$var$sprite_program_info = $amYBK.createProgramInfo($80cc681c87a590bc$var$gl, [\n    (0, (/*@__PURE__*/$parcel$interopDefault($25fe13573bce6064$exports))),\n    (0, (/*@__PURE__*/$parcel$interopDefault($2ac028d4d6421c3a$exports)))\n]);\nconst $80cc681c87a590bc$var$sprite_buffer_info = $amYBK.createBufferInfoFromArrays($80cc681c87a590bc$var$gl, {\n    a_vertex: {\n        data: [\n            // Triangle for 1,1 corner\n            1.0,\n            1.0,\n            0.0,\n            1.0,\n            1.0,\n            0.0,\n            // Triangle for 0,0 corner\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            1.0\n        ],\n        numComponents: 2\n    }\n});\nconst $80cc681c87a590bc$var$sprite_vao = $amYBK.createVertexArrayInfo($80cc681c87a590bc$var$gl, $80cc681c87a590bc$var$sprite_program_info, $80cc681c87a590bc$var$sprite_buffer_info);\n// data for sprite renderer\n// per tile:\n// - 4 vertices : vec8\n// - 2 uv vertices : vec4\n// ?? idk, depends on the specifics (do we want rotation? arbitrary rotation? arbitrary uvs? coords on pixels or tiles or screen?)\n// for now, let's do it perfectly, one thing at a time\n// and from there, get an imperfect but general system\n// min data for a tilemap:\n// global:\n// - screen resolution : vec2\n// - tilemap count : vec2\n// - tilemap top left : vec2\n// - tile size : float/vec2?/vec4 (if allowing an arbitrary base)\n//    (for now, float)\n// per tile:\n// - tile index : vec2\n// - position : vec2\n// draw an instanced [0,1] quad, or maybe directly use vertexId?\n// in any case, a_vertex is a [0,1] quad\n// computations:\n// - pos = u_origin + (a_vertex + a_position) * vec2(u_basis_x, u_basis_y)\n// - uv = (a_tilemap_index + a_vertex) / u_sprite_counts\n// tothink:\n//   what if there's a margin?\n//   no need for position if we assume a rectangular tilemap... but that's too much\n//   another option is to always use the same mesh, & only change tile indices\n//     todo: that seems cool, will do when this one is working\nconst $80cc681c87a590bc$var$tilemap_programinfo = $amYBK.createProgramInfo($80cc681c87a590bc$var$gl, [\n    // vs\n    `#version 300 es\r\n\r\n    // [0, 1]^2 (in other words, a quad)\r\n    in vec2 a_vertex;\r\n\r\n    // per-sprite data\r\n    in vec2 a_position;\r\n    in vec2 a_tileindex;\r\n\r\n    // global data\r\n    // sprites drawn at 0,0 will end in this clipspace position\r\n    uniform vec2 u_origin;\r\n    // sprites drawn at 1,1 will end in u_origin plus this clipspace position\r\n    uniform vec2 u_basis;\r\n    // number of sprites in the spritesheet\r\n    uniform vec2 u_sheet_count;\r\n\r\n    out vec2 v_texcoord;\r\n\r\n    void main() {\r\n        gl_Position = vec4(u_origin + (a_vertex + a_position) * u_basis, 0.0, 1.0);\r\n        v_texcoord = (a_tileindex + a_vertex) / u_sheet_count;\r\n    }\r\n    `,\n    // fs\n    `#version 300 es\r\n    precision highp float;\r\n    \r\n    in vec2 v_texcoord;\r\n\r\n    uniform sampler2D u_sheet;\r\n\r\n    out vec4 out_color;\r\n\r\n    void main() {\r\n        out_color = texture(u_sheet, v_texcoord);\r\n    }\r\n    `\n]);\nvar $d14cc02d99730bca$exports = {};\n\n$d14cc02d99730bca$exports = new URL(\"../\" + (parcelRequire(\"kyEFX\")).resolve(\"6PWe3\"), import.meta.url).toString();\n\n\nconst $80cc681c87a590bc$var$tilemap_texture = $amYBK.createTexture($80cc681c87a590bc$var$gl, {\n    src: new URL($d14cc02d99730bca$exports).toString(),\n    mag: $80cc681c87a590bc$var$gl.NEAREST,\n    wrap: $80cc681c87a590bc$var$gl.REPEAT\n});\nconst $80cc681c87a590bc$var$level_src = `\r\n####!!\r\n#.O#!!\r\n#..###\r\n#@P..#\r\n#..*.#\r\n#..###\r\n####!!\r\n`.trim();\nconst $80cc681c87a590bc$var$level_rows = $80cc681c87a590bc$var$level_src.split(\"\\n\").map((r)=>r.trim());\nconst $80cc681c87a590bc$var$level_height = $80cc681c87a590bc$var$level_rows.length;\nconst $80cc681c87a590bc$var$level_width = $80cc681c87a590bc$var$level_rows[0].length;\nconsole.assert($80cc681c87a590bc$var$level_rows.every((r)=>r.length == $80cc681c87a590bc$var$level_width), \"Bad ascii level\");\nconst $80cc681c87a590bc$var$level_walls = $80cc681c87a590bc$var$level_rows.map((r)=>r.split(\"\").map((c)=>c == \"#\")).flat();\nfunction $80cc681c87a590bc$var$getWallAt(i, j) {\n    if (i < 0 || i >= $80cc681c87a590bc$var$level_width || j < 0 || j >= $80cc681c87a590bc$var$level_height) return false;\n    return $80cc681c87a590bc$var$level_walls[i + j * $80cc681c87a590bc$var$level_width];\n}\nfunction $80cc681c87a590bc$var$getTileIndex(i, j) {\n    // Same numbering as http://www.cr31.co.uk/stagecast/wang/2corn.html\n    let tr_corner = $80cc681c87a590bc$var$getWallAt(i - 0, j - 1) ? 1 : 0;\n    let br_corner = $80cc681c87a590bc$var$getWallAt(i - 0, j - 0) ? 2 : 0;\n    let bl_corner = $80cc681c87a590bc$var$getWallAt(i - 1, j - 0) ? 4 : 0;\n    let tl_corner = $80cc681c87a590bc$var$getWallAt(i - 1, j - 1) ? 8 : 0;\n    let lookup_index = tl_corner + tr_corner + bl_corner + br_corner;\n    const lookup_table = [\n        [\n            0,\n            3\n        ],\n        [\n            0,\n            2\n        ],\n        [\n            1,\n            3\n        ],\n        [\n            1,\n            0\n        ],\n        [\n            0,\n            0\n        ],\n        [\n            2,\n            3\n        ],\n        [\n            3,\n            0\n        ],\n        [\n            1,\n            1\n        ],\n        [\n            3,\n            3\n        ],\n        [\n            1,\n            2\n        ],\n        [\n            0,\n            1\n        ],\n        [\n            2,\n            2\n        ],\n        [\n            3,\n            2\n        ],\n        [\n            3,\n            1\n        ],\n        [\n            2,\n            0\n        ],\n        [\n            2,\n            1\n        ]\n    ];\n    return lookup_table[lookup_index];\n}\nconst $80cc681c87a590bc$var$tilemap_tilesize = 64;\nconst $80cc681c87a590bc$var$tilemap_width = $80cc681c87a590bc$var$level_width + 1;\nconst $80cc681c87a590bc$var$tilemap_height = $80cc681c87a590bc$var$level_height + 1;\nconst $80cc681c87a590bc$var$tilemap_data_cpu = new Float32Array(4 * $80cc681c87a590bc$var$tilemap_width * $80cc681c87a590bc$var$tilemap_height);\nfor(let j = 0; j < $80cc681c87a590bc$var$tilemap_height; j++)for(let i = 0; i < $80cc681c87a590bc$var$tilemap_width; i++){\n    let k = (i + j * $80cc681c87a590bc$var$tilemap_width) * 4;\n    // x,y position; no tilemap specific logic\n    $80cc681c87a590bc$var$tilemap_data_cpu[k + 0] = i;\n    $80cc681c87a590bc$var$tilemap_data_cpu[k + 1] = j;\n    // actual tile to use, depends on the actual map state\n    let cur_index = $80cc681c87a590bc$var$getTileIndex(i, j);\n    $80cc681c87a590bc$var$tilemap_data_cpu[k + 2] = cur_index[0];\n    $80cc681c87a590bc$var$tilemap_data_cpu[k + 3] = cur_index[1];\n}\nconst $80cc681c87a590bc$var$tilemap_buffer = $80cc681c87a590bc$var$gl.createBuffer();\n$80cc681c87a590bc$var$gl.bindBuffer($80cc681c87a590bc$var$gl.ARRAY_BUFFER, $80cc681c87a590bc$var$tilemap_buffer);\n$80cc681c87a590bc$var$gl.bufferData($80cc681c87a590bc$var$gl.ARRAY_BUFFER, $80cc681c87a590bc$var$tilemap_data_cpu, $80cc681c87a590bc$var$gl.STATIC_DRAW);\nlet $80cc681c87a590bc$var$tilemap_vaoinfo = $amYBK.createVertexArrayInfo($80cc681c87a590bc$var$gl, $80cc681c87a590bc$var$tilemap_programinfo, $amYBK.createBufferInfoFromArrays($80cc681c87a590bc$var$gl, {\n    a_position: {\n        buffer: $80cc681c87a590bc$var$tilemap_buffer,\n        type: $80cc681c87a590bc$var$gl.FLOAT,\n        numComponents: 2,\n        stride: 16,\n        offset: 0,\n        divisor: 1\n    },\n    a_tileindex: {\n        buffer: $80cc681c87a590bc$var$tilemap_buffer,\n        type: $80cc681c87a590bc$var$gl.FLOAT,\n        numComponents: 2,\n        stride: 16,\n        offset: 8,\n        divisor: 1\n    },\n    a_vertex: {\n        data: [\n            // Triangle for 1,1 corner\n            1.0,\n            1.0,\n            0.0,\n            1.0,\n            1.0,\n            0.0,\n            // Triangle for 0,0 corner\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            1.0\n        ],\n        numComponents: 2\n    }\n}));\nvar $80cc681c87a590bc$var$vao, $80cc681c87a590bc$var$size, $80cc681c87a590bc$var$type, $80cc681c87a590bc$var$normalize, $80cc681c87a590bc$var$stride, $80cc681c87a590bc$var$offset, $80cc681c87a590bc$var$size, $80cc681c87a590bc$var$type, $80cc681c87a590bc$var$normalize, $80cc681c87a590bc$var$stride, $80cc681c87a590bc$var$offset;\nvar $6b51d33817ed6c9b$exports = {};\n\n$6b51d33817ed6c9b$exports = new URL(\"../\" + (parcelRequire(\"kyEFX\")).resolve(\"5Oroq\"), import.meta.url).toString();\n\n\nconst $80cc681c87a590bc$var$floor_texture = $amYBK.createTexture($80cc681c87a590bc$var$gl, {\n    src: new URL($6b51d33817ed6c9b$exports).toString(),\n    mag: $80cc681c87a590bc$var$gl.NEAREST,\n    wrap: $80cc681c87a590bc$var$gl.REPEAT\n});\nlet $80cc681c87a590bc$var$level_floors = $80cc681c87a590bc$var$level_rows.map((r)=>r.split(\"\").map((c)=>c != \"#\" && c != \"!\")).flat();\n// Floor approach: only first fill N tiles\n// use same shader, or another? for now, let's keep the same one\nconst $80cc681c87a590bc$var$floormap_data_cpu = new Float32Array(4 * $80cc681c87a590bc$var$level_width * $80cc681c87a590bc$var$level_height);\nlet $80cc681c87a590bc$var$n_floors = 0;\nfor(let j = 0; j < $80cc681c87a590bc$var$level_height; j++){\n    for(let i = 0; i < $80cc681c87a590bc$var$level_width; i++)if ($80cc681c87a590bc$var$level_floors[i + j * $80cc681c87a590bc$var$level_width]) {\n        // x,y position\n        $80cc681c87a590bc$var$floormap_data_cpu[$80cc681c87a590bc$var$n_floors * 4 + 0] = i;\n        $80cc681c87a590bc$var$floormap_data_cpu[$80cc681c87a590bc$var$n_floors * 4 + 1] = j;\n        // actual tile to use is always 0,0\n        $80cc681c87a590bc$var$tilemap_data_cpu[$80cc681c87a590bc$var$n_floors * 4 + 2] = 0;\n        $80cc681c87a590bc$var$tilemap_data_cpu[$80cc681c87a590bc$var$n_floors * 4 + 3] = 0;\n        $80cc681c87a590bc$var$n_floors += 1;\n    }\n}\nconst $80cc681c87a590bc$var$floormap_buffer = $80cc681c87a590bc$var$gl.createBuffer();\n$80cc681c87a590bc$var$gl.bindBuffer($80cc681c87a590bc$var$gl.ARRAY_BUFFER, $80cc681c87a590bc$var$floormap_buffer);\n$80cc681c87a590bc$var$gl.bufferData($80cc681c87a590bc$var$gl.ARRAY_BUFFER, $80cc681c87a590bc$var$floormap_data_cpu, $80cc681c87a590bc$var$gl.STATIC_DRAW);\nlet $80cc681c87a590bc$var$floormap_vaoinfo = $amYBK.createVertexArrayInfo($80cc681c87a590bc$var$gl, $80cc681c87a590bc$var$tilemap_programinfo, $amYBK.createBufferInfoFromArrays($80cc681c87a590bc$var$gl, {\n    a_position: {\n        buffer: $80cc681c87a590bc$var$floormap_buffer,\n        type: $80cc681c87a590bc$var$gl.FLOAT,\n        numComponents: 2,\n        stride: 16,\n        offset: 0,\n        divisor: 1\n    },\n    a_tileindex: {\n        buffer: $80cc681c87a590bc$var$floormap_buffer,\n        type: $80cc681c87a590bc$var$gl.FLOAT,\n        numComponents: 2,\n        stride: 16,\n        offset: 8,\n        divisor: 1\n    },\n    a_vertex: {\n        data: [\n            // Triangle for 1,1 corner\n            1.0,\n            1.0,\n            0.0,\n            1.0,\n            1.0,\n            0.0,\n            // Triangle for 0,0 corner\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            1.0\n        ],\n        numComponents: 2\n    }\n}));\n// Player & boxes sprite drawing\n// can't use instancing since it can't offset into the attribute buffer\n// so we will use Shaku's style vertex buffers, sending 6 vertices per sprite instead of a single vec2 position :(\n// each vertex needs position, uv, depth?, color? for the moment, only pos (vec2) & uv (vec2)\n// Let's use sepparate buffers instead of interleaved, since they won't update with the same frequency\n// Vertices will be: top left, top right, bottom left, bottom right.\n// even with different textures, it's cool to have a single buffer, since we can draw subsets of it.\n// but it would be even cooler with atlas texture, @future: custom parcel plugin for auto atlas packing\nconst $80cc681c87a590bc$var$sprites_programinfo = $amYBK.createProgramInfo($80cc681c87a590bc$var$gl, [\n    // vs\n    `#version 300 es\r\n\r\n    in vec2 a_position;\r\n    in vec2 a_texcoord;\r\n\r\n    // global data\r\n    // sprites drawn at 0,0 will end in this clipspace position\r\n    uniform vec2 u_origin;\r\n    // sprites drawn at 1,1 will end in u_origin plus this clipspace position\r\n    uniform vec2 u_basis;\r\n\r\n    out vec2 v_texcoord;\r\n\r\n    void main() {\r\n        gl_Position = vec4(u_origin + a_position * u_basis, 0.0, 1.0);\r\n        v_texcoord = a_texcoord;\r\n    }\r\n    `,\n    // fs\n    `#version 300 es\r\n    precision highp float;\r\n    \r\n    in vec2 v_texcoord;\r\n\r\n    uniform sampler2D u_texture;\r\n\r\n    out vec4 out_color;\r\n\r\n    void main() {\r\n        out_color = texture(u_texture, v_texcoord);\r\n    }\r\n    `\n]);\nconst $80cc681c87a590bc$var$max_n_sprites = 32;\nconsole.assert($80cc681c87a590bc$var$max_n_sprites * 6 < 65536, \"Can't draw that many sprites, change the code to use u32 indices.\");\nvar $80cc681c87a590bc$var$cur_n_sprites = 0;\nvar $80cc681c87a590bc$var$sprites_pos_cpu = new Float32Array($80cc681c87a590bc$var$max_n_sprites * 2);\nvar $80cc681c87a590bc$var$sprites_uv_cpu = new Float32Array($80cc681c87a590bc$var$max_n_sprites * 2);\nconst $80cc681c87a590bc$var$sprites_indices = new Uint16Array($80cc681c87a590bc$var$max_n_sprites * 6);\nfor(let k = 0; k < $80cc681c87a590bc$var$max_n_sprites; k += 1){\n    // top left triangle\n    $80cc681c87a590bc$var$sprites_indices[k * 6 + 0] = k * 4 + 0;\n    $80cc681c87a590bc$var$sprites_indices[k * 6 + 1] = k * 4 + 1;\n    $80cc681c87a590bc$var$sprites_indices[k * 6 + 2] = k * 4 + 2;\n    // bottom right triangle\n    $80cc681c87a590bc$var$sprites_indices[k * 6 + 3] = k * 4 + 1;\n    $80cc681c87a590bc$var$sprites_indices[k * 6 + 4] = k * 4 + 3;\n    $80cc681c87a590bc$var$sprites_indices[k * 6 + 5] = k * 4 + 2;\n}\nlet $80cc681c87a590bc$var$sprites_bufferinfo = $amYBK.createBufferInfoFromArrays($80cc681c87a590bc$var$gl, {\n    a_position: {\n        data: $80cc681c87a590bc$var$sprites_pos_cpu,\n        numComponents: 2,\n        drawType: $80cc681c87a590bc$var$gl.DYNAMIC_DRAW\n    },\n    a_texcoord: {\n        data: $80cc681c87a590bc$var$sprites_uv_cpu,\n        numComponents: 2,\n        drawType: $80cc681c87a590bc$var$gl.DYNAMIC_DRAW\n    },\n    indices: {\n        data: $80cc681c87a590bc$var$sprites_indices,\n        drawType: $80cc681c87a590bc$var$gl.STATIC_DRAW\n    }\n});\nconst $80cc681c87a590bc$var$sprites_pos_gpu = $80cc681c87a590bc$var$sprites_bufferinfo.attribs.a_position.buffer;\nconst $80cc681c87a590bc$var$sprites_uv_gpu = $80cc681c87a590bc$var$sprites_bufferinfo.attribs.a_texcoord.buffer;\nconst $80cc681c87a590bc$var$sprites_vaoinfo = $amYBK.createVertexArrayInfo($80cc681c87a590bc$var$gl, $80cc681c87a590bc$var$sprites_programinfo, $80cc681c87a590bc$var$sprites_bufferinfo);\nvar $8493c613161e864d$exports = {};\n\n$8493c613161e864d$exports = new URL(\"../\" + (parcelRequire(\"kyEFX\")).resolve(\"gQMdV\"), import.meta.url).toString();\n\n\nconst $80cc681c87a590bc$var$player_texture = $amYBK.createTexture($80cc681c87a590bc$var$gl, {\n    src: new URL($8493c613161e864d$exports).toString(),\n    mag: $80cc681c87a590bc$var$gl.NEAREST,\n    wrap: $80cc681c87a590bc$var$gl.REPEAT\n});\nvar $7826d88a0ae564d0$exports = {};\n\n$7826d88a0ae564d0$exports = new URL(\"../\" + (parcelRequire(\"kyEFX\")).resolve(\"8p6MJ\"), import.meta.url).toString();\n\n\nconst $80cc681c87a590bc$var$crate_texture = $amYBK.createTexture($80cc681c87a590bc$var$gl, {\n    src: new URL($7826d88a0ae564d0$exports).toString(),\n    mag: $80cc681c87a590bc$var$gl.NEAREST,\n    wrap: $80cc681c87a590bc$var$gl.REPEAT\n});\nlet $80cc681c87a590bc$var$game_state = {\n    debug_x: 0,\n    debug_y: 0,\n    player_pos: new (0, $5c4293b9a464b6e0$export$ac4bca90992eed1)(2, 3),\n    crates_pos: [\n        new (0, $5c4293b9a464b6e0$export$ac4bca90992eed1)(1, 3),\n        new (0, $5c4293b9a464b6e0$export$ac4bca90992eed1)(3, 4)\n    ]\n};\n// Command: Any action that takes time & is undoable\nclass $80cc681c87a590bc$var$PlayerMoveCommand {\n    constructor(original_pos, dir){\n        this.original_pos = original_pos;\n        this.dir = dir;\n    }\n    execute() {\n        (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).add(this.original_pos, this.dir, $80cc681c87a590bc$var$game_state.player_pos);\n    }\n    animTurn(turn_time) {\n        (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).add(this.original_pos, (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).scale(this.dir, turn_time), $80cc681c87a590bc$var$visual_state.player_sprite.position);\n        $80cc681c87a590bc$var$updateSpritePositionOrSize($80cc681c87a590bc$var$visual_state.player_sprite);\n    }\n    undoAnimTurn(turn_time) {\n        this.animTurn(1.0 - turn_time);\n    }\n    undo() {\n        (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).copy(this.original_pos, $80cc681c87a590bc$var$game_state.player_pos);\n    }\n}\nclass $80cc681c87a590bc$var$PushCrateCommand {\n    constructor(crate_index, original_pos, dir){\n        this.crate_index = crate_index;\n        this.original_pos = original_pos;\n        this.dir = dir;\n        this.extra_command = new $80cc681c87a590bc$var$PlayerMoveCommand((0, $5c4293b9a464b6e0$export$ac4bca90992eed1).sub(original_pos, dir), dir);\n    }\n    execute() {\n        (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).add(this.original_pos, this.dir, $80cc681c87a590bc$var$game_state.crates_pos[this.crate_index]);\n        this.extra_command.execute();\n    }\n    animTurn(turn_time) {\n        (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).add(this.original_pos, (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).scale(this.dir, turn_time), $80cc681c87a590bc$var$visual_state.crates_sprites[this.crate_index].position);\n        $80cc681c87a590bc$var$updateSpritePositionOrSize($80cc681c87a590bc$var$visual_state.crates_sprites[this.crate_index]);\n        this.extra_command.animTurn(turn_time);\n    }\n    undoAnimTurn(turn_time) {\n        // player moves backwards\n        this.extra_command.animTurn(1.0 - turn_time);\n        // crate pops into place\n        let tile_center = (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).add(this.original_pos, new (0, $5c4293b9a464b6e0$export$ac4bca90992eed1)(.5, .5));\n        if (turn_time < .5) {\n            (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).scale((0, $5c4293b9a464b6e0$export$ac4bca90992eed1).one, 1.0 - 2.0 * turn_time, $80cc681c87a590bc$var$visual_state.crates_sprites[this.crate_index].size);\n            (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).add(tile_center, this.dir, tile_center);\n        } else {\n            (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).scale((0, $5c4293b9a464b6e0$export$ac4bca90992eed1).one, 2.0 * turn_time - 1.0, $80cc681c87a590bc$var$visual_state.crates_sprites[this.crate_index].size);\n            (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).copy(this.original_pos, $80cc681c87a590bc$var$visual_state.crates_sprites[this.crate_index].position);\n        }\n        $80cc681c87a590bc$var$setSpriteCenter($80cc681c87a590bc$var$visual_state.crates_sprites[this.crate_index], tile_center);\n        $80cc681c87a590bc$var$updateSpritePositionOrSize($80cc681c87a590bc$var$visual_state.crates_sprites[this.crate_index]);\n    }\n    undo() {\n        (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).copy(this.original_pos, $80cc681c87a590bc$var$game_state.crates_pos[this.crate_index]);\n        this.extra_command.undo();\n    }\n}\nclass $80cc681c87a590bc$var$BumpWallCommand {\n    constructor(pos, dir){\n        this.pos = pos;\n        this.dir = dir;\n    }\n    execute() {\n        throw new Error(\"not an executable command\");\n    }\n    animTurn(turn_time) {\n        let displacement = turn_time * (1 - turn_time);\n        (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).add(this.pos, (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).scale(this.dir, displacement), $80cc681c87a590bc$var$visual_state.player_sprite.position);\n        $80cc681c87a590bc$var$updateSpritePositionOrSize($80cc681c87a590bc$var$visual_state.player_sprite);\n    }\n    undoAnimTurn(turn_time) {\n        throw new Error(\"not an undoable command\");\n    }\n    undo() {\n        throw new Error(\"not an undoable command\");\n    }\n}\nlet $80cc681c87a590bc$var$command_history = [];\nlet $80cc681c87a590bc$var$visual_state = {\n    turn_time: 0,\n    player_sprite: $80cc681c87a590bc$var$createSprite((0, $5c4293b9a464b6e0$export$ac4bca90992eed1).copy($80cc681c87a590bc$var$game_state.player_pos), (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).copy((0, $5c4293b9a464b6e0$export$ac4bca90992eed1).one), (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).copy((0, $5c4293b9a464b6e0$export$ac4bca90992eed1).zero), (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).copy((0, $5c4293b9a464b6e0$export$ac4bca90992eed1).one)),\n    crates_sprites: $80cc681c87a590bc$var$game_state.crates_pos.map((crate_pos)=>{\n        return $80cc681c87a590bc$var$createSprite((0, $5c4293b9a464b6e0$export$ac4bca90992eed1).copy(crate_pos), (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).copy((0, $5c4293b9a464b6e0$export$ac4bca90992eed1).one), (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).copy((0, $5c4293b9a464b6e0$export$ac4bca90992eed1).zero), (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).copy((0, $5c4293b9a464b6e0$export$ac4bca90992eed1).one));\n    })\n};\nlet $80cc681c87a590bc$var$cur_animating_command = null;\nlet $80cc681c87a590bc$var$cur_animating_undo_command = null;\nconst $80cc681c87a590bc$var$move_duration = .05;\nfunction $80cc681c87a590bc$var$createSprite(pos, size, uv_pos, uv_size) {\n    let index = $80cc681c87a590bc$var$cur_n_sprites;\n    $80cc681c87a590bc$var$cur_n_sprites += 1;\n    let sprite = {\n        buffer_index: index,\n        position: pos,\n        size: size,\n        uv_pos: uv_pos,\n        uv_size: uv_size\n    };\n    $80cc681c87a590bc$var$updateSpritePositionOrSize(sprite);\n    $80cc681c87a590bc$var$updateSpriteUVs(sprite);\n    return sprite;\n}\nfunction $80cc681c87a590bc$var$setSpriteCenter(sprite, center) {\n    (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).sub(center, (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).scale(sprite.size, .5), sprite.position);\n}\nfunction $80cc681c87a590bc$var$updateSpritePositionOrSize(sprite) {\n    // vertex positions \n    $80cc681c87a590bc$var$sprites_pos_cpu[sprite.buffer_index * 8 + 0] = sprite.position.x;\n    $80cc681c87a590bc$var$sprites_pos_cpu[sprite.buffer_index * 8 + 1] = sprite.position.y;\n    $80cc681c87a590bc$var$sprites_pos_cpu[sprite.buffer_index * 8 + 2] = sprite.position.x + sprite.size.x;\n    $80cc681c87a590bc$var$sprites_pos_cpu[sprite.buffer_index * 8 + 3] = sprite.position.y;\n    $80cc681c87a590bc$var$sprites_pos_cpu[sprite.buffer_index * 8 + 4] = sprite.position.x;\n    $80cc681c87a590bc$var$sprites_pos_cpu[sprite.buffer_index * 8 + 5] = sprite.position.y + sprite.size.x;\n    $80cc681c87a590bc$var$sprites_pos_cpu[sprite.buffer_index * 8 + 6] = sprite.position.x + sprite.size.x;\n    $80cc681c87a590bc$var$sprites_pos_cpu[sprite.buffer_index * 8 + 7] = sprite.position.y + sprite.size.x;\n}\nfunction $80cc681c87a590bc$var$updateSpriteUVs(sprite) {\n    // vertex uv coordinates\n    $80cc681c87a590bc$var$sprites_uv_cpu[sprite.buffer_index * 8 + 0] = sprite.uv_pos.x;\n    $80cc681c87a590bc$var$sprites_uv_cpu[sprite.buffer_index * 8 + 1] = sprite.uv_pos.y;\n    $80cc681c87a590bc$var$sprites_uv_cpu[sprite.buffer_index * 8 + 2] = sprite.uv_pos.x + sprite.uv_size.x;\n    $80cc681c87a590bc$var$sprites_uv_cpu[sprite.buffer_index * 8 + 3] = sprite.uv_pos.y;\n    $80cc681c87a590bc$var$sprites_uv_cpu[sprite.buffer_index * 8 + 4] = sprite.uv_pos.x;\n    $80cc681c87a590bc$var$sprites_uv_cpu[sprite.buffer_index * 8 + 5] = sprite.uv_pos.y + sprite.uv_size.x;\n    $80cc681c87a590bc$var$sprites_uv_cpu[sprite.buffer_index * 8 + 6] = sprite.uv_pos.x + sprite.uv_size.x;\n    $80cc681c87a590bc$var$sprites_uv_cpu[sprite.buffer_index * 8 + 7] = sprite.uv_pos.y + sprite.uv_size.x;\n}\nlet $80cc681c87a590bc$var$input_state = {\n    pressed: {},\n    queued: []\n};\nlet $80cc681c87a590bc$var$loop_id = requestAnimationFrame($80cc681c87a590bc$var$update);\ndocument.addEventListener(\"keydown\", $80cc681c87a590bc$var$onKeyDown);\ndocument.addEventListener(\"keyup\", $80cc681c87a590bc$var$onKeyUp);\nfunction $80cc681c87a590bc$var$onKeyDown(ev) {\n    console.log(\"keydown\");\n    $80cc681c87a590bc$var$input_state.pressed[ev.code] = true;\n    $80cc681c87a590bc$var$input_state.queued.push(ev.code);\n}\nfunction $80cc681c87a590bc$var$onKeyUp(ev) {\n    console.log(\"keyup\");\n    $80cc681c87a590bc$var$input_state.pressed[ev.code] = false;\n}\nlet $80cc681c87a590bc$var$time_last = 0;\nfunction $80cc681c87a590bc$var$update(time_cur) {\n    let delta = (time_cur - $80cc681c87a590bc$var$time_last) * 0.001;\n    $80cc681c87a590bc$var$time_last = time_cur;\n    if ($amYBK.resizeCanvasToDisplaySize($80cc681c87a590bc$var$gl.canvas)) $80cc681c87a590bc$var$gl.viewport(0, 0, $80cc681c87a590bc$var$gl.drawingBufferWidth, $80cc681c87a590bc$var$gl.drawingBufferHeight);\n    if ($80cc681c87a590bc$var$input_state.pressed[\"KeyA\"]) $80cc681c87a590bc$var$game_state.debug_x -= 1;\n    if ($80cc681c87a590bc$var$input_state.pressed[\"KeyD\"]) $80cc681c87a590bc$var$game_state.debug_x += 1;\n    if ($80cc681c87a590bc$var$input_state.pressed[\"KeyW\"]) $80cc681c87a590bc$var$game_state.debug_y -= 1;\n    if ($80cc681c87a590bc$var$input_state.pressed[\"KeyS\"]) $80cc681c87a590bc$var$game_state.debug_y += 1;\n    if ($80cc681c87a590bc$var$input_state.queued.length > 0 && $80cc681c87a590bc$var$cur_animating_command === null && $80cc681c87a590bc$var$cur_animating_undo_command === null) {\n        let cur_input = $80cc681c87a590bc$var$input_state.queued.shift();\n        if (cur_input == \"KeyZ\") {\n            if ($80cc681c87a590bc$var$command_history.length > 0) {\n                $80cc681c87a590bc$var$cur_animating_undo_command = $80cc681c87a590bc$var$command_history.pop();\n                $80cc681c87a590bc$var$cur_animating_undo_command.undo();\n                $80cc681c87a590bc$var$visual_state.turn_time = 0;\n            }\n        } else {\n            let player_delta = new (0, $5c4293b9a464b6e0$export$ac4bca90992eed1)();\n            switch(cur_input){\n                case \"KeyD\":\n                    player_delta.x = 1;\n                    break;\n                case \"KeyA\":\n                    player_delta.x = -1;\n                    break;\n                case \"KeyW\":\n                    player_delta.y = -1;\n                    break;\n                case \"KeyS\":\n                    player_delta.y = 1;\n                    break;\n            }\n            if (player_delta.x != 0 || player_delta.y != 0) {\n                let new_player_pos = (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).add($80cc681c87a590bc$var$game_state.player_pos, player_delta);\n                if (!$80cc681c87a590bc$var$getWallAt(new_player_pos.x, new_player_pos.y)) {\n                    let pushing_crate_index = $80cc681c87a590bc$var$game_state.crates_pos.findIndex((crate_pos)=>(0, $5c4293b9a464b6e0$export$ac4bca90992eed1).equals(new_player_pos, crate_pos));\n                    if (pushing_crate_index == -1) {\n                        // Standard move\n                        $80cc681c87a590bc$var$cur_animating_command = new $80cc681c87a590bc$var$PlayerMoveCommand((0, $5c4293b9a464b6e0$export$ac4bca90992eed1).copy($80cc681c87a590bc$var$game_state.player_pos), player_delta);\n                        $80cc681c87a590bc$var$cur_animating_command.execute();\n                        $80cc681c87a590bc$var$command_history.push($80cc681c87a590bc$var$cur_animating_command);\n                    } else {\n                        // Try to push a crate\n                        let new_crate_pos = (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).add($80cc681c87a590bc$var$game_state.crates_pos[pushing_crate_index], player_delta);\n                        let is_push_blocked = $80cc681c87a590bc$var$getWallAt(new_crate_pos.x, new_crate_pos.y) || $80cc681c87a590bc$var$game_state.crates_pos.some((crate_pos)=>(0, $5c4293b9a464b6e0$export$ac4bca90992eed1).equals(new_crate_pos, crate_pos));\n                        if (!is_push_blocked) {\n                            // Push a crate\n                            $80cc681c87a590bc$var$cur_animating_command = new $80cc681c87a590bc$var$PushCrateCommand(pushing_crate_index, (0, $5c4293b9a464b6e0$export$ac4bca90992eed1).copy($80cc681c87a590bc$var$game_state.crates_pos[pushing_crate_index]), player_delta);\n                            $80cc681c87a590bc$var$cur_animating_command.execute();\n                            $80cc681c87a590bc$var$command_history.push($80cc681c87a590bc$var$cur_animating_command);\n                        } else $80cc681c87a590bc$var$cur_animating_command = new $80cc681c87a590bc$var$BumpWallCommand($80cc681c87a590bc$var$game_state.player_pos, player_delta);\n                    }\n                } else $80cc681c87a590bc$var$cur_animating_command = new $80cc681c87a590bc$var$BumpWallCommand($80cc681c87a590bc$var$game_state.player_pos, player_delta);\n            }\n        }\n    }\n    if ($80cc681c87a590bc$var$cur_animating_command !== null) {\n        $80cc681c87a590bc$var$visual_state.turn_time += delta / $80cc681c87a590bc$var$move_duration;\n        $80cc681c87a590bc$var$visual_state.turn_time = (0, $5c4293b9a464b6e0$export$7d15b64cf5a3a4c4)($80cc681c87a590bc$var$visual_state.turn_time, 0, 1);\n        $80cc681c87a590bc$var$cur_animating_command.animTurn($80cc681c87a590bc$var$visual_state.turn_time);\n        if ($80cc681c87a590bc$var$visual_state.turn_time >= 1) {\n            $80cc681c87a590bc$var$cur_animating_command = null;\n            $80cc681c87a590bc$var$visual_state.turn_time = 0;\n        }\n    } else if ($80cc681c87a590bc$var$cur_animating_undo_command !== null) {\n        $80cc681c87a590bc$var$visual_state.turn_time += delta / $80cc681c87a590bc$var$move_duration;\n        $80cc681c87a590bc$var$visual_state.turn_time = (0, $5c4293b9a464b6e0$export$7d15b64cf5a3a4c4)($80cc681c87a590bc$var$visual_state.turn_time, 0, 1);\n        $80cc681c87a590bc$var$cur_animating_undo_command.undoAnimTurn($80cc681c87a590bc$var$visual_state.turn_time);\n        if ($80cc681c87a590bc$var$visual_state.turn_time >= 1) {\n            $80cc681c87a590bc$var$cur_animating_undo_command = null;\n            $80cc681c87a590bc$var$visual_state.turn_time = 0;\n        }\n    }\n    $80cc681c87a590bc$var$gl.clear($80cc681c87a590bc$var$gl.COLOR_BUFFER_BIT);\n    // Debug temp stuff\n    $80cc681c87a590bc$var$gl.useProgram($80cc681c87a590bc$var$sprite_program_info.program);\n    $amYBK.setBuffersAndAttributes($80cc681c87a590bc$var$gl, $80cc681c87a590bc$var$sprite_program_info, $80cc681c87a590bc$var$sprite_vao);\n    $amYBK.setUniforms($80cc681c87a590bc$var$sprite_program_info, {\n        u_texture: $80cc681c87a590bc$var$my_texture,\n        u_resolution: [\n            $80cc681c87a590bc$var$gl.canvas.width,\n            $80cc681c87a590bc$var$gl.canvas.height\n        ],\n        u_size: [\n            50,\n            50\n        ],\n        u_position: [\n            $80cc681c87a590bc$var$game_state.debug_x,\n            $80cc681c87a590bc$var$game_state.debug_y\n        ]\n    });\n    $amYBK.drawBufferInfo($80cc681c87a590bc$var$gl, $80cc681c87a590bc$var$sprite_buffer_info);\n    // walls\n    $80cc681c87a590bc$var$gl.useProgram($80cc681c87a590bc$var$tilemap_programinfo.program);\n    $80cc681c87a590bc$var$gl.bindVertexArray($80cc681c87a590bc$var$tilemap_vaoinfo.vertexArrayObject);\n    $amYBK.setUniformsAndBindTextures($80cc681c87a590bc$var$tilemap_programinfo, {\n        u_origin: [\n            -$80cc681c87a590bc$var$tilemap_width * $80cc681c87a590bc$var$tilemap_tilesize / $80cc681c87a590bc$var$gl.canvas.width,\n            $80cc681c87a590bc$var$tilemap_height * $80cc681c87a590bc$var$tilemap_tilesize / $80cc681c87a590bc$var$gl.canvas.height\n        ],\n        u_basis: [\n            2 * $80cc681c87a590bc$var$tilemap_tilesize / $80cc681c87a590bc$var$gl.canvas.width,\n            -2 * $80cc681c87a590bc$var$tilemap_tilesize / $80cc681c87a590bc$var$gl.canvas.height\n        ],\n        u_sheet_count: [\n            4,\n            4\n        ],\n        u_sheet: $80cc681c87a590bc$var$tilemap_texture\n    });\n    $80cc681c87a590bc$var$gl.drawArraysInstanced($80cc681c87a590bc$var$gl.TRIANGLES, 0, 6, $80cc681c87a590bc$var$tilemap_width * $80cc681c87a590bc$var$tilemap_height);\n    // floors\n    $80cc681c87a590bc$var$gl.bindVertexArray($80cc681c87a590bc$var$floormap_vaoinfo.vertexArrayObject);\n    $amYBK.setUniformsAndBindTextures($80cc681c87a590bc$var$tilemap_programinfo, {\n        u_origin: [\n            -$80cc681c87a590bc$var$level_width * $80cc681c87a590bc$var$tilemap_tilesize / $80cc681c87a590bc$var$gl.canvas.width,\n            $80cc681c87a590bc$var$level_height * $80cc681c87a590bc$var$tilemap_tilesize / $80cc681c87a590bc$var$gl.canvas.height\n        ],\n        u_basis: [\n            2 * $80cc681c87a590bc$var$tilemap_tilesize / $80cc681c87a590bc$var$gl.canvas.width,\n            -2 * $80cc681c87a590bc$var$tilemap_tilesize / $80cc681c87a590bc$var$gl.canvas.height\n        ],\n        u_sheet_count: [\n            1,\n            1\n        ],\n        u_sheet: $80cc681c87a590bc$var$floor_texture\n    });\n    $80cc681c87a590bc$var$gl.drawArraysInstanced($80cc681c87a590bc$var$gl.TRIANGLES, 0, 6, $80cc681c87a590bc$var$n_floors);\n    // moving stuff:\n    $80cc681c87a590bc$var$gl.bindBuffer($80cc681c87a590bc$var$gl.ARRAY_BUFFER, $80cc681c87a590bc$var$sprites_pos_gpu);\n    $80cc681c87a590bc$var$gl.bufferSubData($80cc681c87a590bc$var$gl.ARRAY_BUFFER, 0, $80cc681c87a590bc$var$sprites_pos_cpu);\n    $80cc681c87a590bc$var$gl.bindBuffer($80cc681c87a590bc$var$gl.ARRAY_BUFFER, $80cc681c87a590bc$var$sprites_uv_gpu);\n    $80cc681c87a590bc$var$gl.bufferSubData($80cc681c87a590bc$var$gl.ARRAY_BUFFER, 0, $80cc681c87a590bc$var$sprites_uv_cpu);\n    $80cc681c87a590bc$var$gl.useProgram($80cc681c87a590bc$var$sprites_programinfo.program);\n    $80cc681c87a590bc$var$gl.bindVertexArray($80cc681c87a590bc$var$sprites_vaoinfo.vertexArrayObject);\n    //  - player\n    $amYBK.setUniformsAndBindTextures($80cc681c87a590bc$var$sprites_programinfo, {\n        u_origin: [\n            -$80cc681c87a590bc$var$level_width * $80cc681c87a590bc$var$tilemap_tilesize / $80cc681c87a590bc$var$gl.canvas.width,\n            $80cc681c87a590bc$var$level_height * $80cc681c87a590bc$var$tilemap_tilesize / $80cc681c87a590bc$var$gl.canvas.height\n        ],\n        u_basis: [\n            2 * $80cc681c87a590bc$var$tilemap_tilesize / $80cc681c87a590bc$var$gl.canvas.width,\n            -2 * $80cc681c87a590bc$var$tilemap_tilesize / $80cc681c87a590bc$var$gl.canvas.height\n        ],\n        u_texture: $80cc681c87a590bc$var$player_texture\n    });\n    $80cc681c87a590bc$var$gl.drawElements($80cc681c87a590bc$var$gl.TRIANGLES, 6, $80cc681c87a590bc$var$gl.UNSIGNED_SHORT, $80cc681c87a590bc$var$visual_state.player_sprite.buffer_index * 12); // 12 bytes per quad\n    // - crates\n    $amYBK.setUniformsAndBindTextures($80cc681c87a590bc$var$sprites_programinfo, {\n        u_origin: [\n            -$80cc681c87a590bc$var$level_width * $80cc681c87a590bc$var$tilemap_tilesize / $80cc681c87a590bc$var$gl.canvas.width,\n            $80cc681c87a590bc$var$level_height * $80cc681c87a590bc$var$tilemap_tilesize / $80cc681c87a590bc$var$gl.canvas.height\n        ],\n        u_basis: [\n            2 * $80cc681c87a590bc$var$tilemap_tilesize / $80cc681c87a590bc$var$gl.canvas.width,\n            -2 * $80cc681c87a590bc$var$tilemap_tilesize / $80cc681c87a590bc$var$gl.canvas.height\n        ],\n        u_texture: $80cc681c87a590bc$var$crate_texture\n    });\n    $80cc681c87a590bc$var$gl.drawElements($80cc681c87a590bc$var$gl.TRIANGLES, 12, $80cc681c87a590bc$var$gl.UNSIGNED_SHORT, $80cc681c87a590bc$var$visual_state.crates_sprites[0].buffer_index * 12); // assume crate sprites are contiguous\n    $80cc681c87a590bc$var$loop_id = requestAnimationFrame($80cc681c87a590bc$var$update);\n}\n\n\n//# sourceMappingURL=index.d232555d.js.map\n","\"use strict\";\n\nvar mapping = {};\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping[id];\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return resolved;\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"gi6r7\\\":\\\"index.d232555d.js\\\",\\\"5TaR7\\\":\\\"sprite.22ec2077.png\\\",\\\"6PWe3\\\":\\\"walls_312.cb79a6c7.png\\\",\\\"5Oroq\\\":\\\"floor_312.8cddc3eb.png\\\",\\\"gQMdV\\\":\\\"player_puzzlescript.5728a87e.png\\\",\\\"8p6MJ\\\":\\\"crate_puzzlescript.92620967.png\\\",\\\"bB1AD\\\":\\\"index.9c3702eb.js\\\"}\"));","import * as twgl from \"twgl.js\"\r\nimport { Vec2, clamp } from \"../kommon/math\";\r\n\r\n// Sokoban, in \"groud truth programming\" / \"C style\":\r\n// delay abstraction, consider each byte, don't reuse if it's not a perfect fit\r\n\r\n// This \"if\" will only execute during development\r\nif (module.hot) {\r\n    module.hot.dispose(data => {\r\n        data.game_state = game_state;\r\n        cancelAnimationFrame(loop_id);\r\n        document.removeEventListener(\"keydown\", onKeyDown);\r\n        document.removeEventListener(\"keyup\", onKeyUp);\r\n    });\r\n    module.hot.accept(_ => {\r\n        game_state = module.hot!.data.game_state;\r\n    });\r\n}\r\n\r\nconst gl = (document.querySelector(\"#c\") as HTMLCanvasElement).getContext(\"webgl2\", { alpha: false })!;\r\ngl.clearColor(0.5, 0.5, 0.75, 1.0);\r\ngl.enable(gl.BLEND);\r\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\ntwgl.resizeCanvasToDisplaySize(gl.canvas as HTMLCanvasElement);\r\ngl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n\r\nconst my_texture = twgl.createTexture(gl, {\r\n    src: (new URL('sprite.png', import.meta.url)).toString(),\r\n    // mag: gl.NEAREST, etc\r\n});\r\n\r\n// @ts-ignore\r\nimport vert_source from \"../drawSprite/shaders/sprite.vert\";\r\n// @ts-ignore\r\nimport frag_source from \"../drawSprite/shaders/sprite.frag\";\r\nconst sprite_program_info = twgl.createProgramInfo(gl, [vert_source, frag_source]);\r\nconst sprite_buffer_info = twgl.createBufferInfoFromArrays(gl, {\r\n    a_vertex: {\r\n        data: [\r\n            // Triangle for 1,1 corner\r\n            1.0, 1.0,\r\n            0.0, 1.0,\r\n            1.0, 0.0,\r\n            // Triangle for 0,0 corner\r\n            0.0, 0.0,\r\n            1.0, 0.0,\r\n            0.0, 1.0,\r\n        ],\r\n        numComponents: 2,\r\n    },\r\n});\r\nconst sprite_vao = twgl.createVertexArrayInfo(gl, sprite_program_info, sprite_buffer_info);\r\n\r\n// data for sprite renderer\r\n// per tile:\r\n// - 4 vertices : vec8\r\n// - 2 uv vertices : vec4\r\n// ?? idk, depends on the specifics (do we want rotation? arbitrary rotation? arbitrary uvs? coords on pixels or tiles or screen?)\r\n\r\n// for now, let's do it perfectly, one thing at a time\r\n// and from there, get an imperfect but general system\r\n\r\n// min data for a tilemap:\r\n// global:\r\n// - screen resolution : vec2\r\n// - tilemap count : vec2\r\n// - tilemap top left : vec2\r\n// - tile size : float/vec2?/vec4 (if allowing an arbitrary base)\r\n//    (for now, float)\r\n// per tile:\r\n// - tile index : vec2\r\n// - position : vec2\r\n// draw an instanced [0,1] quad, or maybe directly use vertexId?\r\n// in any case, a_vertex is a [0,1] quad\r\n// computations:\r\n// - pos = u_origin + (a_vertex + a_position) * vec2(u_basis_x, u_basis_y)\r\n// - uv = (a_tilemap_index + a_vertex) / u_sprite_counts\r\n// tothink:\r\n//   what if there's a margin?\r\n//   no need for position if we assume a rectangular tilemap... but that's too much\r\n//   another option is to always use the same mesh, & only change tile indices\r\n//     todo: that seems cool, will do when this one is working\r\nconst tilemap_programinfo = twgl.createProgramInfo(gl, [\r\n    // vs\r\n    `#version 300 es\r\n\r\n    // [0, 1]^2 (in other words, a quad)\r\n    in vec2 a_vertex;\r\n\r\n    // per-sprite data\r\n    in vec2 a_position;\r\n    in vec2 a_tileindex;\r\n\r\n    // global data\r\n    // sprites drawn at 0,0 will end in this clipspace position\r\n    uniform vec2 u_origin;\r\n    // sprites drawn at 1,1 will end in u_origin plus this clipspace position\r\n    uniform vec2 u_basis;\r\n    // number of sprites in the spritesheet\r\n    uniform vec2 u_sheet_count;\r\n\r\n    out vec2 v_texcoord;\r\n\r\n    void main() {\r\n        gl_Position = vec4(u_origin + (a_vertex + a_position) * u_basis, 0.0, 1.0);\r\n        v_texcoord = (a_tileindex + a_vertex) / u_sheet_count;\r\n    }\r\n    `,\r\n    // fs\r\n    `#version 300 es\r\n    precision highp float;\r\n    \r\n    in vec2 v_texcoord;\r\n\r\n    uniform sampler2D u_sheet;\r\n\r\n    out vec4 out_color;\r\n\r\n    void main() {\r\n        out_color = texture(u_sheet, v_texcoord);\r\n    }\r\n    `\r\n]);\r\n\r\nconst tilemap_texture = twgl.createTexture(gl, {\r\n    src: (new URL('walls_312.png', import.meta.url)).toString(),\r\n    mag: gl.NEAREST,\r\n    wrap: gl.REPEAT,\r\n});\r\n\r\nconst level_src = `\r\n####!!\r\n#.O#!!\r\n#..###\r\n#@P..#\r\n#..*.#\r\n#..###\r\n####!!\r\n`.trim();\r\n\r\nconst level_rows = level_src.split('\\n').map(r => r.trim());\r\nconst level_height = level_rows.length;\r\nconst level_width = level_rows[0].length;\r\nconsole.assert(level_rows.every(r => r.length == level_width), \"Bad ascii level\");\r\nconst level_walls = level_rows.map(r => r.split('').map(c => c == '#')).flat()\r\n\r\nfunction getWallAt(i: number, j: number): boolean {\r\n    if (i < 0 || i >= level_width || j < 0 || j >= level_height) {\r\n        return false\r\n    }\r\n    return level_walls[i + j * level_width];\r\n}\r\n\r\nfunction getTileIndex(i: number, j: number): [number, number] {\r\n    // Same numbering as http://www.cr31.co.uk/stagecast/wang/2corn.html\r\n    let tr_corner = getWallAt(i - 0, j - 1) ? 1 : 0;\r\n    let br_corner = getWallAt(i - 0, j - 0) ? 2 : 0;\r\n    let bl_corner = getWallAt(i - 1, j - 0) ? 4 : 0;\r\n    let tl_corner = getWallAt(i - 1, j - 1) ? 8 : 0;\r\n    let lookup_index = tl_corner + tr_corner + bl_corner + br_corner;\r\n    const lookup_table: [number, number][] = [\r\n        [0, 3], [0, 2], [1, 3], [1, 0],\r\n        [0, 0], [2, 3], [3, 0], [1, 1],\r\n        [3, 3], [1, 2], [0, 1], [2, 2],\r\n        [3, 2], [3, 1], [2, 0], [2, 1],\r\n    ];\r\n    return lookup_table[lookup_index];\r\n}\r\n\r\nconst tilemap_tilesize = 64;\r\nconst tilemap_width = level_width + 1;\r\nconst tilemap_height = level_height + 1;\r\nconst tilemap_data_cpu = new Float32Array(4 * tilemap_width * tilemap_height);\r\nfor (let j = 0; j < tilemap_height; j++) {\r\n    for (let i = 0; i < tilemap_width; i++) {\r\n        let k = (i + j * tilemap_width) * 4;\r\n        // x,y position; no tilemap specific logic\r\n        tilemap_data_cpu[k + 0] = i;\r\n        tilemap_data_cpu[k + 1] = j;\r\n        // actual tile to use, depends on the actual map state\r\n        let cur_index = getTileIndex(i, j);\r\n        tilemap_data_cpu[k + 2] = cur_index[0];\r\n        tilemap_data_cpu[k + 3] = cur_index[1];\r\n    }\r\n}\r\n\r\nconst tilemap_buffer = gl.createBuffer()!;\r\ngl.bindBuffer(gl.ARRAY_BUFFER, tilemap_buffer);\r\ngl.bufferData(gl.ARRAY_BUFFER, tilemap_data_cpu, gl.STATIC_DRAW);\r\n\r\nlet tilemap_vaoinfo = twgl.createVertexArrayInfo(gl, tilemap_programinfo, twgl.createBufferInfoFromArrays(gl, {\r\n    a_position: {\r\n        buffer: tilemap_buffer,\r\n        type: gl.FLOAT,\r\n        numComponents: 2,\r\n        stride: 4 * 4,\r\n        offset: 0 * 4,\r\n        divisor: 1,\r\n    },\r\n    a_tileindex: {\r\n        buffer: tilemap_buffer,\r\n        type: gl.FLOAT,\r\n        numComponents: 2,\r\n        stride: 4 * 4,\r\n        offset: 2 * 4,\r\n        divisor: 1,\r\n    },\r\n    a_vertex: {\r\n        data: [\r\n            // Triangle for 1,1 corner\r\n            1.0, 1.0,\r\n            0.0, 1.0,\r\n            1.0, 0.0,\r\n            // Triangle for 0,0 corner\r\n            0.0, 0.0,\r\n            1.0, 0.0,\r\n            0.0, 1.0,\r\n        ],\r\n        numComponents: 2,\r\n    },\r\n}))\r\n\r\n// raw version, unfinished - missing a_vertex & divisors.\r\nif (false) {\r\n    var vao = gl.createVertexArray()!;\r\n    gl.bindVertexArray(vao);\r\n    {\r\n        // @ts-ignore\r\n        let a_position_loc = tilemap_programinfo.attribSetters[\"a_position\"].location;\r\n        gl.enableVertexAttribArray(a_position_loc);\r\n        var size = 2;          // 2 components per iteration\r\n        var type = gl.FLOAT;   // the data is 32bit floats\r\n        var normalize = false; // don't normalize the data\r\n        var stride = 4 * 4;    // stride in bytes\r\n        var offset = 0 * 4;    // offset in bytes\r\n        gl.vertexAttribPointer(\r\n            a_position_loc, size, type, normalize, stride, offset);\r\n    }\r\n    {\r\n        // @ts-ignore\r\n        let a_tileindex_loc = tilemap_programinfo.attribSetters[\"a_tileindex\"].location;\r\n        gl.enableVertexAttribArray(a_tileindex_loc);\r\n        var size = 2;          // 2 components per iteration\r\n        var type = gl.FLOAT;   // the data is 32bit floats\r\n        var normalize = false; // don't normalize the data\r\n        var stride = 4 * 4;    // stride in bytes\r\n        var offset = 2 * 4;    // offset in bytes\r\n        gl.vertexAttribPointer(\r\n            a_tileindex_loc, size, type, normalize, stride, offset);\r\n    }\r\n}\r\n\r\nconst floor_texture = twgl.createTexture(gl, {\r\n    src: (new URL('floor_312.png', import.meta.url)).toString(),\r\n    mag: gl.NEAREST,\r\n    wrap: gl.REPEAT,\r\n});\r\n\r\nlet level_floors = level_rows.map(r => r.split('').map(c => c != '#' && c != '!')).flat()\r\n\r\n// Floor approach: only first fill N tiles\r\n// use same shader, or another? for now, let's keep the same one\r\nconst floormap_data_cpu = new Float32Array(4 * level_width * level_height);\r\nlet n_floors = 0;\r\nfor (let j = 0; j < level_height; j++) {\r\n    for (let i = 0; i < level_width; i++) {\r\n        if (level_floors[i + j * level_width]) {\r\n            // x,y position\r\n            floormap_data_cpu[n_floors * 4 + 0] = i;\r\n            floormap_data_cpu[n_floors * 4 + 1] = j;\r\n            // actual tile to use is always 0,0\r\n            tilemap_data_cpu[n_floors * 4 + 2] = 0;\r\n            tilemap_data_cpu[n_floors * 4 + 3] = 0;\r\n\r\n            n_floors += 1;\r\n        }\r\n    }\r\n}\r\n\r\nconst floormap_buffer = gl.createBuffer()!;\r\ngl.bindBuffer(gl.ARRAY_BUFFER, floormap_buffer);\r\ngl.bufferData(gl.ARRAY_BUFFER, floormap_data_cpu, gl.STATIC_DRAW);\r\n\r\n\r\nlet floormap_vaoinfo = twgl.createVertexArrayInfo(gl, tilemap_programinfo, twgl.createBufferInfoFromArrays(gl, {\r\n    a_position: {\r\n        buffer: floormap_buffer,\r\n        type: gl.FLOAT,\r\n        numComponents: 2,\r\n        stride: 4 * 4,\r\n        offset: 0 * 4,\r\n        divisor: 1,\r\n    },\r\n    a_tileindex: {\r\n        buffer: floormap_buffer,\r\n        type: gl.FLOAT,\r\n        numComponents: 2,\r\n        stride: 4 * 4,\r\n        offset: 2 * 4,\r\n        divisor: 1,\r\n    },\r\n    a_vertex: {\r\n        data: [\r\n            // Triangle for 1,1 corner\r\n            1.0, 1.0,\r\n            0.0, 1.0,\r\n            1.0, 0.0,\r\n            // Triangle for 0,0 corner\r\n            0.0, 0.0,\r\n            1.0, 0.0,\r\n            0.0, 1.0,\r\n        ],\r\n        numComponents: 2,\r\n    },\r\n}))\r\n\r\n// Player & boxes sprite drawing\r\n// can't use instancing since it can't offset into the attribute buffer\r\n// so we will use Shaku's style vertex buffers, sending 6 vertices per sprite instead of a single vec2 position :(\r\n// each vertex needs position, uv, depth?, color? for the moment, only pos (vec2) & uv (vec2)\r\n// Let's use sepparate buffers instead of interleaved, since they won't update with the same frequency\r\n// Vertices will be: top left, top right, bottom left, bottom right.\r\n// even with different textures, it's cool to have a single buffer, since we can draw subsets of it.\r\n// but it would be even cooler with atlas texture, @future: custom parcel plugin for auto atlas packing\r\n\r\nconst sprites_programinfo = twgl.createProgramInfo(gl, [\r\n    // vs\r\n    `#version 300 es\r\n\r\n    in vec2 a_position;\r\n    in vec2 a_texcoord;\r\n\r\n    // global data\r\n    // sprites drawn at 0,0 will end in this clipspace position\r\n    uniform vec2 u_origin;\r\n    // sprites drawn at 1,1 will end in u_origin plus this clipspace position\r\n    uniform vec2 u_basis;\r\n\r\n    out vec2 v_texcoord;\r\n\r\n    void main() {\r\n        gl_Position = vec4(u_origin + a_position * u_basis, 0.0, 1.0);\r\n        v_texcoord = a_texcoord;\r\n    }\r\n    `,\r\n    // fs\r\n    `#version 300 es\r\n    precision highp float;\r\n    \r\n    in vec2 v_texcoord;\r\n\r\n    uniform sampler2D u_texture;\r\n\r\n    out vec4 out_color;\r\n\r\n    void main() {\r\n        out_color = texture(u_texture, v_texcoord);\r\n    }\r\n    `\r\n]);\r\n\r\nconst max_n_sprites = 32;\r\nconsole.assert((max_n_sprites * 6) < (1 << 16), \"Can't draw that many sprites, change the code to use u32 indices.\");\r\n\r\nvar cur_n_sprites = 0;\r\nvar sprites_pos_cpu = new Float32Array(max_n_sprites * 2);\r\nvar sprites_uv_cpu = new Float32Array(max_n_sprites * 2);\r\n\r\nconst sprites_indices = new Uint16Array(max_n_sprites * 6);\r\nfor (let k = 0; k < max_n_sprites; k += 1) {\r\n    // top left triangle\r\n    sprites_indices[k * 6 + 0] = k * 4 + 0;\r\n    sprites_indices[k * 6 + 1] = k * 4 + 1;\r\n    sprites_indices[k * 6 + 2] = k * 4 + 2;\r\n    // bottom right triangle\r\n    sprites_indices[k * 6 + 3] = k * 4 + 1;\r\n    sprites_indices[k * 6 + 4] = k * 4 + 3;\r\n    sprites_indices[k * 6 + 5] = k * 4 + 2;\r\n}\r\n\r\nlet sprites_bufferinfo = twgl.createBufferInfoFromArrays(gl, {\r\n    a_position: {\r\n        data: sprites_pos_cpu,\r\n        numComponents: 2,\r\n        drawType: gl.DYNAMIC_DRAW,\r\n    },\r\n    a_texcoord: {\r\n        data: sprites_uv_cpu,\r\n        numComponents: 2,\r\n        drawType: gl.DYNAMIC_DRAW,\r\n    },\r\n    indices: {\r\n        data: sprites_indices,\r\n        drawType: gl.STATIC_DRAW,\r\n    },\r\n});\r\n\r\nconst sprites_pos_gpu = sprites_bufferinfo.attribs!.a_position.buffer;\r\nconst sprites_uv_gpu = sprites_bufferinfo.attribs!.a_texcoord.buffer;\r\n\r\nconst sprites_vaoinfo = twgl.createVertexArrayInfo(gl, sprites_programinfo, sprites_bufferinfo);\r\n\r\nconst player_texture = twgl.createTexture(gl, {\r\n    src: (new URL('player_puzzlescript.png', import.meta.url)).toString(),\r\n    mag: gl.NEAREST,\r\n    wrap: gl.REPEAT,\r\n});\r\n\r\nconst crate_texture = twgl.createTexture(gl, {\r\n    src: (new URL('crate_puzzlescript.png', import.meta.url)).toString(),\r\n    mag: gl.NEAREST,\r\n    wrap: gl.REPEAT,\r\n});\r\n\r\n\r\nlet game_state = {\r\n    debug_x: 0,\r\n    debug_y: 0,\r\n    player_pos: new Vec2(2, 3),\r\n    crates_pos: [\r\n        new Vec2(1, 3),\r\n        new Vec2(3, 4),\r\n    ]\r\n};\r\ntype GameState = typeof game_state;\r\n\r\n// Command: Any action that takes time & is undoable\r\n\r\nclass PlayerMoveCommand {\r\n    constructor(\r\n        public original_pos: Vec2,\r\n        public dir: Vec2,\r\n    ) { }\r\n\r\n    execute() {\r\n        Vec2.add(this.original_pos, this.dir, game_state.player_pos);\r\n    }\r\n\r\n    animTurn(turn_time: number) {\r\n        Vec2.add(this.original_pos, Vec2.scale(this.dir, turn_time), visual_state.player_sprite.position);\r\n        updateSpritePositionOrSize(visual_state.player_sprite);\r\n    }\r\n\r\n    undoAnimTurn(turn_time: number) {\r\n        this.animTurn(1.0 - turn_time);\r\n    }\r\n\r\n    undo() {\r\n        Vec2.copy(this.original_pos, game_state.player_pos);\r\n    }\r\n}\r\n\r\nclass PushCrateCommand {\r\n    extra_command: PlayerMoveCommand;\r\n\r\n    constructor(\r\n        public crate_index: number,\r\n        public original_pos: Vec2,\r\n        public dir: Vec2,\r\n    ) {\r\n        this.extra_command = new PlayerMoveCommand(Vec2.sub(original_pos, dir), dir);\r\n    }\r\n\r\n    execute() {\r\n        Vec2.add(this.original_pos, this.dir, game_state.crates_pos[this.crate_index]);\r\n        this.extra_command.execute();\r\n    }\r\n\r\n    animTurn(turn_time: number) {\r\n        Vec2.add(this.original_pos, Vec2.scale(this.dir, turn_time), visual_state.crates_sprites[this.crate_index].position);\r\n        updateSpritePositionOrSize(visual_state.crates_sprites[this.crate_index]);\r\n        this.extra_command.animTurn(turn_time);\r\n    }\r\n\r\n    undoAnimTurn(turn_time: number) {\r\n        // player moves backwards\r\n        this.extra_command.animTurn(1.0 - turn_time);\r\n        // crate pops into place\r\n        let tile_center = Vec2.add(this.original_pos, new Vec2(.5, .5));\r\n        if (turn_time < .5) {\r\n            Vec2.scale(Vec2.one, 1.0 - 2.0 * turn_time, visual_state.crates_sprites[this.crate_index].size);\r\n            Vec2.add(tile_center, this.dir, tile_center);\r\n        } else {\r\n            Vec2.scale(Vec2.one, 2.0 * turn_time - 1.0, visual_state.crates_sprites[this.crate_index].size);\r\n            Vec2.copy(this.original_pos, visual_state.crates_sprites[this.crate_index].position);\r\n        }\r\n        setSpriteCenter(visual_state.crates_sprites[this.crate_index], tile_center);\r\n        updateSpritePositionOrSize(visual_state.crates_sprites[this.crate_index]);\r\n    }\r\n\r\n    undo() {\r\n        Vec2.copy(this.original_pos, game_state.crates_pos[this.crate_index]);\r\n        this.extra_command.undo();\r\n    }\r\n}\r\n\r\nclass BumpWallCommand {\r\n    constructor(\r\n        public pos: Vec2,\r\n        public dir: Vec2,\r\n    ) { }\r\n\r\n    execute() {\r\n        throw new Error(\"not an executable command\");\r\n    }\r\n\r\n    animTurn(turn_time: number) {\r\n        let displacement = turn_time * (1 - turn_time);\r\n        Vec2.add(this.pos, Vec2.scale(this.dir, displacement), visual_state.player_sprite.position);\r\n        updateSpritePositionOrSize(visual_state.player_sprite);\r\n    }\r\n\r\n    undoAnimTurn(turn_time: number) {\r\n        throw new Error(\"not an undoable command\");\r\n    }\r\n\r\n    undo() {\r\n        throw new Error(\"not an undoable command\");\r\n    }\r\n}\r\n\r\n// todo: generic command\r\n// todo: BumpWallCommand is inherently very dirty :(\r\n// the solution would be to embrace logic & render separation, & have separate queues for logic commands & render commands\r\n\r\ntype Command = PlayerMoveCommand | PushCrateCommand | BumpWallCommand;\r\n\r\nlet command_history: Command[] = [];\r\n\r\nlet visual_state = {\r\n    turn_time: 0,\r\n    player_sprite: createSprite(\r\n        Vec2.copy(game_state.player_pos),\r\n        Vec2.copy(Vec2.one),\r\n        Vec2.copy(Vec2.zero),\r\n        Vec2.copy(Vec2.one),\r\n    ),\r\n    crates_sprites: game_state.crates_pos.map(crate_pos => {\r\n        return createSprite(\r\n            Vec2.copy(crate_pos),\r\n            Vec2.copy(Vec2.one),\r\n            Vec2.copy(Vec2.zero),\r\n            Vec2.copy(Vec2.one),\r\n        );\r\n    }),\r\n}\r\n\r\nlet cur_animating_command: null | Command = null;\r\nlet cur_animating_undo_command: null | Command = null;\r\n\r\nconst move_duration = .05;\r\n\r\n// player sprite data\r\n\r\ntype Sprite = {\r\n    buffer_index: number,\r\n    position: Vec2,\r\n    size: Vec2,\r\n    uv_pos: Vec2,\r\n    uv_size: Vec2,\r\n}\r\n\r\nfunction createSprite(pos: Vec2, size: Vec2, uv_pos: Vec2, uv_size: Vec2): Sprite {\r\n    let index = cur_n_sprites;\r\n    cur_n_sprites += 1;\r\n    let sprite: Sprite = {\r\n        buffer_index: index,\r\n        position: pos,\r\n        size: size,\r\n        uv_pos: uv_pos,\r\n        uv_size: uv_size,\r\n    }\r\n    updateSpritePositionOrSize(sprite);\r\n    updateSpriteUVs(sprite);\r\n    return sprite;\r\n}\r\n\r\nfunction setSpriteCenter(sprite: Sprite, center: Vec2) {\r\n    Vec2.sub(center, Vec2.scale(sprite.size, .5), sprite.position);\r\n}\r\n\r\nfunction updateSpritePositionOrSize(sprite: Sprite) {\r\n    // vertex positions \r\n    sprites_pos_cpu[sprite.buffer_index * 8 + 0] = sprite.position.x;\r\n    sprites_pos_cpu[sprite.buffer_index * 8 + 1] = sprite.position.y;\r\n\r\n    sprites_pos_cpu[sprite.buffer_index * 8 + 2] = sprite.position.x + sprite.size.x;\r\n    sprites_pos_cpu[sprite.buffer_index * 8 + 3] = sprite.position.y;\r\n\r\n    sprites_pos_cpu[sprite.buffer_index * 8 + 4] = sprite.position.x;\r\n    sprites_pos_cpu[sprite.buffer_index * 8 + 5] = sprite.position.y + sprite.size.x;\r\n\r\n    sprites_pos_cpu[sprite.buffer_index * 8 + 6] = sprite.position.x + sprite.size.x;\r\n    sprites_pos_cpu[sprite.buffer_index * 8 + 7] = sprite.position.y + sprite.size.x;\r\n}\r\n\r\nfunction updateSpriteUVs(sprite: Sprite) {\r\n    // vertex uv coordinates\r\n    sprites_uv_cpu[sprite.buffer_index * 8 + 0] = sprite.uv_pos.x;\r\n    sprites_uv_cpu[sprite.buffer_index * 8 + 1] = sprite.uv_pos.y;\r\n\r\n    sprites_uv_cpu[sprite.buffer_index * 8 + 2] = sprite.uv_pos.x + sprite.uv_size.x;\r\n    sprites_uv_cpu[sprite.buffer_index * 8 + 3] = sprite.uv_pos.y;\r\n\r\n    sprites_uv_cpu[sprite.buffer_index * 8 + 4] = sprite.uv_pos.x;\r\n    sprites_uv_cpu[sprite.buffer_index * 8 + 5] = sprite.uv_pos.y + sprite.uv_size.x;\r\n\r\n    sprites_uv_cpu[sprite.buffer_index * 8 + 6] = sprite.uv_pos.x + sprite.uv_size.x;\r\n    sprites_uv_cpu[sprite.buffer_index * 8 + 7] = sprite.uv_pos.y + sprite.uv_size.x;\r\n}\r\n\r\nlet input_state: {\r\n    pressed: Record<string, boolean>,\r\n    queued: string[],\r\n} = {\r\n    pressed: {},\r\n    queued: [],\r\n};\r\n\r\n\r\nlet loop_id = requestAnimationFrame(update);\r\ndocument.addEventListener(\"keydown\", onKeyDown);\r\ndocument.addEventListener(\"keyup\", onKeyUp);\r\n\r\nfunction onKeyDown(ev: KeyboardEvent) {\r\n    console.log(\"keydown\");\r\n    input_state.pressed[ev.code] = true;\r\n    input_state.queued.push(ev.code);\r\n}\r\n\r\nfunction onKeyUp(ev: KeyboardEvent) {\r\n    console.log(\"keyup\");\r\n    input_state.pressed[ev.code] = false;\r\n}\r\n\r\n\r\nlet time_last = 0;\r\nfunction update(time_cur: number) {\r\n    let delta = (time_cur - time_last) * 0.001;\r\n    time_last = time_cur;\r\n\r\n    if (twgl.resizeCanvasToDisplaySize(gl.canvas as HTMLCanvasElement)) {\r\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n    }\r\n\r\n    if (input_state.pressed[\"KeyA\"]) {\r\n        game_state.debug_x -= 1;\r\n    }\r\n    if (input_state.pressed[\"KeyD\"]) {\r\n        game_state.debug_x += 1;\r\n    }\r\n    if (input_state.pressed[\"KeyW\"]) {\r\n        game_state.debug_y -= 1;\r\n    }\r\n    if (input_state.pressed[\"KeyS\"]) {\r\n        game_state.debug_y += 1;\r\n    }\r\n\r\n    if (input_state.queued.length > 0 && cur_animating_command === null && cur_animating_undo_command === null) {\r\n        let cur_input = input_state.queued.shift();\r\n        if (cur_input == \"KeyZ\") {\r\n            if (command_history.length > 0) {\r\n                cur_animating_undo_command = command_history.pop()!;\r\n                cur_animating_undo_command.undo();\r\n                visual_state.turn_time = 0;\r\n            }\r\n        } else {\r\n            let player_delta = new Vec2()\r\n            switch (cur_input) {\r\n                case \"KeyD\":\r\n                    player_delta.x = 1;\r\n                    break;\r\n                case \"KeyA\":\r\n                    player_delta.x = -1;\r\n                    break;\r\n                case \"KeyW\":\r\n                    player_delta.y = -1;\r\n                    break;\r\n                case \"KeyS\":\r\n                    player_delta.y = 1;\r\n                    break;\r\n            }\r\n\r\n            if (player_delta.x != 0 || player_delta.y != 0) {\r\n                let new_player_pos = Vec2.add(game_state.player_pos, player_delta);\r\n                if (!getWallAt(new_player_pos.x, new_player_pos.y)) {\r\n                    let pushing_crate_index = game_state.crates_pos.findIndex(crate_pos => Vec2.equals(new_player_pos, crate_pos));\r\n                    if (pushing_crate_index == -1) {\r\n                        // Standard move\r\n                        cur_animating_command = new PlayerMoveCommand(Vec2.copy(game_state.player_pos), player_delta);\r\n                        cur_animating_command.execute()\r\n                        command_history.push(cur_animating_command);\r\n                    } else {\r\n                        // Try to push a crate\r\n                        let new_crate_pos = Vec2.add(game_state.crates_pos[pushing_crate_index], player_delta);\r\n                        let is_push_blocked = getWallAt(new_crate_pos.x, new_crate_pos.y)\r\n                            || game_state.crates_pos.some(crate_pos => Vec2.equals(new_crate_pos, crate_pos));\r\n                        if (!is_push_blocked) {\r\n                            // Push a crate\r\n                            cur_animating_command = new PushCrateCommand(pushing_crate_index, Vec2.copy(game_state.crates_pos[pushing_crate_index]), player_delta);\r\n                            cur_animating_command.execute()\r\n                            command_history.push(cur_animating_command);\r\n                        } else {\r\n                            cur_animating_command = new BumpWallCommand(game_state.player_pos, player_delta);\r\n                        }\r\n                    }\r\n                } else {\r\n                    cur_animating_command = new BumpWallCommand(game_state.player_pos, player_delta);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (cur_animating_command !== null) {\r\n        visual_state.turn_time += delta / move_duration;\r\n        visual_state.turn_time = clamp(visual_state.turn_time, 0, 1);\r\n        cur_animating_command.animTurn(visual_state.turn_time);\r\n        if (visual_state.turn_time >= 1) {\r\n            cur_animating_command = null;\r\n            visual_state.turn_time = 0;\r\n        }\r\n    } else if (cur_animating_undo_command !== null) {\r\n        visual_state.turn_time += delta / move_duration;\r\n        visual_state.turn_time = clamp(visual_state.turn_time, 0, 1);\r\n        cur_animating_undo_command.undoAnimTurn(visual_state.turn_time);\r\n        if (visual_state.turn_time >= 1) {\r\n            cur_animating_undo_command = null;\r\n            visual_state.turn_time = 0;\r\n        }\r\n    }\r\n\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n    // Debug temp stuff\r\n    gl.useProgram(sprite_program_info.program);\r\n    twgl.setBuffersAndAttributes(gl, sprite_program_info, sprite_vao);\r\n    twgl.setUniforms(sprite_program_info, {\r\n        u_texture: my_texture,\r\n        u_resolution: [gl.canvas.width, gl.canvas.height],\r\n        u_size: [50, 50],\r\n        u_position: [game_state.debug_x, game_state.debug_y],\r\n    });\r\n    twgl.drawBufferInfo(gl, sprite_buffer_info);\r\n\r\n    // walls\r\n    gl.useProgram(tilemap_programinfo.program);\r\n    gl.bindVertexArray(tilemap_vaoinfo.vertexArrayObject!);\r\n    twgl.setUniformsAndBindTextures(tilemap_programinfo, {\r\n        u_origin: [- tilemap_width * tilemap_tilesize / gl.canvas.width, tilemap_height * tilemap_tilesize / gl.canvas.height],\r\n        u_basis: [2 * tilemap_tilesize / gl.canvas.width, -2 * tilemap_tilesize / gl.canvas.height],\r\n        u_sheet_count: [4, 4],\r\n        u_sheet: tilemap_texture,\r\n    });\r\n    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, tilemap_width * tilemap_height);\r\n\r\n    // floors\r\n    gl.bindVertexArray(floormap_vaoinfo.vertexArrayObject!);\r\n    twgl.setUniformsAndBindTextures(tilemap_programinfo, {\r\n        u_origin: [- level_width * tilemap_tilesize / gl.canvas.width, level_height * tilemap_tilesize / gl.canvas.height],\r\n        u_basis: [2 * tilemap_tilesize / gl.canvas.width, -2 * tilemap_tilesize / gl.canvas.height],\r\n        u_sheet_count: [1, 1],\r\n        u_sheet: floor_texture,\r\n    });\r\n    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, n_floors);\r\n\r\n    // moving stuff:\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, sprites_pos_gpu);\r\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, sprites_pos_cpu);\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, sprites_uv_gpu);\r\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, sprites_uv_cpu);\r\n\r\n    gl.useProgram(sprites_programinfo.program)\r\n    gl.bindVertexArray(sprites_vaoinfo.vertexArrayObject!);\r\n\r\n    //  - player\r\n    twgl.setUniformsAndBindTextures(sprites_programinfo, {\r\n        u_origin: [- level_width * tilemap_tilesize / gl.canvas.width, level_height * tilemap_tilesize / gl.canvas.height],\r\n        u_basis: [2 * tilemap_tilesize / gl.canvas.width, -2 * tilemap_tilesize / gl.canvas.height],\r\n        u_texture: player_texture,\r\n    });\r\n    gl.drawElements(gl.TRIANGLES,\r\n        6, // 1 quad\r\n        gl.UNSIGNED_SHORT, visual_state.player_sprite.buffer_index * 12); // 12 bytes per quad\r\n\r\n    // - crates\r\n    twgl.setUniformsAndBindTextures(sprites_programinfo, {\r\n        u_origin: [- level_width * tilemap_tilesize / gl.canvas.width, level_height * tilemap_tilesize / gl.canvas.height],\r\n        u_basis: [2 * tilemap_tilesize / gl.canvas.width, -2 * tilemap_tilesize / gl.canvas.height],\r\n        u_texture: crate_texture,\r\n    });\r\n    gl.drawElements(gl.TRIANGLES,\r\n        6 * 2, // 2 quads\r\n        gl.UNSIGNED_SHORT, visual_state.crates_sprites[0].buffer_index * 12); // assume crate sprites are contiguous\r\n\r\n    loop_id = requestAnimationFrame(update);\r\n}\r\n","export function randomInt(low_inclusive: number, high_exclusive: number): number {\r\n    return low_inclusive + Math.floor(Math.random() * (high_exclusive - low_inclusive));\r\n}\r\n\r\nexport function max(arr: number[]) {\r\n    if (arr.length === 0) {\r\n        return undefined\r\n    }\r\n    return arr[argmax(arr)!];\r\n}\r\n\r\nexport function argmax(arr: number[]) {\r\n    if (arr.length === 0) {\r\n        return undefined\r\n    }\r\n    let res = 0;\r\n    let biggest = arr[0];\r\n    for (let k = 1; k < arr.length; k++) {\r\n        if (arr[k] > biggest) {\r\n            biggest = arr[k];\r\n            res = k;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function lerp(a: number, b: number, t: number): number {\r\n    return a * (1 - t) + b * t;\r\n}\r\n\r\nexport function towards(cur: number, target: number, max_delta: number): number {\r\n    if (cur > target) {\r\n        return Math.max(cur - max_delta, target);\r\n    } else if (cur < target) {\r\n        return Math.min(cur + max_delta, target);\r\n    } else {\r\n        return target;\r\n    }\r\n}\r\n\r\nexport function mod(n: number, m: number) {\r\n    return ((n % m) + m) % m;\r\n}\r\n\r\nexport function remap(value: number, old_a: number, old_b: number, new_a: number, new_b: number) {\r\n    let t = (value - old_a) / (old_b - old_a);\r\n    return t * (new_b - new_a) + new_a;\r\n}\r\n\r\nexport function randomChoice<T>(arr: T[]) {\r\n    if (arr.length === 0) {\r\n        throw new Error(\"can't choose out of an empty array\");\r\n    }\r\n    return arr[Math.floor(Math.random() * arr.length)];\r\n}\r\n\r\nexport function smoothstep(toZero: number, toOne: number, value: number) {\r\n    let x = Math.max(0, Math.min(1, (value - toZero) / (toOne - toZero)));\r\n    return x * x * (3 - 2 * x);\r\n};\r\n\r\nexport function clamp(value: number, min_inclusive: number, max_inclusive: number): number {\r\n    return Math.max(min_inclusive, Math.min(max_inclusive, value));\r\n}\r\n\r\nexport function inRange(value: number, min_inclusive: number, max_exclusive: number): boolean {\r\n    return value >= min_inclusive && value < max_exclusive;\r\n}\r\n\r\nexport function onBorder(value: number, min_inclusive: number, max_exclusive: number): boolean {\r\n    return value == min_inclusive || (value + 1) === max_exclusive;\r\n}\r\n\r\n// from https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\nexport function shuffle<T>(array: T[]) {\r\n    let currentIndex = array.length, randomIndex;\r\n    // While there remain elements to shuffle.\r\n    while (currentIndex != 0) {\r\n        // Pick a remaining element.\r\n        randomIndex = Math.floor(Math.random() * currentIndex);\r\n        currentIndex--;\r\n        // And swap it with the current element.\r\n        [array[currentIndex], array[randomIndex]] = [\r\n            array[randomIndex], array[currentIndex]];\r\n    }\r\n    return array;\r\n}\r\n\r\n\r\n// Use objects instead of arrays: https://jsben.ch/FgKVi\r\nexport class Vec4 {\r\n    constructor(\r\n        public x: number = 0.0,\r\n        public y: number = 0.0,\r\n        public z: number = 0.0,\r\n        public w: number = 0.0,\r\n    ) { }\r\n\r\n    static fromHex(hex_str: string): Vec4 {\r\n        // from https://stackoverflow.com/a/5624139\r\n        var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex_str);\r\n        if (result === null) {\r\n            throw new Error(`can't parse hex: ${hex_str}`);\r\n        }\r\n        return new Vec4(\r\n            parseInt(result[1], 16),\r\n            parseInt(result[2], 16),\r\n            parseInt(result[3], 16),\r\n            255,\r\n        );\r\n    }\r\n\r\n    static zero = new Vec4(0, 0, 0, 0);\r\n    static one = new Vec4(1, 1, 1, 1);\r\n}\r\n\r\ntype CardinalDirection = \"xpos\" | \"xneg\" | \"ypos\" | \"yneg\";\r\n\r\nexport class Vec2 {\r\n    constructor(\r\n        public x: number = 0.0,\r\n        public y: number = 0.0,\r\n    ) { }\r\n\r\n    toString(): string {\r\n        return `Vec2(${this.x}, ${this.y})`;\r\n    }\r\n\r\n    // scratchpad vectors, meant to be reused as intermediate values without allocation\r\n    static tmp = new Vec2(0, 0);\r\n    static tmp1 = new Vec2(0, 0);\r\n    static tmp2 = new Vec2(0, 0);\r\n    static tmp3 = new Vec2(0, 0);\r\n\r\n    static zero = new Vec2(0, 0);\r\n    static one = new Vec2(1, 1);\r\n\r\n    static set(v: Vec2, x: number, y: number): Vec2 {\r\n        v.x = x;\r\n        v.y = y;\r\n        return v;\r\n    }\r\n\r\n    static copy(v: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = v.x;\r\n        out.y = v.y;\r\n        return out;\r\n    }\r\n\r\n    static add(a: Vec2, b: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = a.x + b.x;\r\n        out.y = a.y + b.y;\r\n        return out;\r\n    }\r\n\r\n    static sub(a: Vec2, b: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = a.x - b.x;\r\n        out.y = a.y - b.y;\r\n        return out;\r\n    }\r\n\r\n    static mul(a: Vec2, b: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = a.x * b.x;\r\n        out.y = a.y * b.y;\r\n        return out;\r\n    }\r\n\r\n    static div(a: Vec2, b: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = a.x / b.x;\r\n        out.y = a.y / b.y;\r\n        return out;\r\n    }\r\n\r\n    static round(v: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = Math.round(v.x);\r\n        out.y = Math.round(v.y);\r\n        return out;\r\n    }\r\n\r\n    static negate(v: Vec2, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = -v.x;\r\n        out.y = -v.y;\r\n        return out;\r\n    }\r\n\r\n    static scale(v: Vec2, s: number, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = v.x * s;\r\n        out.y = v.y * s;\r\n        return out;\r\n    }\r\n\r\n    static lerp(a: Vec2, b: Vec2, t: number, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = a.x * (1 - t) + b.x * t;\r\n        out.y = a.y * (1 - t) + b.y * t;\r\n        return out;\r\n    }\r\n\r\n    static inBounds(point: Vec2, bounds: Vec2): boolean {\r\n        return inRange(point.x, 0, bounds.x) && inRange(point.y, 0, bounds.y);\r\n    }\r\n\r\n    // too niche for here?\r\n    static onBorder(point: Vec2, bounds: Vec2): boolean {\r\n        return onBorder(point.x, 0, bounds.x) || onBorder(point.y, 0, bounds.y);\r\n    }\r\n\r\n    static isZero(v: Vec2): boolean {\r\n        return v.x === 0 && v.y === 0;\r\n    }\r\n\r\n    static equals(a: Vec2, b: Vec2): boolean {\r\n        return a.x === b.x && a.y === b.y;\r\n    }\r\n\r\n    static map1(v: Vec2, fn: (x: number) => number, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = fn(v.x);\r\n        out.y = fn(v.y);\r\n        return out;\r\n    }\r\n\r\n    static map2(a: Vec2, b: Vec2, fn: (a: number, b: number) => number, out?: Vec2): Vec2 {\r\n        out = out || new Vec2();\r\n        out.x = fn(a.x, b.x);\r\n        out.y = fn(a.y, b.y);\r\n        return out;\r\n    }\r\n\r\n    static roundToCardinal(a: Vec2): CardinalDirection {\r\n        if (Math.abs(a.x) >= Math.abs(a.y)) {\r\n            if (a.x >= 0) {\r\n                return \"xpos\";\r\n            } else {\r\n                return \"xneg\";\r\n            }\r\n        } else {\r\n            if (a.y >= 0) {\r\n                return \"ypos\";\r\n            } else {\r\n                return \"yneg\";\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// todo: generalize, error check for too many args\r\nexport class Rectangle {\r\n    constructor(\r\n        public topLeft: Vec2,\r\n        public size: Vec2) { }\r\n\r\n    static fromParams(params: {\r\n        topLeft?: Vec2,\r\n        center?: Vec2,\r\n        bottomRight?: Vec2,\r\n        size?: Vec2,\r\n    }): Rectangle {\r\n        let topLeft = new Vec2();\r\n        let size = new Vec2();\r\n\r\n        if (params.topLeft !== undefined) {\r\n            Vec2.copy(params.topLeft, topLeft);\r\n            if (params.size !== undefined) {\r\n                Vec2.copy(params.size, size);\r\n            } else if (params.bottomRight !== undefined) {\r\n                Vec2.sub(params.bottomRight, topLeft, size);\r\n            } else if (params.center !== undefined) {\r\n                Vec2.sub(params.center, topLeft, size);\r\n                Vec2.scale(size, 2, size);\r\n            } else {\r\n                throw new Error(\"not enough data to compute rect\");\r\n            }\r\n            return new Rectangle(topLeft, size);\r\n        } else if (params.center !== undefined) {\r\n            if (params.size !== undefined) {\r\n                Vec2.copy(params.size, size);\r\n            } else if (params.bottomRight !== undefined) {\r\n                Vec2.sub(params.bottomRight, params.center, size);\r\n                Vec2.scale(size, 2, size);\r\n            } else {\r\n                throw new Error(\"not enough data to compute rect\");\r\n            }\r\n            Vec2.sub(params.center, Vec2.scale(size, .5), topLeft);\r\n            return new Rectangle(topLeft, size);\r\n        } else {\r\n            throw new Error(\"unimplemented\");\r\n        }\r\n    }\r\n}\r\n","#version 300 es\r\n\r\n// [0, 1]^2\r\nin vec2 a_vertex;\r\n\r\n// pixels for everything\r\nuniform vec2 u_resolution;\r\nuniform vec2 u_position;\r\nuniform vec2 u_size;\r\n\r\nout vec2 v_texcoord;\r\n\r\nvoid main() {\r\n    // if size is 100 & screen is 400, then\r\n    // clip space result width will be .5\r\n    vec2 pos = 2.0 * a_vertex * u_size / u_resolution;\r\n\r\n    // if position is 200 & screen is 400, then\r\n    // clip space result offset will be .5\r\n    pos += 2.0 * u_position / u_resolution;\r\n\r\n    // pos of 0 should go to the top left\r\n    pos -= vec2(1, 1);\r\n\r\n    // ypos = down\r\n    pos.y = -pos.y;\r\n\r\n    gl_Position = vec4(pos, 0, 1);\r\n\r\n    v_texcoord = a_vertex;\r\n}\r\n\r\n// todo: investigate glslify","#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 v_texcoord;\r\n\r\nuniform sampler2D u_texture;\r\n\r\nout vec4 out_color;\r\n\r\nvoid main() {\r\n    out_color = texture(u_texture, v_texcoord);\r\n}","module.exports = new __parcel__URL__(\"../\" + require('./helpers/bundle-manifest').resolve(\"5TaR7\")).toString();","module.exports = new __parcel__URL__(\"../\" + require('./helpers/bundle-manifest').resolve(\"6PWe3\")).toString();","module.exports = new __parcel__URL__(\"../\" + require('./helpers/bundle-manifest').resolve(\"5Oroq\")).toString();","module.exports = new __parcel__URL__(\"../\" + require('./helpers/bundle-manifest').resolve(\"gQMdV\")).toString();","module.exports = new __parcel__URL__(\"../\" + require('./helpers/bundle-manifest').resolve(\"8p6MJ\")).toString();"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$ef7689007096c8a0$export$6503ec6e8aabbaf","$ef7689007096c8a0$export$f7ad0328861e2f03","$ef7689007096c8a0$var$mapping","pairs","keys","i","length","resolved","JSON","parse","$amYBK","$5c4293b9a464b6e0$export$7d15b64cf5a3a4c4","value","min_inclusive","max_inclusive","Math","max","min","$5c4293b9a464b6e0$export$b973696b5f65b53b","constructor","x","y","z","w","fromHex","hex_str","result","exec","parseInt","_","zero","_1","one","$5c4293b9a464b6e0$export$ac4bca90992eed1","toString","tmp","tmp1","_2","tmp2","_3","tmp3","_4","_5","copy","out","add","b","sub","mul","div","round","negate","scale","lerp","t","inBounds","point","bounds","max_exclusive","$5c4293b9a464b6e0$export$ddf89a9c5af38f94","onBorder","$5c4293b9a464b6e0$export$66124ef7f3a58cb4","isZero","equals","map1","fn","map2","roundToCardinal","abs","$25fe13573bce6064$exports","$2ac028d4d6421c3a$exports","$80cc681c87a590bc$var$gl","document","querySelector","getContext","alpha","clearColor","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","resizeCanvasToDisplaySize","canvas","viewport","drawingBufferWidth","drawingBufferHeight","$d74783ac8623d055$exports","URL","resolve","url","$80cc681c87a590bc$var$my_texture","createTexture","src","$80cc681c87a590bc$var$sprite_program_info","createProgramInfo","$80cc681c87a590bc$var$sprite_buffer_info","createBufferInfoFromArrays","a_vertex","data","numComponents","$80cc681c87a590bc$var$sprite_vao","createVertexArrayInfo","$80cc681c87a590bc$var$tilemap_programinfo","$d14cc02d99730bca$exports","$80cc681c87a590bc$var$tilemap_texture","mag","NEAREST","wrap","REPEAT","$80cc681c87a590bc$var$level_src","trim","$80cc681c87a590bc$var$level_rows","split","map","r","$80cc681c87a590bc$var$level_height","$80cc681c87a590bc$var$level_width","console","assert","every","$80cc681c87a590bc$var$level_walls","c","flat","$80cc681c87a590bc$var$getWallAt","j","$80cc681c87a590bc$var$tilemap_width","$80cc681c87a590bc$var$tilemap_height","$80cc681c87a590bc$var$tilemap_data_cpu","Float32Array","k","cur_index","$80cc681c87a590bc$var$getTileIndex","tr_corner","br_corner","bl_corner","lookup_table","tl_corner","$80cc681c87a590bc$var$tilemap_buffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","$80cc681c87a590bc$var$tilemap_vaoinfo","a_position","buffer","type","FLOAT","stride","offset","divisor","a_tileindex","$6b51d33817ed6c9b$exports","$80cc681c87a590bc$var$floor_texture","$80cc681c87a590bc$var$level_floors","$80cc681c87a590bc$var$floormap_data_cpu","$80cc681c87a590bc$var$n_floors","$80cc681c87a590bc$var$floormap_buffer","$80cc681c87a590bc$var$floormap_vaoinfo","$80cc681c87a590bc$var$sprites_programinfo","$80cc681c87a590bc$var$max_n_sprites","$80cc681c87a590bc$var$cur_n_sprites","$80cc681c87a590bc$var$sprites_pos_cpu","$80cc681c87a590bc$var$sprites_uv_cpu","$80cc681c87a590bc$var$sprites_indices","Uint16Array","$80cc681c87a590bc$var$sprites_bufferinfo","drawType","DYNAMIC_DRAW","a_texcoord","indices","$80cc681c87a590bc$var$sprites_pos_gpu","attribs","$80cc681c87a590bc$var$sprites_uv_gpu","$80cc681c87a590bc$var$sprites_vaoinfo","$8493c613161e864d$exports","$80cc681c87a590bc$var$player_texture","$7826d88a0ae564d0$exports","$80cc681c87a590bc$var$crate_texture","$80cc681c87a590bc$var$game_state","debug_x","debug_y","player_pos","crates_pos","$80cc681c87a590bc$var$PlayerMoveCommand","original_pos","dir","execute","animTurn","turn_time","$80cc681c87a590bc$var$visual_state","player_sprite","position","$80cc681c87a590bc$var$updateSpritePositionOrSize","undoAnimTurn","undo","$80cc681c87a590bc$var$PushCrateCommand","crate_index","extra_command","crates_sprites","sprite","tile_center","size","$80cc681c87a590bc$var$BumpWallCommand","pos","$80cc681c87a590bc$var$command_history","$80cc681c87a590bc$var$createSprite","crate_pos","$80cc681c87a590bc$var$cur_animating_command","$80cc681c87a590bc$var$cur_animating_undo_command","uv_pos","uv_size","index","buffer_index","$80cc681c87a590bc$var$input_state","pressed","queued","requestAnimationFrame","$80cc681c87a590bc$var$update","time_cur","delta","$80cc681c87a590bc$var$time_last","cur_input","shift","pop","player_delta","new_player_pos","pushing_crate_index","findIndex","push","new_crate_pos","some","clear","COLOR_BUFFER_BIT","useProgram","program","setBuffersAndAttributes","setUniforms","u_texture","u_resolution","width","height","u_size","u_position","drawBufferInfo","bindVertexArray","vertexArrayObject","setUniformsAndBindTextures","u_origin","u_basis","u_sheet_count","u_sheet","drawArraysInstanced","TRIANGLES","bufferSubData","drawElements","UNSIGNED_SHORT","addEventListener","ev","log"],"version":3,"file":"index.d232555d.js.map"}