{"mappings":"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","sources":["<anon>","probPoolOracle/main.ts","node_modules/stats.js/build/stats.min.js","kommon/kommon.ts"],"sourcesContent":["(function () {\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire94c2\"] = parcelRequire;\n}\n\nvar $6MzNI = parcelRequire(\"6MzNI\");\nvar $a759912a70d9e191$exports = {};\n// stats.js - http://github.com/mrdoob/stats.js\n(function(f, e) {\n    $a759912a70d9e191$exports = e();\n})($a759912a70d9e191$exports, function() {\n    var f = function() {\n        function e(a) {\n            c.appendChild(a.dom);\n            return a;\n        }\n        function u(a) {\n            for(var d = 0; d < c.children.length; d++)c.children[d].style.display = d === a ? \"block\" : \"none\";\n            l = a;\n        }\n        var l = 0, c = document.createElement(\"div\");\n        c.style.cssText = \"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";\n        c.addEventListener(\"click\", function(a) {\n            a.preventDefault();\n            u(++l % c.children.length);\n        }, !1);\n        var k = (performance || Date).now(), g = k, a = 0, r = e(new f.Panel(\"FPS\", \"#0ff\", \"#002\")), h = e(new f.Panel(\"MS\", \"#0f0\", \"#020\"));\n        if (self.performance && self.performance.memory) var t = e(new f.Panel(\"MB\", \"#f08\", \"#201\"));\n        u(0);\n        return {\n            REVISION: 16,\n            dom: c,\n            addPanel: e,\n            showPanel: u,\n            begin: function() {\n                k = (performance || Date).now();\n            },\n            end: function() {\n                a++;\n                var c = (performance || Date).now();\n                h.update(c - k, 200);\n                if (c > g + 1E3 && (r.update(1E3 * a / (c - g), 100), g = c, a = 0, t)) {\n                    var d = performance.memory;\n                    t.update(d.usedJSHeapSize / 1048576, d.jsHeapSizeLimit / 1048576);\n                }\n                return c;\n            },\n            update: function() {\n                k = this.end();\n            },\n            domElement: c,\n            setMode: u\n        };\n    };\n    f.Panel = function(e, f, l) {\n        var c = Infinity, k = 0, g = Math.round, a = g(window.devicePixelRatio || 1), r = 80 * a, h = 48 * a, t = 3 * a, v = 2 * a, d = 3 * a, m = 15 * a, n = 74 * a, p = 30 * a, q = document.createElement(\"canvas\");\n        q.width = r;\n        q.height = h;\n        q.style.cssText = \"width:80px;height:48px\";\n        var b = q.getContext(\"2d\");\n        b.font = \"bold \" + 9 * a + \"px Helvetica,Arial,sans-serif\";\n        b.textBaseline = \"top\";\n        b.fillStyle = l;\n        b.fillRect(0, 0, r, h);\n        b.fillStyle = f;\n        b.fillText(e, t, v);\n        b.fillRect(d, m, n, p);\n        b.fillStyle = l;\n        b.globalAlpha = .9;\n        b.fillRect(d, m, n, p);\n        return {\n            dom: q,\n            update: function(h, w) {\n                c = Math.min(c, h);\n                k = Math.max(k, h);\n                b.fillStyle = l;\n                b.globalAlpha = 1;\n                b.fillRect(0, 0, r, m);\n                b.fillStyle = f;\n                b.fillText(g(h) + \" \" + e + \" (\" + g(c) + \"-\" + g(k) + \")\", t, v);\n                b.drawImage(q, d + a, m, n - a, p, d, m, n - a, p);\n                b.fillRect(d + n - a, m, a, p);\n                b.fillStyle = l;\n                b.globalAlpha = .9;\n                b.fillRect(d + n - a, m, a, g((1 - h / w) * p));\n            }\n        };\n    };\n    return f;\n});\n\n\nfunction $e28a0cada894885c$export$9f0c37400c701bee(n, callback) {\n    let result = Array(n);\n    for(let k = 0; k < n; k++)result[k] = callback(k);\n    return result;\n}\nfunction $e28a0cada894885c$export$f01e84010c13cebe(lo, hi, callback) {\n    let count = hi - lo;\n    let result = Array(count);\n    for(let k = 0; k < count; k++)result[k] = callback(k + lo);\n    return result;\n}\nfunction* $e28a0cada894885c$export$8901015135f2fb22(...arrays) {\n    let iterators = arrays.map((a)=>a[Symbol.iterator]());\n    while(true){\n        let nexts = iterators.map((a)=>a.next());\n        let done = nexts.some((n)=>n.done);\n        if (done) return;\n        yield nexts.map((n)=>n.value);\n    }\n}\nfunction $e28a0cada894885c$export$58aefef1ff9edd34(object, map_fn) {\n    let result = {};\n    for (let [k, v] of Object.entries(object))result[k] = map_fn(v);\n    return result;\n}\nclass $e28a0cada894885c$export$9341a022b2e0184a {\n    constructor(init_fn){\n        // typing doesn't work :(\n        let target = {};\n        return new Proxy(target, {\n            get: (target, name)=>{\n                if (name in target) return target[name];\n                else {\n                    target[name] = init_fn();\n                    return target[name];\n                }\n            }\n        });\n    }\n}\n\n\nvar $20a75b51695be07d$var$stats = new (0, (/*@__PURE__*/$parcel$interopDefault($a759912a70d9e191$exports)))();\n$20a75b51695be07d$var$stats.showPanel(0);\ndocument.body.appendChild($20a75b51695be07d$var$stats.dom);\n//// init\nconst $20a75b51695be07d$var$canvas = document.querySelector(\"#c\");\nconst $20a75b51695be07d$var$gl = $20a75b51695be07d$var$canvas.getContext(\"webgl2\", {\n    alpha: false\n});\n$20a75b51695be07d$var$gl.clearColor(0.5, 0.5, 0.75, 1.0);\n$20a75b51695be07d$var$gl.enable($20a75b51695be07d$var$gl.BLEND);\n$20a75b51695be07d$var$gl.blendFunc($20a75b51695be07d$var$gl.SRC_ALPHA, $20a75b51695be07d$var$gl.ONE_MINUS_SRC_ALPHA);\n// game logic\nconst $20a75b51695be07d$var$use_gpu = false;\nconst $20a75b51695be07d$var$n_updates = 100;\nconst $20a75b51695be07d$var$n_universes = 500;\nconst $20a75b51695be07d$var$n_balls = 4;\nconst $20a75b51695be07d$var$ball_r = .05;\nconst $20a75b51695be07d$var$chaos = .01;\nconst $20a75b51695be07d$var$update_program = $6MzNI.createProgramFromSources($20a75b51695be07d$var$gl, [\n    // vs\n    `#version 300 es\r\n\r\n    precision highp float;\r\n\r\n    #define ball_r ${$20a75b51695be07d$var$ball_r.toFixed(10)}\r\n    #define bounce .9\r\n    #define drag .99\r\n    #define dt 0.01\r\n\r\n    ${(0, $e28a0cada894885c$export$9f0c37400c701bee)($20a75b51695be07d$var$n_balls, (i)=>{\n        return `in vec4 old_b${i}; out vec4 new_b${i};`;\n    }).join(\"\\n\")}\r\n\r\n    uniform vec2 u_impulse;\r\n\r\n    // pos, vel for each ball\r\n    void collide(in vec4 b1, in vec4 b2, out vec4 r1, out vec4 r2) {\r\n        r1 = b1;\r\n        r2 = b2;\r\n\r\n        vec2 delta = b1.xy - b2.xy;\r\n        float distSq = dot(delta, delta);\r\n        if (distSq > 0.0 && distSq < 4.0 * ball_r * ball_r) {\r\n            float dist = sqrt(distSq);\r\n            // assumption: all balls have the same mass\r\n            // intuition: the balls exchange their momentum\r\n            // but only on the direction joining them\r\n\r\n            // 1. avoid overlap\r\n            float push = (2.0 * ball_r - dist) * .5 * bounce / dist;\r\n            r1.xy += delta * push;\r\n            r2.xy -= delta * push;\r\n\r\n            // 2. exchange momentums\r\n            vec2 momentum = delta * (dot(delta, b1.zw) - dot(delta, b2.zw)) / distSq;\r\n            r1.zw -= momentum;\r\n            r2.zw += momentum;\r\n        }        \r\n    }\r\n\r\n    vec4 individualUpdate(vec4 ball) {\r\n        // movement\r\n        vec4 res = vec4(ball.xy + dt * ball.zw, ball.zw);\r\n        // bounce\r\n        if (abs(res.x) > 1.0 - ball_r) {\r\n            res.x = sign(res.x) * (2.0 - 2.0 * ball_r) - ball.x;\r\n            res.z = -ball.z;\r\n        }\r\n        if (abs(res.y) > 1.0 - ball_r) {\r\n            res.y = sign(res.y) * (2.0 - 2.0 * ball_r) - ball.y;\r\n            res.w = -ball.w;\r\n        }\r\n        // drag\r\n        res.zw *= drag;\r\n        return res;\r\n    }\r\n\r\n    void main() {\r\n        new_b0 = individualUpdate(vec4(old_b0.xy, old_b0.zw + u_impulse));\r\n    ${(0, $e28a0cada894885c$export$f01e84010c13cebe)(1, $20a75b51695be07d$var$n_balls, (i)=>{\n        return `new_b${i} = individualUpdate(old_b${i});`;\n    }).join(\"\\n\")}\r\n        // collision\r\n        // generate this code:\r\n        // collide(new_b0, new_b1, new_b0, new_b1);\r\n        // collide(0, 2) ...\r\n        // collide(0, n_balls-1)\r\n        // collide(1, 2) ...\r\n        // collide(1, n_balls-1)\r\n        // ...\r\n        // collide(n_balls - 2, n_balls-1)\r\n    ${(0, $e28a0cada894885c$export$f01e84010c13cebe)(0, $20a75b51695be07d$var$n_balls, (i)=>{\n        return (0, $e28a0cada894885c$export$f01e84010c13cebe)(i + 1, $20a75b51695be07d$var$n_balls, (j)=>{\n            return `collide(new_b${i}, new_b${j}, new_b${i}, new_b${j});`;\n        }).join(\"\\n\");\n    }).join(\"\\n\")}\r\n    }\r\n    `,\n    // fs\n    `#version 300 es\r\n    precision highp float;\r\n\r\n    void main() {}\r\n    `\n], {\n    transformFeedbackVaryings: (0, $e28a0cada894885c$export$f01e84010c13cebe)(0, $20a75b51695be07d$var$n_balls, (k)=>`new_b${k}`),\n    transformFeedbackMode: $20a75b51695be07d$var$gl.INTERLEAVED_ATTRIBS\n});\nconst $20a75b51695be07d$var$ball_start_pos = (0, $e28a0cada894885c$export$9f0c37400c701bee)($20a75b51695be07d$var$n_balls, (k)=>[\n        (Math.random() - .5) * (2 - $20a75b51695be07d$var$ball_r),\n        (Math.random() - .5) * (2 - $20a75b51695be07d$var$ball_r)\n    ]);\n// const ball_start_pos = [\n//     [.5, 0],\n//     [0, ball_r],\n//     [0, -ball_r],\n//     [-Math.sqrt(3) * ball_r, 0],\n// ]\n// px,py,vx,vy for each ball\n// [b0px,b0py,b0vx,b0vy,b1...,b2...,b0px,b0py,b0vx,b0vy,b1...,b2...,....]\nconst $20a75b51695be07d$var$balldata_cpu = new Float32Array($20a75b51695be07d$var$n_universes * $20a75b51695be07d$var$n_balls * 4);\nfor(let b = 0; b < $20a75b51695be07d$var$n_balls; b++)for(let k = 0; k < $20a75b51695be07d$var$n_universes; k++){\n    let base_index = (k * $20a75b51695be07d$var$n_balls + b) * 4;\n    $20a75b51695be07d$var$balldata_cpu[base_index + 0] = $20a75b51695be07d$var$ball_start_pos[b][0];\n    $20a75b51695be07d$var$balldata_cpu[base_index + 1] = $20a75b51695be07d$var$ball_start_pos[b][1];\n}\n// initial chaos\nfor(let k = 0; k < $20a75b51695be07d$var$n_universes; k++){\n    const ang = Math.PI * 2 * k / $20a75b51695be07d$var$n_universes;\n    $20a75b51695be07d$var$balldata_cpu[k * $20a75b51695be07d$var$n_balls * 4 + 0] += Math.cos(ang) * $20a75b51695be07d$var$chaos;\n    $20a75b51695be07d$var$balldata_cpu[k * $20a75b51695be07d$var$n_balls * 4 + 1] += Math.sin(ang) * $20a75b51695be07d$var$chaos;\n}\n// double buffer pattern\nconst $20a75b51695be07d$var$balldata_gpu_1 = $6MzNI.createBufferFromTypedArray($20a75b51695be07d$var$gl, $20a75b51695be07d$var$balldata_cpu, $20a75b51695be07d$var$gl.ARRAY_BUFFER, $20a75b51695be07d$var$gl.DYNAMIC_DRAW);\nconst $20a75b51695be07d$var$balldata_gpu_2 = $6MzNI.createBufferFromTypedArray($20a75b51695be07d$var$gl, $20a75b51695be07d$var$balldata_cpu, $20a75b51695be07d$var$gl.ARRAY_BUFFER, $20a75b51695be07d$var$gl.DYNAMIC_DRAW);\nconst $20a75b51695be07d$var$draw_pinfo = $6MzNI.createProgramInfo($20a75b51695be07d$var$gl, [\n    // vs\n    `#version 300 es\r\n\r\n    #define n_balls ${$20a75b51695be07d$var$n_balls.toFixed(10)}\r\n\r\n    in vec2 pos;\r\n\r\n    out vec3 v_ball_color;\r\n\r\n    vec3 hsl2rgb(in vec3 c) {\r\n        vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\r\n        return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\r\n    }\r\n\r\n\r\n    void main() {\r\n        gl_Position = vec4(pos, 0.0, 1.0);\r\n        gl_PointSize = ${($20a75b51695be07d$var$gl.canvas.width * 2 * $20a75b51695be07d$var$ball_r).toFixed(10)};\r\n        v_ball_color = hsl2rgb(vec3(float(gl_VertexID) / n_balls, 0.85, 0.5));\r\n        // v_ball_color = mix(vec3(1.0, 0, 0), vec3(0.0, 1, 0), mod(float(gl_VertexID), n_balls) / n_balls);\r\n    }\r\n    `,\n    // fs\n    `#version 300 es\r\n    precision highp float;\r\n\r\n    in vec3 v_ball_color;\r\n\r\n    out vec4 out_color;\r\n    \r\n    void main() {\r\n        float distSq = dot(gl_PointCoord - .5, gl_PointCoord - .5);\r\n        float alpha = smoothstep(.25, .20, distSq);\r\n        float outline = smoothstep(.27, .20, distSq);\r\n        out_color = vec4(v_ball_color * outline, alpha * .1);\r\n    }\r\n    `\n]);\nconst $20a75b51695be07d$var$draw_1_vao = $6MzNI.createVertexArrayInfo($20a75b51695be07d$var$gl, $20a75b51695be07d$var$draw_pinfo, $6MzNI.createBufferInfoFromArrays($20a75b51695be07d$var$gl, {\n    pos: {\n        buffer: $20a75b51695be07d$var$balldata_gpu_1,\n        numComponents: 2,\n        stride: 16,\n        type: Float32Array\n    }\n}));\nconst $20a75b51695be07d$var$draw_2_vao = $6MzNI.createVertexArrayInfo($20a75b51695be07d$var$gl, $20a75b51695be07d$var$draw_pinfo, $6MzNI.createBufferInfoFromArrays($20a75b51695be07d$var$gl, {\n    pos: {\n        buffer: $20a75b51695be07d$var$balldata_gpu_2,\n        numComponents: 2,\n        stride: 16,\n        type: Float32Array\n    }\n}));\nconst $20a75b51695be07d$var$u_impulse_loc = $20a75b51695be07d$var$gl.getUniformLocation($20a75b51695be07d$var$update_program, \"u_impulse\");\nconst $20a75b51695be07d$var$old_b_locs = (0, $e28a0cada894885c$export$9f0c37400c701bee)($20a75b51695be07d$var$n_balls, (k)=>{\n    return $20a75b51695be07d$var$gl.getAttribLocation($20a75b51695be07d$var$update_program, `old_b${k}`);\n});\nconst $20a75b51695be07d$var$vao_update_1to2 = $20a75b51695be07d$var$gl.createVertexArray();\n$20a75b51695be07d$var$gl.bindVertexArray($20a75b51695be07d$var$vao_update_1to2);\n$20a75b51695be07d$var$gl.bindBuffer($20a75b51695be07d$var$gl.ARRAY_BUFFER, $20a75b51695be07d$var$balldata_gpu_1);\nfor(let k = 0; k < $20a75b51695be07d$var$n_balls; k++){\n    $20a75b51695be07d$var$gl.enableVertexAttribArray($20a75b51695be07d$var$old_b_locs[k]);\n    $20a75b51695be07d$var$gl.vertexAttribPointer($20a75b51695be07d$var$old_b_locs[k], 4, $20a75b51695be07d$var$gl.FLOAT, false, $20a75b51695be07d$var$n_balls * 16, 16 * k);\n}\nconst $20a75b51695be07d$var$vao_update_2to1 = $20a75b51695be07d$var$gl.createVertexArray();\n$20a75b51695be07d$var$gl.bindVertexArray($20a75b51695be07d$var$vao_update_2to1);\n$20a75b51695be07d$var$gl.bindBuffer($20a75b51695be07d$var$gl.ARRAY_BUFFER, $20a75b51695be07d$var$balldata_gpu_2);\nfor(let k = 0; k < $20a75b51695be07d$var$n_balls; k++){\n    $20a75b51695be07d$var$gl.enableVertexAttribArray($20a75b51695be07d$var$old_b_locs[k]);\n    $20a75b51695be07d$var$gl.vertexAttribPointer($20a75b51695be07d$var$old_b_locs[k], 4, $20a75b51695be07d$var$gl.FLOAT, false, $20a75b51695be07d$var$n_balls * 16, 16 * k);\n}\n$20a75b51695be07d$var$gl.bindVertexArray(null);\nconst $20a75b51695be07d$var$tf_2to1 = $20a75b51695be07d$var$gl.createTransformFeedback();\n$20a75b51695be07d$var$gl.bindTransformFeedback($20a75b51695be07d$var$gl.TRANSFORM_FEEDBACK, $20a75b51695be07d$var$tf_2to1);\n$20a75b51695be07d$var$gl.bindBufferBase($20a75b51695be07d$var$gl.TRANSFORM_FEEDBACK_BUFFER, 0, $20a75b51695be07d$var$balldata_gpu_1);\nconst $20a75b51695be07d$var$tf_1to2 = $20a75b51695be07d$var$gl.createTransformFeedback();\n$20a75b51695be07d$var$gl.bindTransformFeedback($20a75b51695be07d$var$gl.TRANSFORM_FEEDBACK, $20a75b51695be07d$var$tf_1to2);\n$20a75b51695be07d$var$gl.bindBufferBase($20a75b51695be07d$var$gl.TRANSFORM_FEEDBACK_BUFFER, 0, $20a75b51695be07d$var$balldata_gpu_2);\n// unbind left over stuff\n$20a75b51695be07d$var$gl.bindTransformFeedback($20a75b51695be07d$var$gl.TRANSFORM_FEEDBACK, null);\n$20a75b51695be07d$var$gl.bindBuffer($20a75b51695be07d$var$gl.ARRAY_BUFFER, null);\nlet $20a75b51695be07d$var$buffers_1to2 = {\n    update_vao: $20a75b51695be07d$var$vao_update_1to2,\n    tf: $20a75b51695be07d$var$tf_1to2,\n    draw_vao: $20a75b51695be07d$var$draw_2_vao.vertexArrayObject\n};\nlet $20a75b51695be07d$var$buffers_2to1 = {\n    update_vao: $20a75b51695be07d$var$vao_update_2to1,\n    tf: $20a75b51695be07d$var$tf_2to1,\n    draw_vao: $20a75b51695be07d$var$draw_1_vao.vertexArrayObject\n};\nlet $20a75b51695be07d$var$last_click_pos = null;\nlet $20a75b51695be07d$var$theoretical_impulse = [\n    0,\n    0\n];\nlet $20a75b51695be07d$var$apply_impulse = false;\ndocument.addEventListener(\"mousedown\", (ev)=>{\n    $20a75b51695be07d$var$last_click_pos = [\n        ev.offsetX,\n        ev.offsetY\n    ];\n});\ndocument.addEventListener(\"mouseup\", (ev)=>{\n    $20a75b51695be07d$var$apply_impulse = true;\n    $20a75b51695be07d$var$last_click_pos = null;\n});\ndocument.addEventListener(\"mousemove\", (ev)=>{\n    if ($20a75b51695be07d$var$last_click_pos !== null) {\n        let cur_pos = [\n            ev.offsetX,\n            ev.offsetY\n        ];\n        const force = .01;\n        $20a75b51695be07d$var$theoretical_impulse = [\n            -(cur_pos[0] - $20a75b51695be07d$var$last_click_pos[0]) * force,\n            (cur_pos[1] - $20a75b51695be07d$var$last_click_pos[1]) * force\n        ];\n    }\n});\nlet $20a75b51695be07d$var$balldata_cpu_helper = new Float32Array($20a75b51695be07d$var$balldata_cpu.length);\nlet $20a75b51695be07d$var$last_time = 0;\nfunction $20a75b51695be07d$var$update(cur_time) {\n    $20a75b51695be07d$var$stats.update();\n    if ($6MzNI.resizeCanvasToDisplaySize($20a75b51695be07d$var$canvas)) // on resize\n    $20a75b51695be07d$var$gl.viewport(0, 0, $20a75b51695be07d$var$gl.drawingBufferWidth, $20a75b51695be07d$var$gl.drawingBufferHeight);\n    let delta = cur_time - $20a75b51695be07d$var$last_time;\n    $20a75b51695be07d$var$last_time = cur_time;\n    $20a75b51695be07d$var$gl.clear($20a75b51695be07d$var$gl.COLOR_BUFFER_BIT);\n    // ground truth is the cpu\n    if ($20a75b51695be07d$var$use_gpu) {\n        // copy cpu to gpu\n        $20a75b51695be07d$var$gl.bindBuffer($20a75b51695be07d$var$gl.ARRAY_BUFFER, $20a75b51695be07d$var$balldata_gpu_1);\n        $20a75b51695be07d$var$gl.bufferSubData($20a75b51695be07d$var$gl.ARRAY_BUFFER, 0, $20a75b51695be07d$var$balldata_cpu);\n        $20a75b51695be07d$var$gl.bindBuffer($20a75b51695be07d$var$gl.ARRAY_BUFFER, null);\n        // do a single update...\n        $20a75b51695be07d$var$gl.useProgram($20a75b51695be07d$var$update_program);\n        $20a75b51695be07d$var$gl.enable($20a75b51695be07d$var$gl.RASTERIZER_DISCARD);\n        $20a75b51695be07d$var$gl.bindVertexArray($20a75b51695be07d$var$vao_update_1to2);\n        if ($20a75b51695be07d$var$apply_impulse) {\n            $20a75b51695be07d$var$gl.uniform2f($20a75b51695be07d$var$u_impulse_loc, $20a75b51695be07d$var$theoretical_impulse[0], $20a75b51695be07d$var$theoretical_impulse[1]);\n            $20a75b51695be07d$var$apply_impulse = false;\n            $20a75b51695be07d$var$theoretical_impulse = [\n                0,\n                0\n            ];\n        } else $20a75b51695be07d$var$gl.uniform2f($20a75b51695be07d$var$u_impulse_loc, 0, 0);\n        $20a75b51695be07d$var$gl.bindTransformFeedback($20a75b51695be07d$var$gl.TRANSFORM_FEEDBACK, $20a75b51695be07d$var$tf_1to2);\n        $20a75b51695be07d$var$gl.beginTransformFeedback($20a75b51695be07d$var$gl.POINTS);\n        $20a75b51695be07d$var$gl.drawArrays($20a75b51695be07d$var$gl.POINTS, 0, $20a75b51695be07d$var$n_universes);\n        $20a75b51695be07d$var$gl.endTransformFeedback();\n        $20a75b51695be07d$var$gl.disable($20a75b51695be07d$var$gl.RASTERIZER_DISCARD);\n        $20a75b51695be07d$var$gl.bindTransformFeedback($20a75b51695be07d$var$gl.TRANSFORM_FEEDBACK, null);\n        // ...and copy the result back to the cpu\n        $20a75b51695be07d$var$gl.bindBuffer($20a75b51695be07d$var$gl.ARRAY_BUFFER, $20a75b51695be07d$var$balldata_gpu_2);\n        $20a75b51695be07d$var$gl.getBufferSubData($20a75b51695be07d$var$gl.ARRAY_BUFFER, 0, $20a75b51695be07d$var$balldata_cpu);\n        $20a75b51695be07d$var$gl.bindBuffer($20a75b51695be07d$var$gl.ARRAY_BUFFER, null);\n        // draw the present\n        $20a75b51695be07d$var$gl.useProgram($20a75b51695be07d$var$draw_pinfo.program);\n        $20a75b51695be07d$var$gl.bindVertexArray($20a75b51695be07d$var$draw_2_vao.vertexArrayObject);\n        $20a75b51695be07d$var$gl.drawArrays($20a75b51695be07d$var$gl.POINTS, 0, $20a75b51695be07d$var$n_universes * $20a75b51695be07d$var$n_balls);\n    } else {\n        // do a single update\n        if ($20a75b51695be07d$var$apply_impulse) {\n            $20a75b51695be07d$var$update_cpu($20a75b51695be07d$var$balldata_cpu, $20a75b51695be07d$var$balldata_cpu, $20a75b51695be07d$var$theoretical_impulse[0], $20a75b51695be07d$var$theoretical_impulse[1]);\n            $20a75b51695be07d$var$apply_impulse = false;\n            $20a75b51695be07d$var$theoretical_impulse = [\n                0,\n                0\n            ];\n        } else $20a75b51695be07d$var$update_cpu($20a75b51695be07d$var$balldata_cpu, $20a75b51695be07d$var$balldata_cpu, 0, 0);\n        // copy cpu to gpu\n        $20a75b51695be07d$var$gl.bindBuffer($20a75b51695be07d$var$gl.ARRAY_BUFFER, $20a75b51695be07d$var$balldata_gpu_1);\n        $20a75b51695be07d$var$gl.bufferSubData($20a75b51695be07d$var$gl.ARRAY_BUFFER, 0, $20a75b51695be07d$var$balldata_cpu);\n        $20a75b51695be07d$var$gl.bindBuffer($20a75b51695be07d$var$gl.ARRAY_BUFFER, null);\n        // draw the present\n        $20a75b51695be07d$var$gl.useProgram($20a75b51695be07d$var$draw_pinfo.program);\n        $20a75b51695be07d$var$gl.bindVertexArray($20a75b51695be07d$var$draw_1_vao.vertexArrayObject);\n        $20a75b51695be07d$var$gl.drawArrays($20a75b51695be07d$var$gl.POINTS, 0, $20a75b51695be07d$var$n_universes * $20a75b51695be07d$var$n_balls);\n    }\n    // on the other hand, predict the future!\n    if ($20a75b51695be07d$var$use_gpu) {\n        let cur_buffers = $20a75b51695be07d$var$buffers_1to2;\n        let next_buffers = $20a75b51695be07d$var$buffers_2to1;\n        $20a75b51695be07d$var$gl.useProgram($20a75b51695be07d$var$update_program);\n        $20a75b51695be07d$var$gl.enable($20a75b51695be07d$var$gl.RASTERIZER_DISCARD);\n        for(let k = 0; k < $20a75b51695be07d$var$n_updates; k++){\n            if (k > 0) {\n                const temp = cur_buffers;\n                cur_buffers = next_buffers;\n                next_buffers = temp;\n            }\n            $20a75b51695be07d$var$gl.bindVertexArray(cur_buffers.update_vao);\n            if (k === 0) $20a75b51695be07d$var$gl.uniform2f($20a75b51695be07d$var$u_impulse_loc, $20a75b51695be07d$var$theoretical_impulse[0], $20a75b51695be07d$var$theoretical_impulse[1]);\n            else $20a75b51695be07d$var$gl.uniform2f($20a75b51695be07d$var$u_impulse_loc, 0, 0);\n            $20a75b51695be07d$var$gl.bindTransformFeedback($20a75b51695be07d$var$gl.TRANSFORM_FEEDBACK, cur_buffers.tf);\n            $20a75b51695be07d$var$gl.beginTransformFeedback($20a75b51695be07d$var$gl.POINTS);\n            $20a75b51695be07d$var$gl.drawArrays($20a75b51695be07d$var$gl.POINTS, 0, $20a75b51695be07d$var$n_universes);\n            $20a75b51695be07d$var$gl.endTransformFeedback();\n        }\n        $20a75b51695be07d$var$gl.disable($20a75b51695be07d$var$gl.RASTERIZER_DISCARD);\n        $20a75b51695be07d$var$gl.bindTransformFeedback($20a75b51695be07d$var$gl.TRANSFORM_FEEDBACK, null);\n        // draw the future!\n        $20a75b51695be07d$var$gl.useProgram($20a75b51695be07d$var$draw_pinfo.program);\n        $20a75b51695be07d$var$gl.bindVertexArray(cur_buffers.draw_vao);\n        $20a75b51695be07d$var$gl.drawArrays($20a75b51695be07d$var$gl.POINTS, 0, $20a75b51695be07d$var$n_universes * $20a75b51695be07d$var$n_balls);\n    } else {\n        $20a75b51695be07d$var$update_cpu($20a75b51695be07d$var$balldata_cpu, $20a75b51695be07d$var$balldata_cpu_helper, $20a75b51695be07d$var$theoretical_impulse[0], $20a75b51695be07d$var$theoretical_impulse[1]);\n        for(let k = 1; k < $20a75b51695be07d$var$n_updates; k++)$20a75b51695be07d$var$update_cpu($20a75b51695be07d$var$balldata_cpu_helper, $20a75b51695be07d$var$balldata_cpu_helper, 0, 0);\n        // copy cpu to gpu\n        $20a75b51695be07d$var$gl.bindBuffer($20a75b51695be07d$var$gl.ARRAY_BUFFER, $20a75b51695be07d$var$balldata_gpu_2);\n        $20a75b51695be07d$var$gl.bufferSubData($20a75b51695be07d$var$gl.ARRAY_BUFFER, 0, $20a75b51695be07d$var$balldata_cpu_helper);\n        $20a75b51695be07d$var$gl.bindBuffer($20a75b51695be07d$var$gl.ARRAY_BUFFER, null);\n        // draw the present\n        $20a75b51695be07d$var$gl.useProgram($20a75b51695be07d$var$draw_pinfo.program);\n        $20a75b51695be07d$var$gl.bindVertexArray($20a75b51695be07d$var$draw_2_vao.vertexArrayObject);\n        $20a75b51695be07d$var$gl.drawArrays($20a75b51695be07d$var$gl.POINTS, 0, $20a75b51695be07d$var$n_universes * $20a75b51695be07d$var$n_balls);\n    }\n    requestAnimationFrame($20a75b51695be07d$var$update);\n}\n// const line_pinfo = twgl.createProgramInfo(gl, [\n//     // vs\n//     `#version 300 es\n//     in vec2 pos;\n//     void main() {\n//         gl_Position = vec4(pos, 0.0, 1.0);\n//     }\n//     `,\n//     // fs\n//     `#version 300 es\n//     precision highp float;\n//     out vec4 out_color;\n//     void main() {\n//         out_color = vec4(1.0);\n//     }\n//     `\n// ]);\n// n_universes * n_balls * 4\n// [b0px,b0py,b0vx,b0vy,b1...,b2...,b0px,b0py,b0vx,b0vy,b1...,b2...,....]\nfunction $20a75b51695be07d$var$update_cpu(src, dst, impulse_x, impulse_y) {\n    const bounce = .9;\n    const drag = .99;\n    const dt = .01;\n    // individual updates\n    let k = 0;\n    for(let universe = 0; universe < $20a75b51695be07d$var$n_universes; universe++)for(let ball = 0; ball < $20a75b51695be07d$var$n_balls; ball++){\n        let new_vx = src[k + 2] * drag;\n        let new_vy = src[k + 3] * drag;\n        let new_px = src[k + 0] + dt * src[k + 2];\n        let new_py = src[k + 1] + dt * src[k + 3];\n        if (ball === 0) {\n            new_px += dt * impulse_x;\n            new_py += dt * impulse_y;\n            new_vx += impulse_x;\n            new_vy += impulse_y;\n        }\n        if (Math.abs(new_px) > 1.0 - $20a75b51695be07d$var$ball_r) {\n            new_px = Math.sign(new_px) * (2.0 - 2.0 * $20a75b51695be07d$var$ball_r) - src[k + 0];\n            new_vx = -new_vx;\n        }\n        if (Math.abs(new_py) > 1.0 - $20a75b51695be07d$var$ball_r) {\n            new_py = Math.sign(new_py) * (2.0 - 2.0 * $20a75b51695be07d$var$ball_r) - src[k + 1];\n            new_vy = -new_vy;\n        }\n        dst[k + 0] = new_px;\n        dst[k + 1] = new_py;\n        dst[k + 2] = new_vx;\n        dst[k + 3] = new_vy;\n        k += 4;\n    }\n    // collision\n    for(let universe = 0; universe < $20a75b51695be07d$var$n_universes; universe++)for(let ball_i = 0; ball_i < $20a75b51695be07d$var$n_balls; ball_i++){\n        let index_i = (universe * $20a75b51695be07d$var$n_balls + ball_i) * 4;\n        for(let ball_j = ball_i + 1; ball_j < $20a75b51695be07d$var$n_balls; ball_j++){\n            let index_j = (universe * $20a75b51695be07d$var$n_balls + ball_j) * 4;\n            let delta_x = dst[index_i + 0] - dst[index_j + 0];\n            let delta_y = dst[index_i + 1] - dst[index_j + 1];\n            let dist_sq = delta_x * delta_x + delta_y * delta_y;\n            if (dist_sq > 0.0 && dist_sq < 4 * $20a75b51695be07d$var$ball_r * $20a75b51695be07d$var$ball_r) {\n                let dist = Math.sqrt(dist_sq);\n                // assumption: all balls have the same mass\n                // intuition: the balls exchange their momentum\n                // but only on the direction joining them\n                // 1. avoid overlap\n                let push = (2 * $20a75b51695be07d$var$ball_r - dist) * .5 * bounce / dist;\n                dst[index_i + 0] += delta_x * push;\n                dst[index_i + 1] += delta_y * push;\n                dst[index_j + 0] -= delta_x * push;\n                dst[index_j + 1] -= delta_y * push;\n                // 2. exchange momentums\n                let momentum = (delta_x * dst[index_i + 2] + delta_y * dst[index_i + 3] - (delta_x * dst[index_j + 2] + delta_y * dst[index_j + 3])) / dist_sq;\n                dst[index_i + 2] -= momentum * delta_x;\n                dst[index_i + 3] -= momentum * delta_y;\n                dst[index_j + 2] += momentum * delta_x;\n                dst[index_j + 3] += momentum * delta_y;\n            }\n        }\n    }\n}\nrequestAnimationFrame($20a75b51695be07d$var$update);\n\n})();\n//# sourceMappingURL=index.832e1807.js.map\n","import * as twgl from \"twgl.js\"\r\n\r\nimport Stats from \"stats.js\"\r\nimport { fromCount, fromRange } from \"../kommon/kommon\";\r\nvar stats = new Stats();\r\nstats.showPanel(0);\r\ndocument.body.appendChild(stats.dom);\r\n\r\n//// init\r\nconst canvas = document.querySelector(\"#c\")! as HTMLCanvasElement;\r\nconst gl = canvas.getContext(\"webgl2\", { alpha: false })!;\r\ngl.clearColor(0.5, 0.5, 0.75, 1.0);\r\ngl.enable(gl.BLEND);\r\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n\r\n// game logic\r\nconst use_gpu = false;\r\nconst n_updates = 100;\r\nconst n_universes = 500;\r\nconst n_balls = 4;\r\nconst ball_r = .05;\r\nconst chaos = .01;\r\n\r\nconst update_program = twgl.createProgramFromSources(gl, [\r\n    // vs\r\n    `#version 300 es\r\n\r\n    precision highp float;\r\n\r\n    #define ball_r ${(ball_r).toFixed(10)}\r\n    #define bounce .9\r\n    #define drag .99\r\n    #define dt 0.01\r\n\r\n    ${fromCount(n_balls, i => {\r\n        return `in vec4 old_b${i}; out vec4 new_b${i};`\r\n    }).join(\"\\n\")}\r\n\r\n    uniform vec2 u_impulse;\r\n\r\n    // pos, vel for each ball\r\n    void collide(in vec4 b1, in vec4 b2, out vec4 r1, out vec4 r2) {\r\n        r1 = b1;\r\n        r2 = b2;\r\n\r\n        vec2 delta = b1.xy - b2.xy;\r\n        float distSq = dot(delta, delta);\r\n        if (distSq > 0.0 && distSq < 4.0 * ball_r * ball_r) {\r\n            float dist = sqrt(distSq);\r\n            // assumption: all balls have the same mass\r\n            // intuition: the balls exchange their momentum\r\n            // but only on the direction joining them\r\n\r\n            // 1. avoid overlap\r\n            float push = (2.0 * ball_r - dist) * .5 * bounce / dist;\r\n            r1.xy += delta * push;\r\n            r2.xy -= delta * push;\r\n\r\n            // 2. exchange momentums\r\n            vec2 momentum = delta * (dot(delta, b1.zw) - dot(delta, b2.zw)) / distSq;\r\n            r1.zw -= momentum;\r\n            r2.zw += momentum;\r\n        }        \r\n    }\r\n\r\n    vec4 individualUpdate(vec4 ball) {\r\n        // movement\r\n        vec4 res = vec4(ball.xy + dt * ball.zw, ball.zw);\r\n        // bounce\r\n        if (abs(res.x) > 1.0 - ball_r) {\r\n            res.x = sign(res.x) * (2.0 - 2.0 * ball_r) - ball.x;\r\n            res.z = -ball.z;\r\n        }\r\n        if (abs(res.y) > 1.0 - ball_r) {\r\n            res.y = sign(res.y) * (2.0 - 2.0 * ball_r) - ball.y;\r\n            res.w = -ball.w;\r\n        }\r\n        // drag\r\n        res.zw *= drag;\r\n        return res;\r\n    }\r\n\r\n    void main() {\r\n        new_b0 = individualUpdate(vec4(old_b0.xy, old_b0.zw + u_impulse));\r\n    ${fromRange(1, n_balls, i => {\r\n        return `new_b${i} = individualUpdate(old_b${i});`\r\n    }).join(\"\\n\")}\r\n        // collision\r\n        // generate this code:\r\n        // collide(new_b0, new_b1, new_b0, new_b1);\r\n        // collide(0, 2) ...\r\n        // collide(0, n_balls-1)\r\n        // collide(1, 2) ...\r\n        // collide(1, n_balls-1)\r\n        // ...\r\n        // collide(n_balls - 2, n_balls-1)\r\n    ${fromRange(0, n_balls, i => {\r\n        return fromRange(i + 1, n_balls, j => {\r\n            return `collide(new_b${i}, new_b${j}, new_b${i}, new_b${j});`;\r\n        }).join(\"\\n\");\r\n    }).join(\"\\n\")}\r\n    }\r\n    `,\r\n    // fs\r\n    `#version 300 es\r\n    precision highp float;\r\n\r\n    void main() {}\r\n    `\r\n], {\r\n    transformFeedbackVaryings: fromRange(0, n_balls, k => `new_b${k}`),\r\n    transformFeedbackMode: gl.INTERLEAVED_ATTRIBS,\r\n});\r\n\r\nconst ball_start_pos = fromCount(n_balls, k => [(Math.random() - .5) * (2 - ball_r), (Math.random() - .5) * (2 - ball_r)]);\r\n// const ball_start_pos = [\r\n//     [.5, 0],\r\n//     [0, ball_r],\r\n//     [0, -ball_r],\r\n//     [-Math.sqrt(3) * ball_r, 0],\r\n// ]\r\n\r\n// px,py,vx,vy for each ball\r\n// [b0px,b0py,b0vx,b0vy,b1...,b2...,b0px,b0py,b0vx,b0vy,b1...,b2...,....]\r\nconst balldata_cpu = new Float32Array(n_universes * n_balls * 4);\r\nfor (let b = 0; b < n_balls; b++) {\r\n    for (let k = 0; k < n_universes; k++) {\r\n        let base_index = (k * n_balls + b) * 4;\r\n        balldata_cpu[base_index + 0] = ball_start_pos[b][0];\r\n        balldata_cpu[base_index + 1] = ball_start_pos[b][1];\r\n    }\r\n}\r\n// initial chaos\r\nfor (let k = 0; k < n_universes; k++) {\r\n    const ang = Math.PI * 2 * k / n_universes;\r\n    balldata_cpu[k * n_balls * 4 + 0] += Math.cos(ang) * chaos;\r\n    balldata_cpu[k * n_balls * 4 + 1] += Math.sin(ang) * chaos;\r\n}\r\n\r\n// double buffer pattern\r\nconst balldata_gpu_1 = twgl.createBufferFromTypedArray(gl, balldata_cpu, gl.ARRAY_BUFFER, gl.DYNAMIC_DRAW);\r\nconst balldata_gpu_2 = twgl.createBufferFromTypedArray(gl, balldata_cpu, gl.ARRAY_BUFFER, gl.DYNAMIC_DRAW);\r\n\r\nconst draw_pinfo = twgl.createProgramInfo(gl, [\r\n    // vs\r\n    `#version 300 es\r\n\r\n    #define n_balls ${(n_balls).toFixed(10)}\r\n\r\n    in vec2 pos;\r\n\r\n    out vec3 v_ball_color;\r\n\r\n    vec3 hsl2rgb(in vec3 c) {\r\n        vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\r\n        return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\r\n    }\r\n\r\n\r\n    void main() {\r\n        gl_Position = vec4(pos, 0.0, 1.0);\r\n        gl_PointSize = ${(gl.canvas.width * 2 * ball_r).toFixed(10)};\r\n        v_ball_color = hsl2rgb(vec3(float(gl_VertexID) / n_balls, 0.85, 0.5));\r\n        // v_ball_color = mix(vec3(1.0, 0, 0), vec3(0.0, 1, 0), mod(float(gl_VertexID), n_balls) / n_balls);\r\n    }\r\n    `,\r\n    // fs\r\n    `#version 300 es\r\n    precision highp float;\r\n\r\n    in vec3 v_ball_color;\r\n\r\n    out vec4 out_color;\r\n    \r\n    void main() {\r\n        float distSq = dot(gl_PointCoord - .5, gl_PointCoord - .5);\r\n        float alpha = smoothstep(.25, .20, distSq);\r\n        float outline = smoothstep(.27, .20, distSq);\r\n        out_color = vec4(v_ball_color * outline, alpha * .1);\r\n    }\r\n    `\r\n]);\r\n\r\nconst draw_1_vao = twgl.createVertexArrayInfo(gl, draw_pinfo, twgl.createBufferInfoFromArrays(gl, {\r\n    pos: {\r\n        buffer: balldata_gpu_1,\r\n        numComponents: 2,\r\n        stride: 4 * 4, // in bytes\r\n        type: Float32Array,\r\n    },\r\n}));\r\nconst draw_2_vao = twgl.createVertexArrayInfo(gl, draw_pinfo, twgl.createBufferInfoFromArrays(gl, {\r\n    pos: {\r\n        buffer: balldata_gpu_2,\r\n        numComponents: 2,\r\n        stride: 4 * 4, // in bytes\r\n        type: Float32Array,\r\n    },\r\n}));\r\n\r\nconst u_impulse_loc = gl.getUniformLocation(update_program, \"u_impulse\");\r\nconst old_b_locs = fromCount(n_balls, k => {\r\n    return gl.getAttribLocation(update_program, `old_b${k}`);\r\n});\r\n\r\nconst vao_update_1to2 = gl.createVertexArray()!;\r\ngl.bindVertexArray(vao_update_1to2);\r\ngl.bindBuffer(gl.ARRAY_BUFFER, balldata_gpu_1);\r\nfor (let k = 0; k < n_balls; k++) {\r\n    gl.enableVertexAttribArray(old_b_locs[k]);\r\n    gl.vertexAttribPointer(old_b_locs[k],\r\n        4, // size\r\n        gl.FLOAT,\r\n        false, // normalize\r\n        n_balls * 4 * 4, // stride in bytes, each universe is has n_balls*4 float32\r\n        16 * k, // offset in bytes\r\n    )\r\n}\r\n\r\nconst vao_update_2to1 = gl.createVertexArray()!;\r\ngl.bindVertexArray(vao_update_2to1);\r\ngl.bindBuffer(gl.ARRAY_BUFFER, balldata_gpu_2);\r\nfor (let k = 0; k < n_balls; k++) {\r\n    gl.enableVertexAttribArray(old_b_locs[k]);\r\n    gl.vertexAttribPointer(old_b_locs[k],\r\n        4, // size\r\n        gl.FLOAT,\r\n        false, // normalize\r\n        n_balls * 4 * 4, // stride in bytes, each universe is has n_balls*4 float32\r\n        16 * k, // offset in bytes\r\n    )\r\n}\r\n\r\ngl.bindVertexArray(null);\r\n\r\nconst tf_2to1 = gl.createTransformFeedback()!;\r\ngl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf_2to1);\r\ngl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, balldata_gpu_1);\r\n\r\nconst tf_1to2 = gl.createTransformFeedback()!;\r\ngl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf_1to2);\r\ngl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, balldata_gpu_2);\r\n\r\n// unbind left over stuff\r\ngl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\r\ngl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n\r\nlet buffers_1to2 = {\r\n    update_vao: vao_update_1to2, // read from position 1\r\n    tf: tf_1to2,                 // write to position 2\r\n    draw_vao: draw_2_vao.vertexArrayObject!,  // draw with position 2\r\n}\r\n\r\nlet buffers_2to1 = {\r\n    update_vao: vao_update_2to1, // read from position 2\r\n    tf: tf_2to1,                 // write to position 1\r\n    draw_vao: draw_1_vao.vertexArrayObject!,  // draw with position 1\r\n}\r\n\r\ntype Vec2 = number[];\r\nlet last_click_pos: Vec2 | null = null;\r\nlet theoretical_impulse: Vec2 = [0, 0];\r\nlet apply_impulse = false;\r\n\r\ndocument.addEventListener(\"mousedown\", ev => {\r\n    last_click_pos = [ev.offsetX, ev.offsetY];\r\n});\r\n\r\ndocument.addEventListener(\"mouseup\", ev => {\r\n    apply_impulse = true;\r\n    last_click_pos = null;\r\n});\r\n\r\ndocument.addEventListener(\"mousemove\", ev => {\r\n    if (last_click_pos !== null) {\r\n        let cur_pos = [ev.offsetX, ev.offsetY];\r\n        const force = .01;\r\n        theoretical_impulse = [-(cur_pos[0] - last_click_pos[0]) * force, (cur_pos[1] - last_click_pos[1]) * force];\r\n    }\r\n});\r\n\r\nlet balldata_cpu_helper = new Float32Array(balldata_cpu.length);\r\n\r\nlet last_time = 0;\r\nfunction update(cur_time) {\r\n    stats.update();\r\n    if (twgl.resizeCanvasToDisplaySize(canvas)) {\r\n        // on resize\r\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n    }\r\n    let delta = cur_time - last_time;\r\n    last_time = cur_time;\r\n\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n    // ground truth is the cpu\r\n\r\n    if (use_gpu) {\r\n        // copy cpu to gpu\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, balldata_gpu_1);\r\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, balldata_cpu);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n\r\n        // do a single update...\r\n        gl.useProgram(update_program);\r\n        gl.enable(gl.RASTERIZER_DISCARD);\r\n        gl.bindVertexArray(vao_update_1to2);\r\n        if (apply_impulse) {\r\n            gl.uniform2f(u_impulse_loc, theoretical_impulse[0], theoretical_impulse[1]);\r\n            apply_impulse = false;\r\n            theoretical_impulse = [0, 0];\r\n        } else {\r\n            gl.uniform2f(u_impulse_loc, 0, 0);\r\n        }\r\n        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf_1to2);\r\n        gl.beginTransformFeedback(gl.POINTS);\r\n        gl.drawArrays(gl.POINTS, 0, n_universes);\r\n        gl.endTransformFeedback();\r\n        gl.disable(gl.RASTERIZER_DISCARD);\r\n        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\r\n\r\n        // ...and copy the result back to the cpu\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, balldata_gpu_2);\r\n        gl.getBufferSubData(gl.ARRAY_BUFFER, 0, balldata_cpu);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n\r\n        // draw the present\r\n        gl.useProgram(draw_pinfo.program);\r\n        gl.bindVertexArray(draw_2_vao.vertexArrayObject!);\r\n        gl.drawArrays(gl.POINTS, 0, n_universes * n_balls);\r\n    } else {\r\n        // do a single update\r\n        if (apply_impulse) {\r\n            update_cpu(balldata_cpu, balldata_cpu, theoretical_impulse[0], theoretical_impulse[1]);\r\n            apply_impulse = false;\r\n            theoretical_impulse = [0, 0];\r\n        } else {\r\n            update_cpu(balldata_cpu, balldata_cpu, 0, 0);\r\n        }\r\n        // copy cpu to gpu\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, balldata_gpu_1);\r\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, balldata_cpu);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n        // draw the present\r\n        gl.useProgram(draw_pinfo.program);\r\n        gl.bindVertexArray(draw_1_vao.vertexArrayObject!);\r\n        gl.drawArrays(gl.POINTS, 0, n_universes * n_balls);\r\n    }\r\n\r\n    // on the other hand, predict the future!\r\n    if (use_gpu) {\r\n        let cur_buffers = buffers_1to2;\r\n        let next_buffers = buffers_2to1;\r\n        gl.useProgram(update_program);\r\n        gl.enable(gl.RASTERIZER_DISCARD);\r\n        for (let k = 0; k < n_updates; k++) {\r\n            if (k > 0) {\r\n                const temp = cur_buffers;\r\n                cur_buffers = next_buffers;\r\n                next_buffers = temp;\r\n            }\r\n            gl.bindVertexArray(cur_buffers.update_vao);\r\n            if (k === 0) {\r\n                gl.uniform2f(u_impulse_loc, theoretical_impulse[0], theoretical_impulse[1]);\r\n            } else {\r\n                gl.uniform2f(u_impulse_loc, 0, 0);\r\n            }\r\n            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, cur_buffers.tf);\r\n            gl.beginTransformFeedback(gl.POINTS);\r\n            gl.drawArrays(gl.POINTS, 0, n_universes);\r\n            gl.endTransformFeedback();\r\n        }\r\n        gl.disable(gl.RASTERIZER_DISCARD);\r\n        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\r\n\r\n        // draw the future!\r\n        gl.useProgram(draw_pinfo.program);\r\n        gl.bindVertexArray(cur_buffers.draw_vao);\r\n        gl.drawArrays(gl.POINTS, 0, n_universes * n_balls);\r\n    } else {\r\n        update_cpu(balldata_cpu, balldata_cpu_helper, theoretical_impulse[0], theoretical_impulse[1]);\r\n        for (let k = 1; k < n_updates; k++) {\r\n            update_cpu(balldata_cpu_helper, balldata_cpu_helper, 0, 0);\r\n        }\r\n        // copy cpu to gpu\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, balldata_gpu_2);\r\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, balldata_cpu_helper);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n        // draw the present\r\n        gl.useProgram(draw_pinfo.program);\r\n        gl.bindVertexArray(draw_2_vao.vertexArrayObject!);\r\n        gl.drawArrays(gl.POINTS, 0, n_universes * n_balls);\r\n    }\r\n\r\n    requestAnimationFrame(update);\r\n}\r\n\r\n// const line_pinfo = twgl.createProgramInfo(gl, [\r\n//     // vs\r\n//     `#version 300 es\r\n\r\n//     in vec2 pos;\r\n\r\n//     void main() {\r\n//         gl_Position = vec4(pos, 0.0, 1.0);\r\n//     }\r\n//     `,\r\n//     // fs\r\n//     `#version 300 es\r\n//     precision highp float;\r\n\r\n//     out vec4 out_color;\r\n\r\n//     void main() {\r\n//         out_color = vec4(1.0);\r\n//     }\r\n//     `\r\n// ]);\r\n\r\n// n_universes * n_balls * 4\r\n// [b0px,b0py,b0vx,b0vy,b1...,b2...,b0px,b0py,b0vx,b0vy,b1...,b2...,....]\r\nfunction update_cpu(src: Float32Array, dst: Float32Array, impulse_x: number, impulse_y: number) {\r\n    const bounce = .9;\r\n    const drag = .99;\r\n    const dt = .01;\r\n\r\n    // individual updates\r\n    let k = 0;\r\n    for (let universe = 0; universe < n_universes; universe++) {\r\n        for (let ball = 0; ball < n_balls; ball++) {\r\n            let new_vx = src[k + 2] * drag;\r\n            let new_vy = src[k + 3] * drag;\r\n            let new_px = src[k + 0] + dt * src[k + 2];\r\n            let new_py = src[k + 1] + dt * src[k + 3];\r\n            if (ball === 0) {\r\n                new_px += dt * impulse_x;\r\n                new_py += dt * impulse_y;\r\n                new_vx += impulse_x;\r\n                new_vy += impulse_y;\r\n            }\r\n            if (Math.abs(new_px) > 1.0 - ball_r) {\r\n                new_px = Math.sign(new_px) * (2.0 - 2.0 * ball_r) - src[k + 0];\r\n                new_vx = -new_vx;\r\n            }\r\n            if (Math.abs(new_py) > 1.0 - ball_r) {\r\n                new_py = Math.sign(new_py) * (2.0 - 2.0 * ball_r) - src[k + 1];\r\n                new_vy = -new_vy;\r\n            }\r\n            dst[k + 0] = new_px;\r\n            dst[k + 1] = new_py;\r\n            dst[k + 2] = new_vx;\r\n            dst[k + 3] = new_vy;\r\n            k += 4;\r\n        }\r\n    }\r\n\r\n    // collision\r\n    for (let universe = 0; universe < n_universes; universe++) {\r\n        for (let ball_i = 0; ball_i < n_balls; ball_i++) {\r\n            let index_i = (universe * n_balls + ball_i) * 4;\r\n            for (let ball_j = ball_i + 1; ball_j < n_balls; ball_j++) {\r\n                let index_j = (universe * n_balls + ball_j) * 4;\r\n                let delta_x = dst[index_i + 0] - dst[index_j + 0];\r\n                let delta_y = dst[index_i + 1] - dst[index_j + 1];\r\n                let dist_sq = delta_x * delta_x + delta_y * delta_y;\r\n                if (dist_sq > 0.0 && dist_sq < 4 * ball_r * ball_r) {\r\n                    let dist = Math.sqrt(dist_sq);\r\n                    // assumption: all balls have the same mass\r\n                    // intuition: the balls exchange their momentum\r\n                    // but only on the direction joining them\r\n\r\n                    // 1. avoid overlap\r\n                    let push = (2 * ball_r - dist) * .5 * bounce / dist;\r\n                    dst[index_i + 0] += delta_x * push;\r\n                    dst[index_i + 1] += delta_y * push;\r\n                    dst[index_j + 0] -= delta_x * push;\r\n                    dst[index_j + 1] -= delta_y * push;\r\n\r\n                    // 2. exchange momentums\r\n                    let momentum = (\r\n                        (delta_x * dst[index_i + 2] + delta_y * dst[index_i + 3])\r\n                        - (delta_x * dst[index_j + 2] + delta_y * dst[index_j + 3])\r\n                    ) / dist_sq;\r\n\r\n                    dst[index_i + 2] -= momentum * delta_x;\r\n                    dst[index_i + 3] -= momentum * delta_y;\r\n                    dst[index_j + 2] += momentum * delta_x;\r\n                    dst[index_j + 3] += momentum * delta_y;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nrequestAnimationFrame(update);\r\n","// stats.js - http://github.com/mrdoob/stats.js\n(function(f,e){\"object\"===typeof exports&&\"undefined\"!==typeof module?module.exports=e():\"function\"===typeof define&&define.amd?define(e):f.Stats=e()})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();\nu(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel(\"FPS\",\"#0ff\",\"#002\")),h=e(new f.Panel(\"MS\",\"#0f0\",\"#020\"));if(self.performance&&self.performance.memory)var t=e(new f.Panel(\"MB\",\"#f08\",\"#201\"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/\n1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=h;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);\nb.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+\" \"+e+\" (\"+g(c)+\"-\"+g(k)+\")\",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});\n","export function fromCount<T>(n: number, callback: (index: number) => T): T[] {\r\n    let result = Array(n);\r\n    for (let k = 0; k < n; k++) {\r\n        result[k] = callback(k);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function fromRange<T>(lo: number, hi: number, callback: (index: number) => T): T[] {\r\n    let count = hi - lo;\r\n    let result = Array(count);\r\n    for (let k = 0; k < count; k++) {\r\n        result[k] = callback(k + lo);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function* zip(...arrays: Iterable<any>[]): Generator<any> {\r\n    let iterators = arrays.map(a => a[Symbol.iterator]());\r\n    while (true) {\r\n        let nexts = iterators.map(a => a.next());\r\n        let done = nexts.some(n => n.done);\r\n        if (done) return;\r\n        yield nexts.map(n => n.value);\r\n    }\r\n}\r\n\r\nexport function objectMap<T, S>(object: Record<string, T>, map_fn: (x: T) => S): Record<string, S> {\r\n    let result: Record<string, S> = {};\r\n    for (let [k, v] of Object.entries(object)) {\r\n        result[k] = map_fn(v);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport class DefaultDict<T> {\r\n    constructor(init_fn: () => T) {\r\n        // typing doesn't work :(\r\n        let target: Record<string | symbol | number, T> = {};\r\n        return new Proxy(target, {\r\n            get: (target, name): T => {\r\n                if (name in target) {\r\n                    return target[name];\r\n                } else {\r\n                    target[name] = init_fn();\r\n                    return target[name];\r\n                }\r\n            }\r\n        })\r\n    }\r\n}\r\n"],"names":["f","a","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$6MzNI","$a759912a70d9e191$exports","$e28a0cada894885c$export$9f0c37400c701bee","n","callback","result","Array","k","$e28a0cada894885c$export$f01e84010c13cebe","lo","hi","count","$20a75b51695be07d$var$stats","e","c","appendChild","dom","u","d","children","length","style","display","l","document","createElement","cssText","addEventListener","preventDefault","performance","Date","now","g","r","Panel","h","memory","t","REVISION","addPanel","showPanel","begin","end","update","usedJSHeapSize","jsHeapSizeLimit","domElement","setMode","Infinity","Math","round","devicePixelRatio","v","m","p","q","width","height","b","getContext","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","w","min","max","drawImage","__esModule","default","body","$20a75b51695be07d$var$canvas","querySelector","$20a75b51695be07d$var$gl","alpha","clearColor","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","$20a75b51695be07d$var$update_program","createProgramFromSources","$20a75b51695be07d$var$ball_r","toFixed","i","join","j","transformFeedbackVaryings","transformFeedbackMode","INTERLEAVED_ATTRIBS","$20a75b51695be07d$var$ball_start_pos","random","$20a75b51695be07d$var$balldata_cpu","Float32Array","$20a75b51695be07d$var$n_universes","base_index","ang","PI","cos","sin","$20a75b51695be07d$var$balldata_gpu_1","createBufferFromTypedArray","ARRAY_BUFFER","DYNAMIC_DRAW","$20a75b51695be07d$var$balldata_gpu_2","$20a75b51695be07d$var$draw_pinfo","createProgramInfo","$20a75b51695be07d$var$n_balls","canvas","$20a75b51695be07d$var$draw_1_vao","createVertexArrayInfo","createBufferInfoFromArrays","pos","buffer","numComponents","stride","type","$20a75b51695be07d$var$draw_2_vao","$20a75b51695be07d$var$old_b_locs","getUniformLocation","getAttribLocation","$20a75b51695be07d$var$vao_update_1to2","createVertexArray","bindVertexArray","bindBuffer","enableVertexAttribArray","vertexAttribPointer","FLOAT","$20a75b51695be07d$var$vao_update_2to1","$20a75b51695be07d$var$tf_2to1","createTransformFeedback","bindTransformFeedback","TRANSFORM_FEEDBACK","bindBufferBase","TRANSFORM_FEEDBACK_BUFFER","$20a75b51695be07d$var$tf_1to2","vertexArrayObject","$20a75b51695be07d$var$last_click_pos","$20a75b51695be07d$var$theoretical_impulse","$20a75b51695be07d$var$apply_impulse","ev","offsetX","offsetY","cur_pos","$20a75b51695be07d$var$balldata_cpu_helper","$20a75b51695be07d$var$update_cpu","src","dst","impulse_x","impulse_y","universe","ball","new_vx","new_vy","new_px","dt","new_py","abs","sign","ball_i","index_i","ball_j","index_j","delta_x","delta_y","dist_sq","dist","sqrt","push","momentum","requestAnimationFrame","$20a75b51695be07d$var$update","cur_time","resizeCanvasToDisplaySize","viewport","drawingBufferWidth","drawingBufferHeight","clear","COLOR_BUFFER_BIT","bufferSubData","useProgram","program","drawArrays","POINTS"],"version":3,"file":"index.832e1807.js.map"}